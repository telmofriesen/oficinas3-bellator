   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 2
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"bellator_low_level.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  23              	log_char:
  24              		.fnstart
  25              	.LFB1:
  26              		.file 1 "logger.c"
   1:logger.c      **** /*
   2:logger.c      ****  * logger.c
   3:logger.c      ****  *
   4:logger.c      ****  *  Created on: Jul 14, 2009
   5:logger.c      ****  *      Author: telmo
   6:logger.c      ****  */
   7:logger.c      **** #include "lpc2103.h"
   8:logger.c      **** #include "logger.h"
   9:logger.c      **** 
  10:logger.c      **** /**
  11:logger.c      ****  * Start logger using UART0
  12:logger.c      ****  * 8N1 (8 data, Non parity, 1 stop)
  13:logger.c      ****  * 115200 bps
  14:logger.c      ****  *
  15:logger.c      ****  * UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL) * ( 1 + DivAddVal/MulVal))
  16:logger.c      ****  * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
  17:logger.c      ****  * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
  18:logger.c      ****  * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
  19:logger.c      ****  */
  20:logger.c      **** void logger_init(void){ // using UART0
  21:logger.c      **** 	PINSEL0 |= 0x05; // Set the pins function
  22:logger.c      **** 	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
  23:logger.c      **** 	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
  24:logger.c      **** 
  25:logger.c      **** #ifdef CRYSTAL12MHz
  26:logger.c      **** 	U0DLL	 = 0x06; // DivisorLatchLow bit
  27:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
  28:logger.c      **** 	U0FDR	|= 0x05; // DivAddVal
  29:logger.c      **** 	U0FDR	|= 0x0E << 4; // MulVal = 14
  30:logger.c      **** #endif
  31:logger.c      **** #ifdef CRYSTAL14745600Hz
  32:logger.c      **** 	U0DLL	 = 0x08; // DivisorLatchLow bit
  33:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
  34:logger.c      **** #endif
  35:logger.c      **** 
  36:logger.c      **** 	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
  37:logger.c      **** }
  38:logger.c      **** 
  39:logger.c      **** static void log_char(char c){
  27              		.loc 1 39 0
  28              		.cfi_startproc
  29              		@ Function supports interworking.
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  40:logger.c      **** 	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
  34              		.loc 1 40 0
  35 0000 14309FE5 		ldr	r3, .L4
  36 0004 0000C3E5 		strb	r0, [r3, #0]
  41:logger.c      **** 	while(!(U0LSR & 0x40));
  37              		.loc 1 41 0
  38 0008 0320A0E1 		mov	r2, r3
  39              	.L2:
  40              		.loc 1 41 0 is_stmt 0 discriminator 1
  41 000c 1430D2E5 		ldrb	r3, [r2, #20]	@ zero_extendqisi2
  42 0010 400013E3 		tst	r3, #64
  43 0014 FCFFFF0A 		beq	.L2
  42:logger.c      **** }
  44              		.loc 1 42 0 is_stmt 1
  45 0018 1EFF2FE1 		bx	lr
  46              	.L5:
  47              		.align	2
  48              	.L4:
  49 001c 00C000E0 		.word	-536821760
  50              		.cfi_endproc
  51              	.LFE1:
  52              		.fnend
  54              		.align	2
  55              		.global	i2c_write_byte_isr
  57              	i2c_write_byte_isr:
  58              		.fnstart
  59              	.LFB21:
  60              		.file 2 "i2c.c"
   1:i2c.c         **** /*
   2:i2c.c         ****  * i2c.c
   3:i2c.c         ****  *
   4:i2c.c         ****  *  Created on: Mar 21, 2013
   5:i2c.c         ****  *      Author: telmo
   6:i2c.c         ****  */
   7:i2c.c         **** #include "lpc2103.h"
   8:i2c.c         **** #include "i2c.h"
   9:i2c.c         **** #include "logger.h"
  10:i2c.c         **** #include "mpu6050.h"
  11:i2c.c         **** 
  12:i2c.c         **** /**
  13:i2c.c         ****  * I2C 1
  14:i2c.c         ****  *
  15:i2c.c         ****  * I2Cbitfrequency = PCLK / ( I2C1SCLH + I2C1SCLL )
  16:i2c.c         ****  * 0 < I2Cbitfrequency < 400kHz
  17:i2c.c         ****  * I2C1SCLL >= 4, I2C1SCLH >=4
  18:i2c.c         ****  * pclk=15MHz or pclk=14.7456MHz, depending on previous configuration
  19:i2c.c         ****  *
  20:i2c.c         ****  * MPU Address: b1101000W
  21:i2c.c         ****  * W bit 0 => write on the mpu registers
  22:i2c.c         ****  * I2C Addr + Reg Addr + Data
  23:i2c.c         ****  * I2C Addr + Reg Addr + Data + Data for Addr+1, etc
  24:i2c.c         ****  * W bit 1 => read
  25:i2c.c         ****  */
  26:i2c.c         **** void i2c_init(void){
  27:i2c.c         **** 
  28:i2c.c         **** 	log_string_i2c(">> i2c_init\n");
  29:i2c.c         **** 
  30:i2c.c         **** 	// Set the pin function
  31:i2c.c         **** 	PINSEL1 |= 0x1 << 2; // SCL1
  32:i2c.c         **** 	PINSEL1 |= 0x1 << 4; // SDA1
  33:i2c.c         **** 
  34:i2c.c         **** 	I2C1CONCLR = 0x6C; // clear all flags
  35:i2c.c         **** 	I2C1CONSET |= 0x1 << 6; // enable i2c1
  36:i2c.c         **** 	I2C1SCLH = 19; // Set the bit rate:
  37:i2c.c         **** 	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
  38:i2c.c         **** 
  39:i2c.c         **** 	// Enable the interrupts
  40:i2c.c         **** 	VICVectCntl0 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
  41:i2c.c         **** 	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
  42:i2c.c         **** 
  43:i2c.c         **** 	// Enable i2c as FIQ
  44:i2c.c         **** 	//VICIntSelect |= 0x1 << 19;// I2C1 as FIQ
  45:i2c.c         **** 	//VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
  46:i2c.c         **** 
  47:i2c.c         **** 	log_string_i2c("<< i2c_init\n");
  48:i2c.c         **** }
  49:i2c.c         **** 
  50:i2c.c         **** //void i2c_isr(void) {
  51:i2c.c         **** //	(*current_isr)();
  52:i2c.c         **** //}
  53:i2c.c         **** 
  54:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
  55:i2c.c         **** 	log_string_i2c("read_byte\n");
  56:i2c.c         **** 
  57:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
  58:i2c.c         **** 
  59:i2c.c         **** 	log_string_i2c("read_byte..returning\n");
  60:i2c.c         **** 	return i;
  61:i2c.c         **** }
  62:i2c.c         **** 
  63:i2c.c         **** int i2c_read_bytes(char reg_addr, char length, char* data) {
  64:i2c.c         **** 	log_string_i2c(">> read_bytes\n");
  65:i2c.c         **** 
  66:i2c.c         **** 	buff_size = length;
  67:i2c.c         **** 	buff_pos = 0;
  68:i2c.c         **** 	ra_buff = reg_addr;
  69:i2c.c         **** 	c_buff = data;
  70:i2c.c         **** 
  71:i2c.c         **** 	busy = 1;
  72:i2c.c         **** 
  73:i2c.c         **** 	//Setting the interrupt handler location for write byte
  74:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_read_bytes_isr;
  75:i2c.c         **** 	//current_isr = &i2c_read_bytes_isr;
  76:i2c.c         **** 	// Send Start bit
  77:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
  78:i2c.c         **** 
  79:i2c.c         **** 	log_string_i2c("waiting\n");
  80:i2c.c         **** 
  81:i2c.c         **** 	while (busy); // busy wait for read process
  82:i2c.c         **** 
  83:i2c.c         **** 	log_string_i2c("<< read_bytes\n");
  84:i2c.c         **** 	return 1;
  85:i2c.c         **** }
  86:i2c.c         **** 
  87:i2c.c         **** /**
  88:i2c.c         ****  * i2c interrupt handler
  89:i2c.c         ****  */
  90:i2c.c         **** void i2c_read_bytes_isr(void) {
  91:i2c.c         **** 	log_string_i2c(">> read_bytes_isr\n");
  92:i2c.c         **** 	volatile int temp = 0;
  93:i2c.c         **** 	temp = I2C1STAT;
  94:i2c.c         **** 
  95:i2c.c         **** 	switch (temp) {
  96:i2c.c         **** 	case TW_START: // A START condition has been transmitted.
  97:i2c.c         **** 		log_string_i2c("TW_START\n");
  98:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
  99:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 100:i2c.c         **** 		break;
 101:i2c.c         **** 	case TW_REP_START: // A repeated START	condition has been transmitted.
 102:i2c.c         **** 		log_string_i2c("TW_REP_START\n");
 103:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_READ; // Slave address + Read
 104:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 105:i2c.c         **** 		break;
 106:i2c.c         **** 	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
 107:i2c.c         **** 		log_string_i2c("TW_MT_SLA_ACK\n");
 108:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 109:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 110:i2c.c         **** 		break;
 111:i2c.c         **** 	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
 112:i2c.c         **** 		log_string_i2c("TW_MT_SLA_NACK\n");
 113:i2c.c         **** 		break;
 114:i2c.c         **** 	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
 115:i2c.c         **** 		log_string_i2c("TW_MT_DATA_ACK\n");
 116:i2c.c         **** 		I2C1CONSET = 0x20; // Transmit start condition
 117:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 118:i2c.c         **** 		break;
 119:i2c.c         **** 	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
 120:i2c.c         **** 		log_string_i2c("TW_MT_DATA_NACK\n");
 121:i2c.c         **** 		break;
 122:i2c.c         **** 	case TW_MT_ARB_LOST: // Arbitration lost in SLA+R/W or Data bytes.
 123:i2c.c         **** 		log_string_i2c("TW_MT_ARB_LOST\n");
 124:i2c.c         **** 		break;
 125:i2c.c         **** 
 126:i2c.c         **** 	case TW_MR_SLA_ACK: // SLA+R has been transmitted; ACK has been received.
 127:i2c.c         **** 		log_string_i2c("TW_MR_SLA_ACK\n");
 128:i2c.c         **** 		if(buff_size > 1)
 129:i2c.c         **** 			I2C1CONSET = 0x04; // Transmit ACK on data receives
 130:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 131:i2c.c         **** 		break;
 132:i2c.c         **** 	case TW_MR_SLA_NACK: // SLA+R has been transmitted; NOT ACK or has been received.
 133:i2c.c         **** 		log_string_i2c("TW_MR_SLA_NACK\n");
 134:i2c.c         **** 		break;
 135:i2c.c         **** 	case TW_MR_DATA_ACK: // Data byte has been received; ACK has been returned.
 136:i2c.c         **** 		log_string_i2c("TW_MR_DATA_ACK\n");
 137:i2c.c         **** 		log_string_i2c("pos: ");
 138:i2c.c         **** 		log_int_i2c(buff_pos);
 139:i2c.c         **** 		log_string_i2c("\n");
 140:i2c.c         **** 		if ((buff_pos + 2) < buff_size) {
 141:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 142:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 143:i2c.c         **** 		}
 144:i2c.c         **** 		else {
 145:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 146:i2c.c         **** 			I2C1CONCLR = 0x0C; // Transmit NACK on next data receive, Clear SI
 147:i2c.c         **** 		}
 148:i2c.c         **** 		break;
 149:i2c.c         **** 	case TW_MR_DATA_NACK: // Data byte has been received; NOT ACK has been returned.
 150:i2c.c         **** 		log_string_i2c("TW_MR_DATA_NACK\n");
 151:i2c.c         **** 		log_string_i2c("pos: ");
 152:i2c.c         **** 		log_int_i2c(buff_pos);
 153:i2c.c         **** 		log_string_i2c("\n");
 154:i2c.c         **** 		if (buff_pos < buff_size) {
 155:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 156:i2c.c         **** 		}
 157:i2c.c         **** 		I2C1CONSET = 0x10; // Transmit stop condition
 158:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 159:i2c.c         **** 		busy = 0; // data ready to be returned
 160:i2c.c         **** 		break;
 161:i2c.c         **** 
 162:i2c.c         **** 	default:
 163:i2c.c         **** 		log_string_warning("[i2c] default: ");
 164:i2c.c         **** 		log_int_warning(temp);
 165:i2c.c         **** 		log_string_warning("\n");
 166:i2c.c         **** 		//I2C1CONSET = 0x10; // Transmit stop condition
 167:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 168:i2c.c         **** 		//busy = 0; // data ready to be returned
 169:i2c.c         **** 		break;
 170:i2c.c         **** 	}
 171:i2c.c         **** 
 172:i2c.c         **** 	VICVectAddr = 0;
 173:i2c.c         **** }
 174:i2c.c         **** 
 175:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 176:i2c.c         **** 	//      010 value to write
 177:i2c.c         **** 	// 76543210 bit numbers
 178:i2c.c         **** 	//    xxx   args: bitStart=4, length=3
 179:i2c.c         **** 	// 00011100 mask byte
 180:i2c.c         **** 	// 10101111 original value (sample)
 181:i2c.c         **** 	// 10100011 original & ~mask
 182:i2c.c         **** 	// 10101011 masked | value
 183:i2c.c         **** 
 184:i2c.c         **** 	char c;
 185:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 186:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 187:i2c.c         **** 	data <<= (bit - length + 1); // shift data into correct position
 188:i2c.c         **** 	data &= mask; // zero all non-important bits in data
 189:i2c.c         **** 	c &= ~(mask); // zero all important bits in existing byte
 190:i2c.c         **** 	c |= data; // combine data with existing byte
 191:i2c.c         **** 
 192:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 193:i2c.c         **** }
 194:i2c.c         **** 
 195:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 196:i2c.c         **** 	log_string_i2c("write_byte\n");
 197:i2c.c         **** 
 198:i2c.c         **** 	buff_size = 1;
 199:i2c.c         **** 	buff_pos = 0;
 200:i2c.c         **** 	ra_buff = reg_addr;
 201:i2c.c         **** 	c_buff = &data;
 202:i2c.c         **** 
 203:i2c.c         **** 	busy = 1;
 204:i2c.c         **** 
 205:i2c.c         **** 	//Setting the interrupt handler location for write byte
 206:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_write_byte_isr;
 207:i2c.c         **** 	//current_isr = &i2c_write_byte_isr;
 208:i2c.c         **** 	// Send Start bit
 209:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 210:i2c.c         **** 
 211:i2c.c         **** 	while (busy); // busy wait for read process
 212:i2c.c         **** 
 213:i2c.c         **** 	log_string_i2c("write_byte..returning\n");
 214:i2c.c         **** 	return 1;
 215:i2c.c         **** }
 216:i2c.c         **** 
 217:i2c.c         **** /**
 218:i2c.c         ****  * i2c interrupt handler
 219:i2c.c         ****  */
 220:i2c.c         **** void i2c_write_byte_isr(void) {
  61              		.loc 2 220 0
  62              		.cfi_startproc
  63              		@ Interrupt Service Routine.
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67 0020 0F002DE9 		stmfd	sp!, {r0, r1, r2, r3}
  68              		.save {r0, r1, r2, r3}
  69              	.LCFI0:
  70              		.cfi_def_cfa_offset 16
  71              		.pad #8
  72 0024 08D04DE2 		sub	sp, sp, #8
  73              	.LCFI1:
  74              		.cfi_def_cfa_offset 24
 221:i2c.c         **** 	log_string_i2c(">> i2c_write_byte_isr\n");
 222:i2c.c         **** 	volatile int temp = 0;
  75              		.loc 2 222 0
  76 0028 0030A0E3 		mov	r3, #0
  77              		.cfi_offset 3, -4
  78              		.cfi_offset 2, -8
  79              		.cfi_offset 1, -12
  80              		.cfi_offset 0, -16
  81 002c 04308DE5 		str	r3, [sp, #4]
  82              	.LVL1:
 223:i2c.c         **** 	temp = I2C1STAT;
  83              		.loc 2 223 0
  84 0030 9C319FE5 		ldr	r3, .L14
  85 0034 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
  86 0038 FF3003E2 		and	r3, r3, #255
  87 003c 04308DE5 		str	r3, [sp, #4]
 224:i2c.c         **** 
 225:i2c.c         **** 	switch (temp) {
  88              		.loc 2 225 0
  89 0040 04309DE5 		ldr	r3, [sp, #4]
  90 0044 083043E2 		sub	r3, r3, #8
  91 0048 280053E3 		cmp	r3, #40
  92 004c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
  93 0050 590000EA 		b	.L7
  94              	.L12:
  95 0054 F8000000 		.word	.L8
  96 0058 BC010000 		.word	.L7
  97 005c BC010000 		.word	.L7
  98 0060 BC010000 		.word	.L7
  99 0064 BC010000 		.word	.L7
 100 0068 BC010000 		.word	.L7
 101 006c BC010000 		.word	.L7
 102 0070 BC010000 		.word	.L7
 103 0074 BC010000 		.word	.L7
 104 0078 BC010000 		.word	.L7
 105 007c BC010000 		.word	.L7
 106 0080 BC010000 		.word	.L7
 107 0084 BC010000 		.word	.L7
 108 0088 BC010000 		.word	.L7
 109 008c BC010000 		.word	.L7
 110 0090 BC010000 		.word	.L7
 111 0094 10010000 		.word	.L9
 112 0098 BC010000 		.word	.L7
 113 009c BC010000 		.word	.L7
 114 00a0 BC010000 		.word	.L7
 115 00a4 BC010000 		.word	.L7
 116 00a8 BC010000 		.word	.L7
 117 00ac BC010000 		.word	.L7
 118 00b0 BC010000 		.word	.L7
 119 00b4 BC010000 		.word	.L7
 120 00b8 BC010000 		.word	.L7
 121 00bc BC010000 		.word	.L7
 122 00c0 BC010000 		.word	.L7
 123 00c4 BC010000 		.word	.L7
 124 00c8 BC010000 		.word	.L7
 125 00cc BC010000 		.word	.L7
 126 00d0 BC010000 		.word	.L7
 127 00d4 2C010000 		.word	.L10
 128 00d8 BC010000 		.word	.L7
 129 00dc BC010000 		.word	.L7
 130 00e0 BC010000 		.word	.L7
 131 00e4 BC010000 		.word	.L7
 132 00e8 BC010000 		.word	.L7
 133 00ec BC010000 		.word	.L7
 134 00f0 BC010000 		.word	.L7
 135 00f4 94010000 		.word	.L11
 136              	.L8:
 226:i2c.c         **** 	case TW_START: // A START condition has been transmitted.
 227:i2c.c         **** 		log_string_i2c("TW_START\n");
 228:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
 137              		.loc 2 228 0
 138 00f8 D4309FE5 		ldr	r3, .L14
 139 00fc 2F20E0E3 		mvn	r2, #47
 140 0100 0820C3E5 		strb	r2, [r3, #8]
 229:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 141              		.loc 2 229 0
 142 0104 2820A0E3 		mov	r2, #40
 143 0108 1820C3E5 		strb	r2, [r3, #24]
 230:i2c.c         **** 		break;
 144              		.loc 2 230 0
 145 010c 2A0000EA 		b	.L7
 146              	.L9:
 231:i2c.c         **** 	case TW_REP_START: // A repeated START	condition has been transmitted.
 232:i2c.c         **** 		log_string_i2c("TW_REP_START\n");
 233:i2c.c         **** 		break;
 234:i2c.c         **** 	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
 235:i2c.c         **** 		log_string_i2c("TW_MT_SLA_ACK\n");
 236:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 147              		.loc 2 236 0
 148 0110 C0309FE5 		ldr	r3, .L14+4
 149 0114 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 150 0118 B4309FE5 		ldr	r3, .L14
 151 011c 0820C3E5 		strb	r2, [r3, #8]
 237:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 152              		.loc 2 237 0
 153 0120 0820A0E3 		mov	r2, #8
 154 0124 1820C3E5 		strb	r2, [r3, #24]
 238:i2c.c         **** 		break;
 155              		.loc 2 238 0
 156 0128 230000EA 		b	.L7
 157              	.L10:
 239:i2c.c         **** 	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
 240:i2c.c         **** 		log_string_i2c("TW_MT_SLA_NACK\n");
 241:i2c.c         **** 		break;
 242:i2c.c         **** 	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
 243:i2c.c         **** 		log_string_i2c("TW_MT_DATA_ACK\n");
 244:i2c.c         **** 		if (buff_pos < buff_size) {
 158              		.loc 2 244 0
 159 012c A4209FE5 		ldr	r2, .L14+4
 160 0130 043092E5 		ldr	r3, [r2, #4]
 161 0134 082092E5 		ldr	r2, [r2, #8]
 162 0138 020053E1 		cmp	r3, r2
 163 013c 090000AA 		bge	.L13
 245:i2c.c         **** 			I2C1DAT = c_buff[buff_pos++]; // Send data
 164              		.loc 2 245 0
 165 0140 90109FE5 		ldr	r1, .L14+4
 166 0144 0C2091E5 		ldr	r2, [r1, #12]
 167 0148 0300D2E7 		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 168 014c 80209FE5 		ldr	r2, .L14
 169 0150 0800C2E5 		strb	r0, [r2, #8]
 170 0154 013083E2 		add	r3, r3, #1
 171 0158 043081E5 		str	r3, [r1, #4]
 246:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 172              		.loc 2 246 0
 173 015c 0830A0E3 		mov	r3, #8
 174 0160 1830C2E5 		strb	r3, [r2, #24]
 175 0164 140000EA 		b	.L7
 176              	.L13:
 247:i2c.c         **** 		} else {
 248:i2c.c         **** 			I2C1CONSET |= 0x01 << 4; // Transmit stop condition
 177              		.loc 2 248 0
 178 0168 64309FE5 		ldr	r3, .L14
 179 016c 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 180 0170 FF2002E2 		and	r2, r2, #255
 181 0174 102082E3 		orr	r2, r2, #16
 182 0178 0020C3E5 		strb	r2, [r3, #0]
 249:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 183              		.loc 2 249 0
 184 017c 0820A0E3 		mov	r2, #8
 185 0180 1820C3E5 		strb	r2, [r3, #24]
 250:i2c.c         **** 			busy = 0; // done
 186              		.loc 2 250 0
 187 0184 0020A0E3 		mov	r2, #0
 188 0188 48309FE5 		ldr	r3, .L14+4
 189 018c 102083E5 		str	r2, [r3, #16]
 190 0190 090000EA 		b	.L7
 191              	.L11:
 251:i2c.c         **** 		}
 252:i2c.c         **** 		break;
 253:i2c.c         **** 	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
 254:i2c.c         **** 		log_string_i2c("TW_MT_DATA_NACK\n");
 255:i2c.c         **** 		I2C1CONSET |= 0x01 << 4; // Transmit stop condition
 192              		.loc 2 255 0
 193 0194 38309FE5 		ldr	r3, .L14
 194 0198 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 195 019c FF2002E2 		and	r2, r2, #255
 196 01a0 102082E3 		orr	r2, r2, #16
 197 01a4 0020C3E5 		strb	r2, [r3, #0]
 256:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 198              		.loc 2 256 0
 199 01a8 0820A0E3 		mov	r2, #8
 200 01ac 1820C3E5 		strb	r2, [r3, #24]
 257:i2c.c         **** 		busy = 0; // done
 201              		.loc 2 257 0
 202 01b0 0020A0E3 		mov	r2, #0
 203 01b4 1C309FE5 		ldr	r3, .L14+4
 204 01b8 102083E5 		str	r2, [r3, #16]
 205              	.L7:
 258:i2c.c         **** 		break;
 259:i2c.c         **** 	case TW_MT_ARB_LOST: // Arbitration lost in SLA+R/W or Data bytes.
 260:i2c.c         **** 		log_string_i2c("TW_MT_ARB_LOST\n");
 261:i2c.c         **** 		break;
 262:i2c.c         **** 
 263:i2c.c         **** 	default:
 264:i2c.c         **** 		log_string_i2c("default\n");
 265:i2c.c         **** 		break;
 266:i2c.c         **** 	}
 267:i2c.c         **** 
 268:i2c.c         **** 	VICVectAddr = 0;
 206              		.loc 2 268 0
 207 01bc 0020A0E3 		mov	r2, #0
 208 01c0 0030E0E3 		mvn	r3, #0
 209 01c4 CF2F03E5 		str	r2, [r3, #-4047]
 269:i2c.c         **** }
 210              		.loc 2 269 0
 211 01c8 08D08DE2 		add	sp, sp, #8
 212 01cc 0F00BDE8 		ldmfd	sp!, {r0, r1, r2, r3}
 213 01d0 04F05EE2 		subs	pc, lr, #4
 214              	.L15:
 215              		.align	2
 216              	.L14:
 217 01d4 00C005E0 		.word	-536494080
 218 01d8 00000000 		.word	.LANCHOR0
 219              		.cfi_endproc
 220              	.LFE21:
 221              		.fnend
 223              		.align	2
 224              		.global	protocol_in
 226              	protocol_in:
 227              		.fnstart
 228              	.LFB52:
 229              		.file 3 "bellator_low_level.c"
   1:bellator_low_level.c **** /**
   2:bellator_low_level.c ****  *
   3:bellator_low_level.c ****  *
   4:bellator_low_level.c ****  *
   5:bellator_low_level.c ****  */
   6:bellator_low_level.c **** /* global defines */
   7:bellator_low_level.c **** #define CRYSTAL12MHz
   8:bellator_low_level.c **** //#define CRYSTAL14745600Hz
   9:bellator_low_level.c **** #define CMD_BUFF_SIZE 32 // has to be a power of two
  10:bellator_low_level.c **** #define DATA_BUFF_SIZE 256 // has to be a power of two
  11:bellator_low_level.c **** 
  12:bellator_low_level.c **** #define SAMPLE_RATE_1kHZ 0;
  13:bellator_low_level.c **** #define SAMPLE_RATE_500HZ 1;
  14:bellator_low_level.c **** #define SAMPLE_RATE_250HZ 2;
  15:bellator_low_level.c **** #define SAMPLE_RATE_125HZ 4;
  16:bellator_low_level.c **** #define SAMPLE_RATE_012HZ 4096;
  17:bellator_low_level.c **** 
  18:bellator_low_level.c **** #define SAMPLE_RATE SAMPLE_RATE_012HZ
  19:bellator_low_level.c **** 
  20:bellator_low_level.c **** #define ERROR
  21:bellator_low_level.c **** #define WARNING
  22:bellator_low_level.c **** //#define DEBUG
  23:bellator_low_level.c **** //#define DEBUG_I2C
  24:bellator_low_level.c **** //#define DEBUG_MPU
  25:bellator_low_level.c **** 
  26:bellator_low_level.c **** #define IENABLE \
  27:bellator_low_level.c **** 		asm volatile ( "MRS		LR, SPSR" 		); /* copy SPSR_irq to LR */ \
  28:bellator_low_level.c **** 		asm volatile ( "STMFD	SP!, {LR}"		); /* save SPSR_irq */ \
  29:bellator_low_level.c **** 		asm volatile ( "MSR		CPSR_c, #0x1F"	); /* enable IRQ */ \
  30:bellator_low_level.c **** 		asm volatile ( "STMFD	SP!, {LR}"		); /* save LR */ \
  31:bellator_low_level.c **** 
  32:bellator_low_level.c **** #define IDISABLE \
  33:bellator_low_level.c **** 		asm volatile ( "LDMFD	SP!, {LR}" 		); /* restore LR */ \
  34:bellator_low_level.c **** 		asm volatile ( "MSR		CPSR_c, #0x92"	); /* disable IRQ */ \
  35:bellator_low_level.c **** 		asm volatile ( "LDMFD	SP!, {LR}"		); /* Restore SPSR_irq to LR */ \
  36:bellator_low_level.c **** 		asm volatile ( "MSR		SPSR_cxsf, LR"	); /* copy LR to SPSR_irq */ \
  37:bellator_low_level.c **** 
  38:bellator_low_level.c **** 
  39:bellator_low_level.c **** /* includes */
  40:bellator_low_level.c **** #include "lpc2103.h"
  41:bellator_low_level.c **** #include "logger.h"
  42:bellator_low_level.c **** #include "logger.c"
  43:bellator_low_level.c **** #include "irq.h"
  44:bellator_low_level.c **** #include "irq.c"
  45:bellator_low_level.c **** #include "i2c.h"
  46:bellator_low_level.c **** #include "i2c.c"
  47:bellator_low_level.c **** #include "protocol.h"
  48:bellator_low_level.c **** #include "mpu6050.h"
  49:bellator_low_level.c **** #include "mpu6050.c"
  50:bellator_low_level.c **** 
  51:bellator_low_level.c **** /* interruptions */
  52:bellator_low_level.c **** void __attribute__ ((interrupt("FIQ"))) pulse_in(void);
  53:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) protocol_in(void);
  54:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) sample(void);
  55:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) error(void);
  56:bellator_low_level.c **** 
  57:bellator_low_level.c **** 
  58:bellator_low_level.c **** /* init functions */
  59:bellator_low_level.c **** inline void PLL_Init(void);
  60:bellator_low_level.c **** inline void MAM_Init(void);
  61:bellator_low_level.c **** inline void APB_Init(void);
  62:bellator_low_level.c **** 
  63:bellator_low_level.c **** inline void pulses_in_init(void);
  64:bellator_low_level.c **** inline void imu_init(void);
  65:bellator_low_level.c **** inline void adc_init(void);
  66:bellator_low_level.c **** inline void pwm_out_init(void);
  67:bellator_low_level.c **** static inline void protocol_init(void);
  68:bellator_low_level.c **** inline void sampler_init(void);
  69:bellator_low_level.c **** 
  70:bellator_low_level.c **** /* getters and setters */
  71:bellator_low_level.c **** void get_ir_sensor_data(char * buff);
  72:bellator_low_level.c **** void get_encoders_count(short * left_encoder, short * right_encoder);
  73:bellator_low_level.c **** inline void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel);
  74:bellator_low_level.c **** 
  75:bellator_low_level.c **** /* auxiliary functions */
  76:bellator_low_level.c **** static inline void protocol_out_cmd(void);
  77:bellator_low_level.c **** static inline void protocol_out_char(char c);
  78:bellator_low_level.c **** 
  79:bellator_low_level.c **** /* data structs defenitions */
  80:bellator_low_level.c **** struct cmd_buff {
  81:bellator_low_level.c ****   unsigned int i;
  82:bellator_low_level.c ****   char buff [CMD_BUFF_SIZE];      // Circular Buffer
  83:bellator_low_level.c **** };
  84:bellator_low_level.c **** 
  85:bellator_low_level.c **** struct sensors_data {
  86:bellator_low_level.c **** 	short encoder_left, encoder_right;
  87:bellator_low_level.c **** 	char ir_r, ir_mr, ir_m, ir_ml, ir_l;
  88:bellator_low_level.c **** 	char ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l;
  89:bellator_low_level.c **** 	unsigned short timestamp;
  90:bellator_low_level.c **** };
  91:bellator_low_level.c **** 
  92:bellator_low_level.c **** /* global variables */
  93:bellator_low_level.c **** static struct cmd_buff cmd_out = { 0, };
  94:bellator_low_level.c **** static struct cmd_buff cmd_in = { 0, };
  95:bellator_low_level.c **** static volatile int encoder_count[2] = { 0, 0};
  96:bellator_low_level.c **** static int sent_encoder_count[2] = { 0, 0};
  97:bellator_low_level.c **** static int forward_r = 0, forward_l = 0;
  98:bellator_low_level.c **** static unsigned volatile char send_data = 0;
  99:bellator_low_level.c **** static struct sensors_data sensors_data_buff[DATA_BUFF_SIZE]; // Circular Buffer
 100:bellator_low_level.c **** static unsigned volatile short data_in_pos = 0; // last valid data in
 101:bellator_low_level.c **** static unsigned volatile short data_out_pos = 0; // last data sent
 102:bellator_low_level.c **** static unsigned short timestamp = 0;
 103:bellator_low_level.c **** 
 104:bellator_low_level.c **** /**
 105:bellator_low_level.c ****  * Entry point
 106:bellator_low_level.c ****  */
 107:bellator_low_level.c **** int main(void){
 108:bellator_low_level.c **** 
 109:bellator_low_level.c **** 	PLL_Init(); // Turn on PLL clock
 110:bellator_low_level.c **** 	MAM_Init(); // Turn on MAM pre-fetcher
 111:bellator_low_level.c **** 	APB_Init(); // Turn on the peripheral devices clock divider
 112:bellator_low_level.c **** 
 113:bellator_low_level.c **** 	logger_init(); // uart0
 114:bellator_low_level.c **** 	log_string_debug("iniciando\n");
 115:bellator_low_level.c **** 
 116:bellator_low_level.c **** 	enableIRQ(); // Enable interruptions
 117:bellator_low_level.c **** 	enableFIQ();
 118:bellator_low_level.c **** 
 119:bellator_low_level.c **** 	pulses_in_init(); // start counting pulses from the encoder	| Timer 2, FIQ, eint0, FIQ
 120:bellator_low_level.c **** 	imu_init(); // start the IMU								| i2c1 FIQ
 121:bellator_low_level.c **** 	adc_init(); // start reading the IR sensor signals			| Burst mode, no interruption
 122:bellator_low_level.c **** 	pwm_out_init(); // start pwm for the H bridges				| Timer 0 and Timer 1 operating in PWM mode, no 
 123:bellator_low_level.c **** 	protocol_init(); // start the communication protocol		| uart1, Priority 2
 124:bellator_low_level.c **** 	sampler_init(); // start taking samples at 1kHz				| Timer 3, 1kH, Priority 1
 125:bellator_low_level.c **** 
 126:bellator_low_level.c **** 	VICDefVectAddr = (unsigned int) &error;
 127:bellator_low_level.c **** 
 128:bellator_low_level.c **** 	//set_wheel_pwm(RIGHT_WHEEL,0x7F);
 129:bellator_low_level.c **** 	//set_wheel_pwm(LEFT_WHEEL,0x7F);
 130:bellator_low_level.c **** 
 131:bellator_low_level.c **** 	while (1) {
 132:bellator_low_level.c **** 		if (send_data) {
 133:bellator_low_level.c **** 			// while data available
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 135:bellator_low_level.c **** 				// send next data
 136:bellator_low_level.c **** 				data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 137:bellator_low_level.c **** 
 138:bellator_low_level.c **** 				struct sensors_data* data;
 139:bellator_low_level.c **** 				data = &(sensors_data_buff[data_out_pos]);
 140:bellator_low_level.c **** 
 141:bellator_low_level.c **** 				// encoders
 142:bellator_low_level.c **** 				cmd_out.buff[0] = (data->encoder_left >> 0x8) & 0xFF;
 143:bellator_low_level.c **** 				cmd_out.buff[1] = data->encoder_left & 0xFF;
 144:bellator_low_level.c **** 				cmd_out.buff[2] = (data->encoder_right >> 0x8) & 0xFF;
 145:bellator_low_level.c **** 				cmd_out.buff[3] = data->encoder_right & 0xFF;
 146:bellator_low_level.c **** 
 147:bellator_low_level.c **** 				// Infra Red
 148:bellator_low_level.c **** 				cmd_out.buff[4] = data->ir_l;
 149:bellator_low_level.c **** 				cmd_out.buff[5] = data->ir_ml;
 150:bellator_low_level.c **** 				cmd_out.buff[6] = data->ir_m;
 151:bellator_low_level.c **** 				cmd_out.buff[7] = data->ir_mr;
 152:bellator_low_level.c **** 				cmd_out.buff[8] = data->ir_r;
 153:bellator_low_level.c **** 
 154:bellator_low_level.c **** 				// IMU data
 155:bellator_low_level.c **** 				cmd_out.buff[9] = data->ax_h;
 156:bellator_low_level.c **** 				cmd_out.buff[10] = data->ax_l;
 157:bellator_low_level.c **** 				cmd_out.buff[11] = data->ay_h;
 158:bellator_low_level.c **** 				cmd_out.buff[12] = data->ay_l;
 159:bellator_low_level.c **** 				cmd_out.buff[13] = data->az_h;
 160:bellator_low_level.c **** 				cmd_out.buff[14] = data->az_l;
 161:bellator_low_level.c **** 				cmd_out.buff[15] = data->gx_h;
 162:bellator_low_level.c **** 				cmd_out.buff[16] = data->gx_l;
 163:bellator_low_level.c **** 				cmd_out.buff[17] = data->gy_h;
 164:bellator_low_level.c **** 				cmd_out.buff[18] = data->gy_l;
 165:bellator_low_level.c **** 				cmd_out.buff[19] = data->gz_h;
 166:bellator_low_level.c **** 				cmd_out.buff[20] = data->gz_l;
 167:bellator_low_level.c **** 
 168:bellator_low_level.c **** 				// Timestamp
 169:bellator_low_level.c **** 				cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 170:bellator_low_level.c **** 				cmd_out.buff[22] = data->timestamp & 0xFF;
 171:bellator_low_level.c **** 
 172:bellator_low_level.c **** 				// end cmd
 173:bellator_low_level.c **** 				cmd_out.buff[23] = END_CMD;
 174:bellator_low_level.c **** 				cmd_out.buff[24] = '\n';
 175:bellator_low_level.c **** 				cmd_out.i = 25;
 176:bellator_low_level.c **** 
 177:bellator_low_level.c **** 				protocol_out_cmd();
 178:bellator_low_level.c **** 			}
 179:bellator_low_level.c **** 
 180:bellator_low_level.c **** 			send_data = 0;
 181:bellator_low_level.c **** 		}
 182:bellator_low_level.c **** 	}
 183:bellator_low_level.c **** 
 184:bellator_low_level.c **** 	return 0;
 185:bellator_low_level.c **** }
 186:bellator_low_level.c **** 
 187:bellator_low_level.c **** /**
 188:bellator_low_level.c ****  * Sets the processor clock
 189:bellator_low_level.c ****  *
 190:bellator_low_level.c ****  * Fosc = External oscilator =	12MHz | 14.7456MHz
 191:bellator_low_level.c ****  * CCLK = PLL Clock output =	60MHz | 58.9824MHz  (desired system clock)
 192:bellator_low_level.c ****  * MSEL = Clock multiplier =	4	  | 3			(MSEL = CCLK/Fosc -1)
 193:bellator_low_level.c ****  * PSEL = Clock divider = 		1	  | 1			(P | 156MHz < Fcco < 320MHz, Fcco = CCLK * 2 * P)
 194:bellator_low_level.c ****  * 													(P=1 -> PSEL=00, P=2 -> PSEL=01, P=4 -> PSEL=10, P=8 -> PSEL=11)
 195:bellator_low_level.c ****  */
 196:bellator_low_level.c **** inline void PLL_Init(void){
 197:bellator_low_level.c **** 
 198:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 199:bellator_low_level.c **** 	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 200:bellator_low_level.c **** #endif
 201:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 202:bellator_low_level.c **** 	PLLCFG=0x23;                // 14.7456MHz crystal -> 58.9824MHz
 203:bellator_low_level.c **** #endif
 204:bellator_low_level.c **** 
 205:bellator_low_level.c **** 	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 206:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 207:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 208:bellator_low_level.c **** 	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 209:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 210:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 211:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 212:bellator_low_level.c **** }
 213:bellator_low_level.c **** 
 214:bellator_low_level.c **** /**
 215:bellator_low_level.c ****  * Starts the Memory Acceleration Module
 216:bellator_low_level.c ****  * System clock
 217:bellator_low_level.c ****  * < 20MHz         -> MAMTIM = 1 CCLK
 218:bellator_low_level.c ****  * 20MHz to 40MHz  -> MAMTIM = 2 CCLK
 219:bellator_low_level.c ****  * 40MHz to 60MHz  -> MAMTIM = 3 CCLK
 220:bellator_low_level.c ****  * > 60MHz         -> MAMTIM = 4 CCLK
 221:bellator_low_level.c ****  */
 222:bellator_low_level.c **** inline void MAM_Init(void){
 223:bellator_low_level.c **** 
 224:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 225:bellator_low_level.c **** 	MAMTIM = 4; // 4 clock fetches
 226:bellator_low_level.c **** #endif
 227:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 228:bellator_low_level.c **** 	MAMTIM = 3; // 3 clock fetches
 229:bellator_low_level.c **** #endif
 230:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 231:bellator_low_level.c **** }
 232:bellator_low_level.c **** 
 233:bellator_low_level.c **** /**
 234:bellator_low_level.c ****  * Configure the peripheral devices clock divider
 235:bellator_low_level.c ****  * for PCLK = CCLK/4
 236:bellator_low_level.c ****  */
 237:bellator_low_level.c **** inline void APB_Init(void){
 238:bellator_low_level.c **** 	// peripheral clock = PCLK = CCLK/4
 239:bellator_low_level.c **** 	//APBDIV |= 0x02;
 240:bellator_low_level.c **** 	APBDIV &= ~0x03;
 241:bellator_low_level.c **** }
 242:bellator_low_level.c **** 
 243:bellator_low_level.c **** /**
 244:bellator_low_level.c ****  * Timer 2, capture pins generating FIQs for event counter
 245:bellator_low_level.c ****  * The timer has no function, except for the interrupt generation.
 246:bellator_low_level.c ****  * and EINT0 also generating FIQs for event counter
 247:bellator_low_level.c ****  * CAP20 - Left encoder
 248:bellator_low_level.c ****  * CAP21 - Left encoder
 249:bellator_low_level.c ****  * CAP22 - Right encoder
 250:bellator_low_level.c ****  * EINT0 - Right encoder
 251:bellator_low_level.c ****  */
 252:bellator_low_level.c **** inline void pulses_in_init(void){
 253:bellator_low_level.c **** 
 254:bellator_low_level.c **** 	log_string_debug(">> pulses_in_init\n");
 255:bellator_low_level.c **** 
 256:bellator_low_level.c **** 	// Set the pin function
 257:bellator_low_level.c **** 	PINSEL1 |= 0x1 << 0;  // EINT0
 258:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 259:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 24; // CAP2.1
 260:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 26; // CAP2.2
 261:bellator_low_level.c **** 
 262:bellator_low_level.c **** 	// EINT setup
 263:bellator_low_level.c **** 	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
 264:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
 265:bellator_low_level.c **** 	EXTINT |= 0x1 << 0; // reset EINT0
 266:bellator_low_level.c **** 
 267:bellator_low_level.c **** 	// Timer Setup
 268:bellator_low_level.c **** 	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
 269:bellator_low_level.c **** 	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
 270:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 271:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 272:bellator_low_level.c **** 
 273:bellator_low_level.c **** 	// Enable the interrupts
 274:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 14;// EINT2 as FIQ
 275:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
 276:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 26;// Timer 2 as FIQ
 277:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
 278:bellator_low_level.c **** 
 279:bellator_low_level.c **** 	log_string_debug("<< pulses_in_init\n");
 280:bellator_low_level.c **** }
 281:bellator_low_level.c **** 
 282:bellator_low_level.c **** /**
 283:bellator_low_level.c ****  * Start i2c communication
 284:bellator_low_level.c ****  * Configure MPU
 285:bellator_low_level.c ****  * Setup eint2 with priority 1 for data ready interrupt
 286:bellator_low_level.c ****  */
 287:bellator_low_level.c **** inline void imu_init(void){
 288:bellator_low_level.c **** 
 289:bellator_low_level.c **** 	log_string_debug(">> imu_init\n");
 290:bellator_low_level.c **** 
 291:bellator_low_level.c **** 	// start the communication with the IMU
 292:bellator_low_level.c **** 	i2c_init();
 293:bellator_low_level.c **** 
 294:bellator_low_level.c **** 	// configure mpu and start taking samples
 295:bellator_low_level.c **** 	mpu_init();
 296:bellator_low_level.c **** 
 297:bellator_low_level.c **** 	// DATA READY INTERRUPT WAS NOT USED
 298:bellator_low_level.c **** 	// Configure data ready interrupt
 299:bellator_low_level.c **** 	// Set the pin function
 300:bellator_low_level.c **** 	//PINSEL0 |= 0x1 << 30;  // EINT2
 301:bellator_low_level.c **** 
 302:bellator_low_level.c **** 	// EINT setup
 303:bellator_low_level.c **** 	//EXTMODE |= 0x1 << 2; // EINT2 is edge sensitive
 304:bellator_low_level.c **** 	//EXTPOLAR |= 0x1 << 2; // EINT2 is rising edge sensitive
 305:bellator_low_level.c **** 	//EXTINT |= 0x1 << 2; // reset EINT2
 306:bellator_low_level.c **** 
 307:bellator_low_level.c **** 	//VICVectAddr1 = (unsigned int) &imu_data_ready; //Setting the interrupt handler location
 308:bellator_low_level.c **** 	//VICVectCntl1 = 0x30; //Vectored Interrupt slot enabled with source #16 (EINT2)
 309:bellator_low_level.c **** 	//VICIntEnable |= 0x1 << 16; //source #16 enabled as FIQ or IRQ
 310:bellator_low_level.c **** 
 311:bellator_low_level.c **** 	log_string_debug("<< imu_init\n");
 312:bellator_low_level.c **** }
 313:bellator_low_level.c **** 
 314:bellator_low_level.c **** /**
 315:bellator_low_level.c ****  * ADC0 Configured in BURST mode
 316:bellator_low_level.c ****  */
 317:bellator_low_level.c **** inline void adc_init(void){
 318:bellator_low_level.c **** 
 319:bellator_low_level.c **** 	log_string_debug(">> adc_init\n");
 320:bellator_low_level.c **** 
 321:bellator_low_level.c **** 	// Set the pin function
 322:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 12; // AD0.0
 323:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 14; // AD0.1
 324:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 16; // AD0.2
 325:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 20; // AD0.3
 326:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 22; // AD0.4
 327:bellator_low_level.c **** 
 328:bellator_low_level.c **** 	// ADC setup
 329:bellator_low_level.c **** 	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
 330:bellator_low_level.c **** 	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
 331:bellator_low_level.c **** 	ADCR |= 0x1F; // Read AD0.0 - AD0.4
 332:bellator_low_level.c **** 	ADCR |= 0x01 << 21; // The ADC is operational
 333:bellator_low_level.c **** 
 334:bellator_low_level.c **** 	log_string_debug("<< adc_init\n");
 335:bellator_low_level.c **** }
 336:bellator_low_level.c **** 
 337:bellator_low_level.c **** /**
 338:bellator_low_level.c ****  * Timer 0,1, 200Hz, at least 76 levels to comply with the old version
 339:bellator_low_level.c ****  * Timer 0 -> left wheel
 340:bellator_low_level.c ****  * Timer 1 -> right wheel
 341:bellator_low_level.c ****  * PCLK = 15MHz or 14.7456MHz
 342:bellator_low_level.c ****  */
 343:bellator_low_level.c **** inline void pwm_out_init(void){
 344:bellator_low_level.c **** 
 345:bellator_low_level.c **** 	log_string_debug(">> pwm_out_init\n");
 346:bellator_low_level.c **** 
 347:bellator_low_level.c **** 	// Set the pin function
 348:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 6;  // MAT0.0
 349:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 10; // MAT0.1
 350:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 24; // MAT1.0
 351:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 26; // MAT1.1
 352:bellator_low_level.c **** 
 353:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 354:bellator_low_level.c **** 	T0PR = 293; // 255 levels for T2TC in 5ms
 355:bellator_low_level.c **** 	T1PR = 293; // TC increments every PR + 1 PCLKs
 356:bellator_low_level.c **** #endif
 357:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 358:bellator_low_level.c **** 	T0PR = 288; // 255 levels for T2TC in 5ms
 359:bellator_low_level.c **** 	T1PR = 288;
 360:bellator_low_level.c **** #endif
 361:bellator_low_level.c **** 
 362:bellator_low_level.c **** 	T0PC = 0; // Prescale = 0
 363:bellator_low_level.c **** 	T1PC = 0;
 364:bellator_low_level.c **** 	T0TC = 0; // Counter = 0
 365:bellator_low_level.c **** 	T1TC = 0;
 366:bellator_low_level.c **** 
 367:bellator_low_level.c **** 	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
 368:bellator_low_level.c **** 	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
 369:bellator_low_level.c **** 	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
 370:bellator_low_level.c **** 	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
 371:bellator_low_level.c **** 
 372:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
 373:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
 374:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
 375:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
 376:bellator_low_level.c **** 
 377:bellator_low_level.c **** 	T0MR0 = 256; // initially LOW
 378:bellator_low_level.c **** 	T0MR1 = 256; // initially LOW
 379:bellator_low_level.c **** 	T1MR0 = 256; // initially LOW
 380:bellator_low_level.c **** 	T1MR1 = 256; // initially LOW
 381:bellator_low_level.c **** 
 382:bellator_low_level.c **** 	T0TCR = 1; // enable T0
 383:bellator_low_level.c **** 	T1TCR = 1; // enable T1
 384:bellator_low_level.c **** 
 385:bellator_low_level.c **** 	log_string_debug("<< pwm_out_init\n");
 386:bellator_low_level.c **** }
 387:bellator_low_level.c **** 
 388:bellator_low_level.c **** /**
 389:bellator_low_level.c ****  * Set up the protocol using UART1 to communicate with TS-7260
 390:bellator_low_level.c ****  *
 391:bellator_low_level.c ****  * 8N1 (8 data, Non parity, 1 stop)
 392:bellator_low_level.c ****  * 115200 bps
 393:bellator_low_level.c ****  *
 394:bellator_low_level.c ****  * UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL) * ( 1 + DivAddVal/MulVal))
 395:bellator_low_level.c ****  * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
 396:bellator_low_level.c ****  * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
 397:bellator_low_level.c ****  * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
 398:bellator_low_level.c ****  *
 399:bellator_low_level.c ****  * Set UART1 interrupt to the second slot in the vectored interrupts.
 400:bellator_low_level.c ****  */
 401:bellator_low_level.c **** static inline void protocol_init(void){
 402:bellator_low_level.c **** 
 403:bellator_low_level.c **** 	log_string_debug(">> protocol_init\n");
 404:bellator_low_level.c **** 
 405:bellator_low_level.c **** 	volatile char dummy;
 406:bellator_low_level.c **** 
 407:bellator_low_level.c **** 	PINSEL0 |= 0x05 << 16; // Set the pins function
 408:bellator_low_level.c **** 	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 409:bellator_low_level.c **** 	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 410:bellator_low_level.c **** 
 411:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 412:bellator_low_level.c **** 	U1DLL	 = 0x06; // DivisorLatchLow bit
 413:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 414:bellator_low_level.c **** 	U1FDR	|= 0x05; // DivAddVal
 415:bellator_low_level.c **** 	U1FDR	|= 0x0E << 4; // MulVal = 14
 416:bellator_low_level.c **** #endif
 417:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 418:bellator_low_level.c **** 	U1DLL	 = 0x08; // DivisorLatchLow bit
 419:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 420:bellator_low_level.c **** #endif
 421:bellator_low_level.c **** 
 422:bellator_low_level.c **** 	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 423:bellator_low_level.c **** 
 424:bellator_low_level.c **** 	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 425:bellator_low_level.c **** 	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 426:bellator_low_level.c **** 	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 427:bellator_low_level.c **** 
 428:bellator_low_level.c **** 	cmd_out.i = 0;
 429:bellator_low_level.c **** 	cmd_in.i = 0;
 430:bellator_low_level.c **** 
 431:bellator_low_level.c **** 	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 432:bellator_low_level.c **** 	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
 433:bellator_low_level.c **** 
 434:bellator_low_level.c **** 	log_string_debug("<< protocol_init\n");
 435:bellator_low_level.c **** }
 436:bellator_low_level.c **** 
 437:bellator_low_level.c **** /**
 438:bellator_low_level.c ****  * PCLK = 15MHz or 14.7456MHz
 439:bellator_low_level.c ****  */
 440:bellator_low_level.c **** inline void sampler_init(void){
 441:bellator_low_level.c **** 	log_string_debug(">> sampler_init\n");
 442:bellator_low_level.c **** 
 443:bellator_low_level.c **** 	// set pre scale for sample rate
 444:bellator_low_level.c **** 	T3PR = SAMPLE_RATE; // Increment the timer every PCLK
 445:bellator_low_level.c **** 
 446:bellator_low_level.c **** 	T3PC = 0;
 447:bellator_low_level.c **** 	T3TC = 0; // Counter = 0
 448:bellator_low_level.c **** 
 449:bellator_low_level.c **** 	T3MCR |= (0x1 << 0); // Interrupt on MAT3.0
 450:bellator_low_level.c **** 	T3MCR |= (0x1 << 1); // Reset the counter on MAT3.0
 451:bellator_low_level.c **** 
 452:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 453:bellator_low_level.c **** 	T3MR0 = 15000; // MAT3.0 every 15000/(SAMPLE_RATE + 1) counts (1ms/(SAMPLE_RATE + 1))
 454:bellator_low_level.c **** #endif
 455:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 456:bellator_low_level.c **** 	T3MR0 = 14746; // MAT3.0 every 14746/(SAMPLE_RATE + 1) counts (1.000027127ms/(SAMPLE_RATE + 1))
 457:bellator_low_level.c **** #endif
 458:bellator_low_level.c **** 
 459:bellator_low_level.c **** 	VICVectAddr1 = (unsigned int) &sample; //Setting the interrupt handler location
 460:bellator_low_level.c **** 	VICVectCntl1 = 0x3B; //Vectored Interrupt slot enabled and with source #27 (TIMER3)
 461:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 27; //source #27 enabled as FIQ or IRQ
 462:bellator_low_level.c **** 
 463:bellator_low_level.c **** 	T3TCR = 1; // enable T3
 464:bellator_low_level.c **** 
 465:bellator_low_level.c **** 	log_string_debug("<< sampler_init\n");
 466:bellator_low_level.c **** }
 467:bellator_low_level.c **** 
 468:bellator_low_level.c **** /**
 469:bellator_low_level.c ****  * Communication Protocol state machine implementation;
 470:bellator_low_level.c ****  * This is triggered on uart1 interruption
 471:bellator_low_level.c ****  * This handles the following commands
 472:bellator_low_level.c ****  *
 473:bellator_low_level.c ****  */
 474:bellator_low_level.c **** void protocol_in(void){
 230              		.loc 3 474 0
 231              		.cfi_startproc
 232              		@ Interrupt Service Routine.
 233              		@ args = 0, pretend = 0, frame = 8
 234              		@ frame_needed = 0, uses_anonymous_args = 0
 235              		@ link register save eliminated.
 236 01dc FF102DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, ip}
 237              		.save {r0, r1, r2, r3, r4, r5, r6, r7, ip}
 238              	.LCFI2:
 239              		.cfi_def_cfa_offset 36
 240              		.pad #12
 241 01e0 0CD04DE2 		sub	sp, sp, #12
 242              	.LCFI3:
 243              		.cfi_def_cfa_offset 48
 475:bellator_low_level.c **** 
 476:bellator_low_level.c **** 	log_string_debug(">> protocol_in\n");
 477:bellator_low_level.c **** 
 478:bellator_low_level.c **** 	volatile char dummy;
 479:bellator_low_level.c **** 	volatile char iir;
 480:bellator_low_level.c **** 
 481:bellator_low_level.c **** 	// Repeat while there is at least one interrupt source.
 482:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 483:bellator_low_level.c **** 		switch (iir & 0x0E) {
 484:bellator_low_level.c **** 		case 0x06: // Receive Line Status
 485:bellator_low_level.c **** 			dummy = U1LSR; // Just clear the interrupt source
 486:bellator_low_level.c **** 			break;
 487:bellator_low_level.c **** 
 488:bellator_low_level.c **** 		case 0x04: // Receive Data Available
 489:bellator_low_level.c **** 		case 0x0C: // Character Time-Out
 490:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 244              		.loc 3 490 0
 245 01e4 8C319FE5 		ldr	r3, .L34
 246              		.cfi_offset 12, -4
 247              		.cfi_offset 7, -8
 248              		.cfi_offset 6, -12
 249              		.cfi_offset 5, -16
 250              		.cfi_offset 4, -20
 251              		.cfi_offset 3, -24
 252              		.cfi_offset 2, -28
 253              		.cfi_offset 1, -32
 254              		.cfi_offset 0, -36
 474:bellator_low_level.c **** void protocol_in(void){
 255              		.loc 3 474 0
 256 01e8 141093E5 		ldr	r1, [r3, #20]
 482:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 257              		.loc 3 482 0
 258 01ec 88219FE5 		ldr	r2, .L34+4
 259              		.loc 3 490 0
 260 01f0 0300A0E1 		mov	r0, r3
 491:bellator_low_level.c **** 
 492:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 493:bellator_low_level.c **** 				// ENGINES
 494:bellator_low_level.c **** 				if (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] == ENGINES) {
 495:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]),
 496:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)]));
 497:bellator_low_level.c **** 				}
 498:bellator_low_level.c **** 				// SYNC
 499:bellator_low_level.c **** 				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
 500:bellator_low_level.c **** 					send_data = 1;
 261              		.loc 3 500 0
 262 01f4 0160A0E3 		mov	r6, #1
 263              	.LBB51:
 264              	.LBB52:
 501:bellator_low_level.c **** 				}
 502:bellator_low_level.c **** 			}
 503:bellator_low_level.c **** 
 504:bellator_low_level.c **** 			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
 505:bellator_low_level.c **** 			break;
 506:bellator_low_level.c **** 
 507:bellator_low_level.c **** 		case 0x02: // THRE Interrupt, transmit interrupt
 508:bellator_low_level.c **** 			U1THR = dummy; // Just clear the interrupt source
 509:bellator_low_level.c **** 			break;
 510:bellator_low_level.c **** 
 511:bellator_low_level.c **** 		case 0x00: // Modem Interrupt
 512:bellator_low_level.c **** 			dummy = U1MSR; // Just clear the interrupt source
 513:bellator_low_level.c **** 			break;
 514:bellator_low_level.c **** 
 515:bellator_low_level.c **** 		default:
 516:bellator_low_level.c **** 			break;
 517:bellator_low_level.c **** 		}
 518:bellator_low_level.c **** 	}
 519:bellator_low_level.c **** 
 520:bellator_low_level.c **** 	log_string_debug("<< protocol_in\n");
 521:bellator_low_level.c **** 
 522:bellator_low_level.c **** 	VICVectAddr = 0;
 523:bellator_low_level.c **** }
 524:bellator_low_level.c **** 
 525:bellator_low_level.c **** /**
 526:bellator_low_level.c ****  * Hall the FIQ interrupts shoul be handled as fast as possible.
 527:bellator_low_level.c ****  *
 528:bellator_low_level.c ****  * Count the encoder pulses using CAP2.0-2 and EINT0 as interrupt sources
 529:bellator_low_level.c ****  *
 530:bellator_low_level.c ****  * Handle i2c requests
 531:bellator_low_level.c ****  */
 532:bellator_low_level.c **** void pulse_in(void) {
 533:bellator_low_level.c **** 
 534:bellator_low_level.c **** 	log_string_debug(">> pulse_in\n");
 535:bellator_low_level.c **** 
 536:bellator_low_level.c **** 	const unsigned short ir = T2IR;
 537:bellator_low_level.c **** 
 538:bellator_low_level.c **** 	// pulses in int
 539:bellator_low_level.c **** 	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
 540:bellator_low_level.c **** 		//log_string_debug("FIQ2\n");
 541:bellator_low_level.c **** 		forward_l--;
 542:bellator_low_level.c **** 		T2IR |= 0x1 << 4; // reset CAP2.0
 543:bellator_low_level.c **** 	}
 544:bellator_low_level.c **** 	else if (ir & (0x1 << 5)) { //CAP2.1 right encoder
 545:bellator_low_level.c **** 		//log_string_debug("FIQ3\n");
 546:bellator_low_level.c **** 		forward_r++;
 547:bellator_low_level.c **** 		if (forward_r > 0)
 548:bellator_low_level.c **** 			encoder_count[1]++;
 549:bellator_low_level.c **** 		else
 550:bellator_low_level.c **** 			encoder_count[1]--;
 551:bellator_low_level.c **** 		T2IR |= 0x1 << 5; // reset CAP2.1
 552:bellator_low_level.c **** 	}
 553:bellator_low_level.c **** 	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
 554:bellator_low_level.c **** 		//log_string_debug("FIQ4\n");
 555:bellator_low_level.c **** 		forward_r--;
 556:bellator_low_level.c **** 		T2IR |= 0x1 << 6; // reset CAP2.2
 557:bellator_low_level.c **** 	}
 558:bellator_low_level.c **** 	else if (EXTINT & 0x1 << 0) { // EINT0 left encoder
 559:bellator_low_level.c **** 		//log_string_debug("FIQ1\n");
 560:bellator_low_level.c **** 		forward_l++;
 561:bellator_low_level.c **** 		if (forward_l > 0)
 562:bellator_low_level.c **** 			encoder_count[0]++;
 563:bellator_low_level.c **** 		else
 564:bellator_low_level.c **** 			encoder_count[0]--;
 565:bellator_low_level.c **** 		EXTINT |= 0x1 << 0; // reset EINT0
 566:bellator_low_level.c **** 	}
 567:bellator_low_level.c **** 
 568:bellator_low_level.c **** 	log_string_debug("<< pulse_in\n");
 569:bellator_low_level.c **** 
 570:bellator_low_level.c **** 	VICVectAddr = 0;
 571:bellator_low_level.c **** }
 572:bellator_low_level.c **** 
 573:bellator_low_level.c **** /**
 574:bellator_low_level.c ****  * DATA READY INTERRUPT WAS NOT USED
 575:bellator_low_level.c ****  * Read IMU data when triggered by EINT2
 576:bellator_low_level.c ****  */
 577:bellator_low_level.c **** /*void imu_data_ready(void) {
 578:bellator_low_level.c **** 
 579:bellator_low_level.c **** 	//log_string_debug(">> imu_data_ready\n");
 580:bellator_low_level.c **** 
 581:bellator_low_level.c **** 	imu_data_available = 1;
 582:bellator_low_level.c **** 
 583:bellator_low_level.c **** 	EXTINT |= 0x1 << 2; // reset EINT2
 584:bellator_low_level.c **** 
 585:bellator_low_level.c **** 	//log_string_debug("<< imu_data_ready\n");
 586:bellator_low_level.c **** 
 587:bellator_low_level.c **** 	VICVectAddr = 0;
 588:bellator_low_level.c **** }
 589:bellator_low_level.c **** */
 590:bellator_low_level.c **** 
 591:bellator_low_level.c **** /**
 592:bellator_low_level.c ****  * Sample sensors every 1ms (1kHz)
 593:bellator_low_level.c ****  * data_in_pos -
 594:bellator_low_level.c ****  */
 595:bellator_low_level.c **** void sample(void) {
 596:bellator_low_level.c **** 	const unsigned short ir = T3IR;
 597:bellator_low_level.c **** 	if(ir & 0x1) { // MAT3.0
 598:bellator_low_level.c **** 		log_string_debug(">> sample\n");
 599:bellator_low_level.c **** 
 600:bellator_low_level.c **** 		log_string_debug("IENABLE\n");
 601:bellator_low_level.c **** 		// enable nested interrupts for i2c and FIQ
 602:bellator_low_level.c **** 		T3IR |= 0x1 << 0; // clear MAT3.0 interrupt
 603:bellator_low_level.c **** 		IENABLE
 604:bellator_low_level.c **** 
 605:bellator_low_level.c **** 		// next position in buffer
 606:bellator_low_level.c **** 		data_in_pos = ++data_in_pos % DATA_BUFF_SIZE;
 607:bellator_low_level.c **** 
 608:bellator_low_level.c **** 		// check for overflow
 609:bellator_low_level.c **** 		if (data_in_pos == data_out_pos) {
 610:bellator_low_level.c **** 			log_string_warning("LPC overflow\n");
 611:bellator_low_level.c **** 			// the oldest data will be overwritten
 612:bellator_low_level.c **** 			data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 613:bellator_low_level.c **** 		}
 614:bellator_low_level.c **** 
 615:bellator_low_level.c **** 		// read data and put on local circular buffer
 616:bellator_low_level.c **** 		struct sensors_data* data;
 617:bellator_low_level.c **** 		data = &(sensors_data_buff[data_in_pos]);
 618:bellator_low_level.c **** 
 619:bellator_low_level.c **** 		// read encoder counts
 620:bellator_low_level.c **** 		get_encoders_count(&(data->encoder_left), &(data->encoder_right));
 621:bellator_low_level.c **** 
 622:bellator_low_level.c **** 		// read the last IMU data
 623:bellator_low_level.c **** 		mpu_get_motion6(&(data->ax_h));
 624:bellator_low_level.c **** 
 625:bellator_low_level.c **** 		// read IR data
 626:bellator_low_level.c **** 		get_ir_sensor_data(&(data->ir_l));
 627:bellator_low_level.c **** 
 628:bellator_low_level.c **** 		data->timestamp = timestamp++;
 629:bellator_low_level.c **** 
 630:bellator_low_level.c **** 		log_string_debug("IDISABLE\n");
 631:bellator_low_level.c **** 		IDISABLE
 632:bellator_low_level.c **** 
 633:bellator_low_level.c **** 		log_string_debug("<< sample\n");
 634:bellator_low_level.c **** 	}
 635:bellator_low_level.c **** 
 636:bellator_low_level.c **** 	VICVectAddr = 0;
 637:bellator_low_level.c **** }
 638:bellator_low_level.c **** 
 639:bellator_low_level.c **** /**
 640:bellator_low_level.c ****  *
 641:bellator_low_level.c ****  */
 642:bellator_low_level.c **** void error(void){
 643:bellator_low_level.c **** 	log_string_error("irq error");
 644:bellator_low_level.c **** }
 645:bellator_low_level.c **** 
 646:bellator_low_level.c **** /**
 647:bellator_low_level.c ****  * Return the value read from the i'th sensor
 648:bellator_low_level.c ****  * buff
 649:bellator_low_level.c ****  * ir_l, ir_ml, ir_m, ir_mr, ir_r
 650:bellator_low_level.c ****  *
 651:bellator_low_level.c ****  */
 652:bellator_low_level.c **** void get_ir_sensor_data(char * buff) {
 653:bellator_low_level.c **** 
 654:bellator_low_level.c **** 	unsigned short val;
 655:bellator_low_level.c **** 
 656:bellator_low_level.c **** 	while(ADDR0 & ((0x1 << 31) == 0));
 657:bellator_low_level.c **** 	val = (ADDR0 >> 6) & 0x3FF;
 658:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 659:bellator_low_level.c **** 	val += (val == 0);
 660:bellator_low_level.c **** 	*buff = (char) val;
 661:bellator_low_level.c **** 
 662:bellator_low_level.c **** 	while(ADDR1 & ((0x1 << 31) == 0));
 663:bellator_low_level.c **** 	val = (ADDR1 >> 6) & 0x3FF;
 664:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 665:bellator_low_level.c **** 	val += (val == 0);
 666:bellator_low_level.c **** 	*(buff+1) = (char) val;
 667:bellator_low_level.c **** 
 668:bellator_low_level.c **** 	while(ADDR2 & ((0x1 << 31) == 0));
 669:bellator_low_level.c **** 	val = (ADDR2 >> 6) & 0x3FF;
 670:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 671:bellator_low_level.c **** 	val += (val == 0);
 672:bellator_low_level.c **** 	*(buff+2) = (char) val;
 673:bellator_low_level.c **** 
 674:bellator_low_level.c **** 	while(ADDR3 & ((0x1 << 31) == 0));
 675:bellator_low_level.c **** 	val = (ADDR3 >> 6) & 0x3FF;
 676:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 677:bellator_low_level.c **** 	val += (val == 0);
 678:bellator_low_level.c **** 	*(buff+3) = (char) val;
 679:bellator_low_level.c **** 
 680:bellator_low_level.c **** 	while(ADDR4 & ((0x1 << 31) == 0));
 681:bellator_low_level.c **** 	val = (ADDR4 >> 6) & 0x3FF;
 682:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 683:bellator_low_level.c **** 	val += (val == 0);
 684:bellator_low_level.c **** 	*(buff+4) = (char) val;
 685:bellator_low_level.c **** }
 686:bellator_low_level.c **** 
 687:bellator_low_level.c **** 
 688:bellator_low_level.c **** 
 689:bellator_low_level.c **** /**
 690:bellator_low_level.c ****  * Return the count value read from the i'th sensor
 691:bellator_low_level.c ****  */
 692:bellator_low_level.c **** void get_encoders_count(short * left_encoder, short * right_encoder) {
 693:bellator_low_level.c **** 
 694:bellator_low_level.c **** 	int val;
 695:bellator_low_level.c **** 	val = encoder_count[ENCODER_L - ENCODER_L];
 696:bellator_low_level.c **** 	*left_encoder = val - sent_encoder_count[ENCODER_L - ENCODER_L];
 697:bellator_low_level.c **** 	sent_encoder_count[ENCODER_L - ENCODER_L] = val;
 698:bellator_low_level.c **** 
 699:bellator_low_level.c **** 	val = encoder_count[ENCODER_R - ENCODER_L];
 700:bellator_low_level.c **** 	*right_encoder = val - sent_encoder_count[ENCODER_R - ENCODER_L];
 701:bellator_low_level.c **** 	sent_encoder_count[ENCODER_R - ENCODER_L] = val;
 702:bellator_low_level.c **** }
 703:bellator_low_level.c **** 
 704:bellator_low_level.c **** /**
 705:bellator_low_level.c ****  * Set the output pwm value
 706:bellator_low_level.c ****  */
 707:bellator_low_level.c **** inline void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel) {
 708:bellator_low_level.c **** 
 709:bellator_low_level.c **** 	if (right_wheel & PWM_DIR) { // Forward
 710:bellator_low_level.c **** 		T0MR2 = 256;
 711:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 712:bellator_low_level.c **** 	} else { // Backwards
 713:bellator_low_level.c **** 		T0MR1 = 256;
 714:bellator_low_level.c **** 		T0MR2 = 256 - right_wheel*2;
 715:bellator_low_level.c **** 	}
 716:bellator_low_level.c **** 
 717:bellator_low_level.c **** 	if (left_wheel & PWM_DIR) { // Forward
 718:bellator_low_level.c **** 		T1MR0 = 256;
 719:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 720:bellator_low_level.c **** 	} else { // Backwards
 721:bellator_low_level.c **** 		T1MR1 = 256;
 265              		.loc 3 721 0
 266 01f8 80519FE5 		ldr	r5, .L34+8
 267 01fc 014CA0E3 		mov	r4, #256
 713:bellator_low_level.c **** 		T0MR1 = 256;
 268              		.loc 3 713 0
 269 0200 7CC19FE5 		ldr	ip, .L34+12
 270              	.LBE52:
 271              	.LBE51:
 482:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 272              		.loc 3 482 0
 273 0204 4D0000EA 		b	.L33
 274              	.LVL2:
 275              	.L30:
 483:bellator_low_level.c **** 		switch (iir & 0x0E) {
 276              		.loc 3 483 0
 277 0208 0630DDE5 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 278 020c 0E3003E2 		and	r3, r3, #14
 279              	.LVL3:
 280 0210 0C0053E3 		cmp	r3, #12
 281 0214 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 282 0218 480000EA 		b	.L33
 283              	.L23:
 284 021c 34030000 		.word	.L19
 285 0220 40030000 		.word	.L33
 286 0224 24030000 		.word	.L20
 287 0228 40030000 		.word	.L33
 288 022c 60020000 		.word	.L21
 289 0230 40030000 		.word	.L33
 290 0234 50020000 		.word	.L22
 291 0238 40030000 		.word	.L33
 292 023c 40030000 		.word	.L33
 293 0240 40030000 		.word	.L33
 294 0244 40030000 		.word	.L33
 295 0248 40030000 		.word	.L33
 296 024c 60020000 		.word	.L21
 297              	.L22:
 485:bellator_low_level.c **** 			dummy = U1LSR; // Just clear the interrupt source
 298              		.loc 3 485 0
 299 0250 1430D2E5 		ldrb	r3, [r2, #20]	@ zero_extendqisi2
 300 0254 FF3003E2 		and	r3, r3, #255
 301              	.LVL4:
 302 0258 0730CDE5 		strb	r3, [sp, #7]
 486:bellator_low_level.c **** 			break;
 303              		.loc 3 486 0
 304 025c 370000EA 		b	.L33
 305              	.LVL5:
 306              	.L21:
 490:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 307              		.loc 3 490 0
 308 0260 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 309 0264 FF3003E2 		and	r3, r3, #255
 310 0268 017080E0 		add	r7, r0, r1
 311 026c 1830C7E5 		strb	r3, [r7, #24]
 492:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 312              		.loc 3 492 0
 313 0270 FE0053E3 		cmp	r3, #254
 314 0274 2700001A 		bne	.L25
 494:bellator_low_level.c **** 				if (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] == ENGINES) {
 315              		.loc 3 494 0
 316 0278 023041E2 		sub	r3, r1, #2
 317 027c 1F3003E2 		and	r3, r3, #31
 318 0280 033080E0 		add	r3, r0, r3
 319 0284 1830D3E5 		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 320 0288 B00053E3 		cmp	r3, #176
 321 028c 1B00001A 		bne	.L26
 495:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]),
 322              		.loc 3 495 0
 323 0290 013041E2 		sub	r3, r1, #1
 324 0294 1F3003E2 		and	r3, r3, #31
 325 0298 033080E0 		add	r3, r0, r3
 326 029c 1830D3E5 		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 327              	.LVL6:
 496:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)]));
 328              		.loc 3 496 0
 329 02a0 1F7001E2 		and	r7, r1, #31
 330 02a4 077080E0 		add	r7, r0, r7
 331              	.LBB54:
 332              	.LBB53:
 709:bellator_low_level.c **** 	if (right_wheel & PWM_DIR) { // Forward
 333              		.loc 3 709 0
 334 02a8 1870D7E5 		ldrb	r7, [r7, #24]	@ zero_extendqisi2
 335 02ac 800017E3 		tst	r7, #128
 710:bellator_low_level.c **** 		T0MR2 = 256;
 336              		.loc 3 710 0
 337 02b0 20408C15 		strne	r4, [ip, #32]
 711:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 338              		.loc 3 711 0
 339 02b4 8070C713 		bicne	r7, r7, #128
 340 02b8 80706712 		rsbne	r7, r7, #128
 341 02bc 8770A011 		movne	r7, r7, asl #1
 342 02c0 1C708C15 		strne	r7, [ip, #28]
 713:bellator_low_level.c **** 		T0MR1 = 256;
 343              		.loc 3 713 0
 344 02c4 1C408C05 		streq	r4, [ip, #28]
 714:bellator_low_level.c **** 		T0MR2 = 256 - right_wheel*2;
 345              		.loc 3 714 0
 346 02c8 80706702 		rsbeq	r7, r7, #128
 347 02cc 8770A001 		moveq	r7, r7, asl #1
 348 02d0 20708C05 		streq	r7, [ip, #32]
 717:bellator_low_level.c **** 	if (left_wheel & PWM_DIR) { // Forward
 349              		.loc 3 717 0
 350 02d4 800013E3 		tst	r3, #128
 718:bellator_low_level.c **** 		T1MR0 = 256;
 351              		.loc 3 718 0
 352 02d8 18408515 		strne	r4, [r5, #24]
 719:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 353              		.loc 3 719 0
 354 02dc 8030C313 		bicne	r3, r3, #128
 355              	.LVL7:
 356 02e0 80306312 		rsbne	r3, r3, #128
 357 02e4 8330A011 		movne	r3, r3, asl #1
 358 02e8 1C308515 		strne	r3, [r5, #28]
 359              		.loc 3 721 0
 360 02ec 1C408505 		streq	r4, [r5, #28]
 722:bellator_low_level.c **** 		T1MR0 = 256 - left_wheel*2;
 361              		.loc 3 722 0
 362 02f0 80306302 		rsbeq	r3, r3, #128
 363 02f4 8330A001 		moveq	r3, r3, asl #1
 364 02f8 18308505 		streq	r3, [r5, #24]
 365 02fc 050000EA 		b	.L25
 366              	.LVL8:
 367              	.L26:
 368              	.LBE53:
 369              	.LBE54:
 499:bellator_low_level.c **** 				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
 370              		.loc 3 499 0
 371 0300 013041E2 		sub	r3, r1, #1
 372 0304 1F3003E2 		and	r3, r3, #31
 373 0308 033080E0 		add	r3, r0, r3
 374 030c 1830D3E5 		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 375 0310 A00053E3 		cmp	r3, #160
 500:bellator_low_level.c **** 					send_data = 1;
 376              		.loc 3 500 0
 377 0314 3860C005 		streqb	r6, [r0, #56]
 378              	.L25:
 504:bellator_low_level.c **** 			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
 379              		.loc 3 504 0
 380 0318 011081E2 		add	r1, r1, #1
 381 031c 1F1001E2 		and	r1, r1, #31
 505:bellator_low_level.c **** 			break;
 382              		.loc 3 505 0
 383 0320 060000EA 		b	.L33
 384              	.L20:
 508:bellator_low_level.c **** 			U1THR = dummy; // Just clear the interrupt source
 385              		.loc 3 508 0
 386 0324 0730DDE5 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 387              	.LVL9:
 388 0328 FF3003E2 		and	r3, r3, #255
 389              	.LVL10:
 390 032c 0030C2E5 		strb	r3, [r2, #0]
 509:bellator_low_level.c **** 			break;
 391              		.loc 3 509 0
 392 0330 020000EA 		b	.L33
 393              	.LVL11:
 394              	.L19:
 512:bellator_low_level.c **** 			dummy = U1MSR; // Just clear the interrupt source
 395              		.loc 3 512 0
 396 0334 1830D2E5 		ldrb	r3, [r2, #24]	@ zero_extendqisi2
 397 0338 FF3003E2 		and	r3, r3, #255
 398              	.LVL12:
 399 033c 0730CDE5 		strb	r3, [sp, #7]
 400              	.L33:
 482:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 401              		.loc 3 482 0 discriminator 1
 402 0340 0830D2E5 		ldrb	r3, [r2, #8]	@ zero_extendqisi2
 403              	.LVL13:
 404 0344 FF3003E2 		and	r3, r3, #255
 405              	.LVL14:
 406 0348 0630CDE5 		strb	r3, [sp, #6]
 407 034c 0630DDE5 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 408 0350 010013E3 		tst	r3, #1
 409 0354 ABFFFF0A 		beq	.L30
 482:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 410              		.loc 3 482 0 is_stmt 0
 411 0358 18309FE5 		ldr	r3, .L34
 412              	.LVL15:
 413 035c 141083E5 		str	r1, [r3, #20]
 522:bellator_low_level.c **** 	VICVectAddr = 0;
 414              		.loc 3 522 0 is_stmt 1
 415 0360 0020A0E3 		mov	r2, #0
 416 0364 0030E0E3 		mvn	r3, #0
 417 0368 CF2F03E5 		str	r2, [r3, #-4047]
 523:bellator_low_level.c **** }
 418              		.loc 3 523 0
 419 036c 0CD08DE2 		add	sp, sp, #12
 420 0370 FF10BDE8 		ldmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, ip}
 421 0374 04F05EE2 		subs	pc, lr, #4
 422              	.L35:
 423              		.align	2
 424              	.L34:
 425 0378 00000000 		.word	.LANCHOR0
 426 037c 000001E0 		.word	-536805376
 427 0380 008000E0 		.word	-536838144
 428 0384 004000E0 		.word	-536854528
 429              		.cfi_endproc
 430              	.LFE52:
 431              		.fnend
 433              		.align	2
 434              		.global	logger_init
 436              	logger_init:
 437              		.fnstart
 438              	.LFB0:
  20:logger.c      **** void logger_init(void){ // using UART0
 439              		.loc 1 20 0
 440              		.cfi_startproc
 441              		@ Function supports interworking.
 442              		@ args = 0, pretend = 0, frame = 0
 443              		@ frame_needed = 0, uses_anonymous_args = 0
 444              		@ link register save eliminated.
  21:logger.c      **** 	PINSEL0 |= 0x05; // Set the pins function
 445              		.loc 1 21 0
 446 0388 54309FE5 		ldr	r3, .L37
 447 038c 002093E5 		ldr	r2, [r3, #0]
 448 0390 052082E3 		orr	r2, r2, #5
 449 0394 002083E5 		str	r2, [r3, #0]
  22:logger.c      **** 	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
 450              		.loc 1 22 0
 451 0398 48309FE5 		ldr	r3, .L37+4
 452 039c 0720A0E3 		mov	r2, #7
 453 03a0 0820C3E5 		strb	r2, [r3, #8]
  23:logger.c      **** 	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 454              		.loc 1 23 0
 455 03a4 7C20E0E3 		mvn	r2, #124
 456 03a8 0C20C3E5 		strb	r2, [r3, #12]
  26:logger.c      **** 	U0DLL	 = 0x06; // DivisorLatchLow bit
 457              		.loc 1 26 0
 458 03ac 0620A0E3 		mov	r2, #6
 459 03b0 0020C3E5 		strb	r2, [r3, #0]
  27:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
 460              		.loc 1 27 0
 461 03b4 0020A0E3 		mov	r2, #0
 462 03b8 0420C3E5 		strb	r2, [r3, #4]
  28:logger.c      **** 	U0FDR	|= 0x05; // DivAddVal
 463              		.loc 1 28 0
 464 03bc 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 465 03c0 FF2002E2 		and	r2, r2, #255
 466 03c4 052082E3 		orr	r2, r2, #5
 467 03c8 2820C3E5 		strb	r2, [r3, #40]
  29:logger.c      **** 	U0FDR	|= 0x0E << 4; // MulVal = 14
 468              		.loc 1 29 0
 469 03cc 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 470 03d0 E02082E3 		orr	r2, r2, #224
 471 03d4 2820C3E5 		strb	r2, [r3, #40]
  36:logger.c      **** 	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 472              		.loc 1 36 0
 473 03d8 0320A0E3 		mov	r2, #3
 474 03dc 0C20C3E5 		strb	r2, [r3, #12]
  37:logger.c      **** }
 475              		.loc 1 37 0
 476 03e0 1EFF2FE1 		bx	lr
 477              	.L38:
 478              		.align	2
 479              	.L37:
 480 03e4 00C002E0 		.word	-536690688
 481 03e8 00C000E0 		.word	-536821760
 482              		.cfi_endproc
 483              	.LFE0:
 484              		.fnend
 486              		.align	2
 487              		.global	log_int
 489              	log_int:
 490              		.fnstart
 491              	.LFB2:
  43:logger.c      **** 
  44:logger.c      **** void log_int(int num){
 492              		.loc 1 44 0
 493              		.cfi_startproc
 494              		@ Function supports interworking.
 495              		@ args = 0, pretend = 0, frame = 0
 496              		@ frame_needed = 0, uses_anonymous_args = 0
 497              	.LVL16:
 498 03ec 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 499              		.save {r3, r4, r5, lr}
 500              	.LCFI4:
 501              		.cfi_def_cfa_offset 16
  45:logger.c      **** 	if(num & 0x80000000){ // se for negativo
 502              		.loc 1 45 0
 503 03f0 004050E2 		subs	r4, r0, #0
 504              		.cfi_offset 14, -4
 505              		.cfi_offset 5, -8
 506              		.cfi_offset 4, -12
 507              		.cfi_offset 3, -16
 508 03f4 030000AA 		bge	.L40
  46:logger.c      **** 		log_char('-');
 509              		.loc 1 46 0
 510 03f8 2D00A0E3 		mov	r0, #45
 511              	.LVL17:
 512 03fc FFFEFFEB 		bl	log_char
 513              	.LVL18:
  47:logger.c      **** 		num = ~num;
  48:logger.c      **** 		num += 0x1;
 514              		.loc 1 48 0
 515 0400 004064E2 		rsb	r4, r4, #0
 516              	.LVL19:
 517 0404 010000EA 		b	.L41
 518              	.LVL20:
 519              	.L40:
  49:logger.c      **** 	}else
  50:logger.c      **** 		log_char(' ');
 520              		.loc 1 50 0
 521 0408 2000A0E3 		mov	r0, #32
 522              	.LVL21:
 523 040c FBFEFFEB 		bl	log_char
 524              	.L41:
  51:logger.c      **** 	log_char(ascii[num >> 28]);
 525              		.loc 1 51 0
 526 0410 78509FE5 		ldr	r5, .L42
 527 0414 440ED5E7 		ldrb	r0, [r5, r4, asr #28]	@ zero_extendqisi2
 528 0418 F8FEFFEB 		bl	log_char
  52:logger.c      **** 	log_char(ascii[num >> 24 & 0x0000000f]);
 529              		.loc 1 52 0
 530 041c 443CA0E1 		mov	r3, r4, asr #24
 531 0420 0F3003E2 		and	r3, r3, #15
 532 0424 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 533 0428 F4FEFFEB 		bl	log_char
  53:logger.c      **** 	log_char(ascii[num >> 20 & 0x0000000f]);
 534              		.loc 1 53 0
 535 042c 443AA0E1 		mov	r3, r4, asr #20
 536 0430 0F3003E2 		and	r3, r3, #15
 537 0434 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 538 0438 F0FEFFEB 		bl	log_char
  54:logger.c      **** 	log_char(ascii[num >> 16 & 0x0000000f]);
 539              		.loc 1 54 0
 540 043c 4438A0E1 		mov	r3, r4, asr #16
 541 0440 0F3003E2 		and	r3, r3, #15
 542 0444 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 543 0448 ECFEFFEB 		bl	log_char
  55:logger.c      **** 	log_char(ascii[num >> 12 & 0x0000000f]);
 544              		.loc 1 55 0
 545 044c 4436A0E1 		mov	r3, r4, asr #12
 546 0450 0F3003E2 		and	r3, r3, #15
 547 0454 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 548 0458 E8FEFFEB 		bl	log_char
  56:logger.c      **** 	log_char(ascii[num >> 8 & 0x0000000f]);
 549              		.loc 1 56 0
 550 045c 4434A0E1 		mov	r3, r4, asr #8
 551 0460 0F3003E2 		and	r3, r3, #15
 552 0464 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 553 0468 E4FEFFEB 		bl	log_char
  57:logger.c      **** 	log_char(ascii[num >> 4 & 0x0000000f]);
 554              		.loc 1 57 0
 555 046c 4432A0E1 		mov	r3, r4, asr #4
 556 0470 0F3003E2 		and	r3, r3, #15
 557 0474 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 558 0478 E0FEFFEB 		bl	log_char
  58:logger.c      **** 	log_char(ascii[num & 0x0000000f]);
 559              		.loc 1 58 0
 560 047c 0F4004E2 		and	r4, r4, #15
 561              	.LVL22:
 562 0480 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 563 0484 DDFEFFEB 		bl	log_char
  59:logger.c      **** }
 564              		.loc 1 59 0
 565 0488 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 566 048c 1EFF2FE1 		bx	lr
 567              	.L43:
 568              		.align	2
 569              	.L42:
 570 0490 00000000 		.word	.LANCHOR1
 571              		.cfi_endproc
 572              	.LFE2:
 573              		.fnend
 575              		.align	2
 576              		.global	log_short
 578              	log_short:
 579              		.fnstart
 580              	.LFB3:
  60:logger.c      **** 
  61:logger.c      **** void log_short(short num){
 581              		.loc 1 61 0
 582              		.cfi_startproc
 583              		@ Function supports interworking.
 584              		@ args = 0, pretend = 0, frame = 0
 585              		@ frame_needed = 0, uses_anonymous_args = 0
 586              	.LVL23:
 587 0494 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 588              		.save {r3, r4, r5, lr}
 589              	.LCFI5:
 590              		.cfi_def_cfa_offset 16
  62:logger.c      **** 	if(num & 0x8000){ // se for negativo
 591              		.loc 1 62 0
 592 0498 004050E2 		subs	r4, r0, #0
 593              		.cfi_offset 14, -4
 594              		.cfi_offset 5, -8
 595              		.cfi_offset 4, -12
 596              		.cfi_offset 3, -16
 597 049c 050000AA 		bge	.L45
  63:logger.c      **** 		log_char('-');
 598              		.loc 1 63 0
 599 04a0 2D00A0E3 		mov	r0, #45
 600              	.LVL24:
 601 04a4 D5FEFFEB 		bl	log_char
 602              	.LVL25:
  64:logger.c      **** 		num = ~num;
  65:logger.c      **** 		num++;
 603              		.loc 1 65 0
 604 04a8 004064E2 		rsb	r4, r4, #0
 605              	.LVL26:
 606 04ac 0448A0E1 		mov	r4, r4, asl #16
 607              	.LVL27:
 608 04b0 4448A0E1 		mov	r4, r4, asr #16
 609              	.LVL28:
 610 04b4 010000EA 		b	.L46
 611              	.LVL29:
 612              	.L45:
  66:logger.c      **** 	}else
  67:logger.c      **** 		log_char(' ');
 613              		.loc 1 67 0
 614 04b8 2000A0E3 		mov	r0, #32
 615              	.LVL30:
 616 04bc CFFEFFEB 		bl	log_char
 617              	.L46:
 618              	.LVL31:
  68:logger.c      **** 	log_char(ascii[num >> 12]);
 619              		.loc 1 68 0
 620 04c0 38509FE5 		ldr	r5, .L47
 621 04c4 4406D5E7 		ldrb	r0, [r5, r4, asr #12]	@ zero_extendqisi2
 622 04c8 CCFEFFEB 		bl	log_char
  69:logger.c      **** 	log_char(ascii[num >> 8 & 0x000f]);
 623              		.loc 1 69 0
 624 04cc 2434A0E1 		mov	r3, r4, lsr #8
 625 04d0 0F3003E2 		and	r3, r3, #15
 626 04d4 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 627 04d8 C8FEFFEB 		bl	log_char
  70:logger.c      **** 	log_char(ascii[num >> 4 & 0x000f]);
 628              		.loc 1 70 0
 629 04dc 2432A0E1 		mov	r3, r4, lsr #4
 630 04e0 0F3003E2 		and	r3, r3, #15
 631 04e4 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 632 04e8 C4FEFFEB 		bl	log_char
  71:logger.c      **** 	log_char(ascii[num & 0x000f]);
 633              		.loc 1 71 0
 634 04ec 0F4004E2 		and	r4, r4, #15
 635              	.LVL32:
 636 04f0 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 637 04f4 C1FEFFEB 		bl	log_char
  72:logger.c      **** }
 638              		.loc 1 72 0
 639 04f8 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 640 04fc 1EFF2FE1 		bx	lr
 641              	.L48:
 642              		.align	2
 643              	.L47:
 644 0500 00000000 		.word	.LANCHOR1
 645              		.cfi_endproc
 646              	.LFE3:
 647              		.fnend
 649              		.align	2
 650              		.global	log_string
 652              	log_string:
 653              		.fnstart
 654              	.LFB4:
  73:logger.c      **** 
  74:logger.c      **** void log_string(const char *s){
 655              		.loc 1 74 0
 656              		.cfi_startproc
 657              		@ Function supports interworking.
 658              		@ args = 0, pretend = 0, frame = 0
 659              		@ frame_needed = 0, uses_anonymous_args = 0
 660              	.LVL33:
 661 0504 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 662              		.save {r3, r4, r5, lr}
 663              	.LCFI6:
 664              		.cfi_def_cfa_offset 16
  75:logger.c      **** 	while(*s){
 665              		.loc 1 75 0
 666 0508 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 667              		.cfi_offset 14, -4
 668              		.cfi_offset 5, -8
 669              		.cfi_offset 4, -12
 670              		.cfi_offset 3, -16
 671 050c 000053E3 		cmp	r3, #0
 672 0510 0900000A 		beq	.L49
 673 0514 0040A0E1 		mov	r4, r0
  76:logger.c      **** 		if(*s == '\n')
  77:logger.c      **** 			log_char('\r'); // \n + \r = new line
 674              		.loc 1 77 0
 675 0518 0D50A0E3 		mov	r5, #13
 676              	.LVL34:
 677              	.L52:
  76:logger.c      **** 		if(*s == '\n')
 678              		.loc 1 76 0
 679 051c 0A0053E3 		cmp	r3, #10
 680              		.loc 1 77 0
 681 0520 0500A001 		moveq	r0, r5
 682 0524 B5FEFF0B 		bleq	log_char
 683              	.L51:
  78:logger.c      **** 		log_char(*s);
 684              		.loc 1 78 0
 685 0528 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 686 052c B3FEFFEB 		bl	log_char
  75:logger.c      **** 	while(*s){
 687              		.loc 1 75 0
 688 0530 0130F4E5 		ldrb	r3, [r4, #1]!	@ zero_extendqisi2
 689 0534 000053E3 		cmp	r3, #0
 690 0538 F7FFFF1A 		bne	.L52
 691              	.L49:
  79:logger.c      **** 		s++;
  80:logger.c      **** 	}
  81:logger.c      **** }
 692              		.loc 1 81 0
 693 053c 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 694 0540 1EFF2FE1 		bx	lr
 695              		.cfi_endproc
 696              	.LFE4:
 697              		.fnend
 699              		.align	2
 700              		.global	error
 702              	error:
 703              		.fnstart
 704              	.LFB55:
 642:bellator_low_level.c **** void error(void){
 705              		.loc 3 642 0
 706              		.cfi_startproc
 707              		@ Interrupt Service Routine.
 708              		@ args = 0, pretend = 0, frame = 0
 709              		@ frame_needed = 0, uses_anonymous_args = 0
 710 0544 04E04EE2 		sub	lr, lr, #4
 711 0548 0F502DE9 		stmfd	sp!, {r0, r1, r2, r3, ip, lr}
 712              		.save {r0, r1, r2, r3, ip, lr}
 713              	.LCFI7:
 714              		.cfi_def_cfa_offset 24
 643:bellator_low_level.c **** 	log_string_error("irq error");
 715              		.loc 3 643 0
 716 054c 04009FE5 		ldr	r0, .L55
 717              		.cfi_offset 14, -4
 718              		.cfi_offset 12, -8
 719              		.cfi_offset 3, -12
 720              		.cfi_offset 2, -16
 721              		.cfi_offset 1, -20
 722              		.cfi_offset 0, -24
 723 0550 FEFFFFEB 		bl	log_string
 644:bellator_low_level.c **** }
 724              		.loc 3 644 0
 725 0554 0F90FDE8 		ldmfd	sp!, {r0, r1, r2, r3, ip, pc}^
 726              	.L56:
 727              		.align	2
 728              	.L55:
 729 0558 00000000 		.word	.LC0
 730              		.cfi_endproc
 731              	.LFE55:
 732              		.fnend
 734              		.align	2
 735              		.global	i2c_read_bytes_isr
 737              	i2c_read_bytes_isr:
 738              		.fnstart
 739              	.LFB18:
  90:i2c.c         **** void i2c_read_bytes_isr(void) {
 740              		.loc 2 90 0
 741              		.cfi_startproc
 742              		@ Interrupt Service Routine.
 743              		@ args = 0, pretend = 0, frame = 8
 744              		@ frame_needed = 0, uses_anonymous_args = 0
 745 055c 04E04EE2 		sub	lr, lr, #4
 746 0560 0F502DE9 		stmfd	sp!, {r0, r1, r2, r3, ip, lr}
 747              		.save {r0, r1, r2, r3, ip, lr}
 748              	.LCFI8:
 749              		.cfi_def_cfa_offset 24
 750              		.pad #8
 751 0564 08D04DE2 		sub	sp, sp, #8
 752              	.LCFI9:
 753              		.cfi_def_cfa_offset 32
  92:i2c.c         **** 	volatile int temp = 0;
 754              		.loc 2 92 0
 755 0568 0030A0E3 		mov	r3, #0
 756              		.cfi_offset 14, -4
 757              		.cfi_offset 12, -8
 758              		.cfi_offset 3, -12
 759              		.cfi_offset 2, -16
 760              		.cfi_offset 1, -20
 761              		.cfi_offset 0, -24
 762 056c 04308DE5 		str	r3, [sp, #4]
 763              	.LVL35:
  93:i2c.c         **** 	temp = I2C1STAT;
 764              		.loc 2 93 0
 765 0570 B8329FE5 		ldr	r3, .L71
 766 0574 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 767 0578 FF3003E2 		and	r3, r3, #255
 768 057c 04308DE5 		str	r3, [sp, #4]
  95:i2c.c         **** 	switch (temp) {
 769              		.loc 2 95 0
 770 0580 04309DE5 		ldr	r3, [sp, #4]
 771 0584 083043E2 		sub	r3, r3, #8
 772 0588 500053E3 		cmp	r3, #80
 773 058c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 774 0590 980000EA 		b	.L58
 775              	.L67:
 776 0594 D8060000 		.word	.L59
 777 0598 F8070000 		.word	.L58
 778 059c F8070000 		.word	.L58
 779 05a0 F8070000 		.word	.L58
 780 05a4 F8070000 		.word	.L58
 781 05a8 F8070000 		.word	.L58
 782 05ac F8070000 		.word	.L58
 783 05b0 F8070000 		.word	.L58
 784 05b4 F0060000 		.word	.L60
 785 05b8 F8070000 		.word	.L58
 786 05bc F8070000 		.word	.L58
 787 05c0 F8070000 		.word	.L58
 788 05c4 F8070000 		.word	.L58
 789 05c8 F8070000 		.word	.L58
 790 05cc F8070000 		.word	.L58
 791 05d0 F8070000 		.word	.L58
 792 05d4 08070000 		.word	.L61
 793 05d8 F8070000 		.word	.L58
 794 05dc F8070000 		.word	.L58
 795 05e0 F8070000 		.word	.L58
 796 05e4 F8070000 		.word	.L58
 797 05e8 F8070000 		.word	.L58
 798 05ec F8070000 		.word	.L58
 799 05f0 F8070000 		.word	.L58
 800 05f4 1C080000 		.word	.L62
 801 05f8 F8070000 		.word	.L58
 802 05fc F8070000 		.word	.L58
 803 0600 F8070000 		.word	.L58
 804 0604 F8070000 		.word	.L58
 805 0608 F8070000 		.word	.L58
 806 060c F8070000 		.word	.L58
 807 0610 F8070000 		.word	.L58
 808 0614 24070000 		.word	.L63
 809 0618 F8070000 		.word	.L58
 810 061c F8070000 		.word	.L58
 811 0620 F8070000 		.word	.L58
 812 0624 F8070000 		.word	.L58
 813 0628 F8070000 		.word	.L58
 814 062c F8070000 		.word	.L58
 815 0630 F8070000 		.word	.L58
 816 0634 1C080000 		.word	.L62
 817 0638 F8070000 		.word	.L58
 818 063c F8070000 		.word	.L58
 819 0640 F8070000 		.word	.L58
 820 0644 F8070000 		.word	.L58
 821 0648 F8070000 		.word	.L58
 822 064c F8070000 		.word	.L58
 823 0650 F8070000 		.word	.L58
 824 0654 1C080000 		.word	.L62
 825 0658 F8070000 		.word	.L58
 826 065c F8070000 		.word	.L58
 827 0660 F8070000 		.word	.L58
 828 0664 F8070000 		.word	.L58
 829 0668 F8070000 		.word	.L58
 830 066c F8070000 		.word	.L58
 831 0670 F8070000 		.word	.L58
 832 0674 3C070000 		.word	.L64
 833 0678 F8070000 		.word	.L58
 834 067c F8070000 		.word	.L58
 835 0680 F8070000 		.word	.L58
 836 0684 F8070000 		.word	.L58
 837 0688 F8070000 		.word	.L58
 838 068c F8070000 		.word	.L58
 839 0690 F8070000 		.word	.L58
 840 0694 1C080000 		.word	.L62
 841 0698 F8070000 		.word	.L58
 842 069c F8070000 		.word	.L58
 843 06a0 F8070000 		.word	.L58
 844 06a4 F8070000 		.word	.L58
 845 06a8 F8070000 		.word	.L58
 846 06ac F8070000 		.word	.L58
 847 06b0 F8070000 		.word	.L58
 848 06b4 64070000 		.word	.L65
 849 06b8 F8070000 		.word	.L58
 850 06bc F8070000 		.word	.L58
 851 06c0 F8070000 		.word	.L58
 852 06c4 F8070000 		.word	.L58
 853 06c8 F8070000 		.word	.L58
 854 06cc F8070000 		.word	.L58
 855 06d0 F8070000 		.word	.L58
 856 06d4 A4070000 		.word	.L66
 857              	.L59:
  98:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
 858              		.loc 2 98 0
 859 06d8 50319FE5 		ldr	r3, .L71
 860 06dc 2F20E0E3 		mvn	r2, #47
 861 06e0 0820C3E5 		strb	r2, [r3, #8]
  99:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 862              		.loc 2 99 0
 863 06e4 2820A0E3 		mov	r2, #40
 864 06e8 1820C3E5 		strb	r2, [r3, #24]
 100:i2c.c         **** 		break;
 865              		.loc 2 100 0
 866 06ec 4A0000EA 		b	.L62
 867              	.L60:
 103:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_READ; // Slave address + Read
 868              		.loc 2 103 0
 869 06f0 38319FE5 		ldr	r3, .L71
 870 06f4 2E20E0E3 		mvn	r2, #46
 871 06f8 0820C3E5 		strb	r2, [r3, #8]
 104:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 872              		.loc 2 104 0
 873 06fc 2820A0E3 		mov	r2, #40
 874 0700 1820C3E5 		strb	r2, [r3, #24]
 105:i2c.c         **** 		break;
 875              		.loc 2 105 0
 876 0704 440000EA 		b	.L62
 877              	.L61:
 108:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 878              		.loc 2 108 0
 879 0708 24319FE5 		ldr	r3, .L71+4
 880 070c 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 881 0710 18319FE5 		ldr	r3, .L71
 882 0714 0820C3E5 		strb	r2, [r3, #8]
 109:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 883              		.loc 2 109 0
 884 0718 0820A0E3 		mov	r2, #8
 885 071c 1820C3E5 		strb	r2, [r3, #24]
 110:i2c.c         **** 		break;
 886              		.loc 2 110 0
 887 0720 3D0000EA 		b	.L62
 888              	.L63:
 116:i2c.c         **** 		I2C1CONSET = 0x20; // Transmit start condition
 889              		.loc 2 116 0
 890 0724 04319FE5 		ldr	r3, .L71
 891 0728 2020A0E3 		mov	r2, #32
 892 072c 0020C3E5 		strb	r2, [r3, #0]
 117:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 893              		.loc 2 117 0
 894 0730 0820A0E3 		mov	r2, #8
 895 0734 1820C3E5 		strb	r2, [r3, #24]
 118:i2c.c         **** 		break;
 896              		.loc 2 118 0
 897 0738 370000EA 		b	.L62
 898              	.L64:
 128:i2c.c         **** 		if(buff_size > 1)
 899              		.loc 2 128 0
 900 073c F0309FE5 		ldr	r3, .L71+4
 901 0740 083093E5 		ldr	r3, [r3, #8]
 902 0744 010053E3 		cmp	r3, #1
 129:i2c.c         **** 			I2C1CONSET = 0x04; // Transmit ACK on data receives
 903              		.loc 2 129 0
 904 0748 0420A0C3 		movgt	r2, #4
 905 074c DC309FC5 		ldrgt	r3, .L71
 906 0750 0020C3C5 		strgtb	r2, [r3, #0]
 130:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 907              		.loc 2 130 0
 908 0754 0820A0E3 		mov	r2, #8
 909 0758 D0309FE5 		ldr	r3, .L71
 910 075c 1820C3E5 		strb	r2, [r3, #24]
 131:i2c.c         **** 		break;
 911              		.loc 2 131 0
 912 0760 2D0000EA 		b	.L62
 913              	.L65:
 140:i2c.c         **** 		if ((buff_pos + 2) < buff_size) {
 914              		.loc 2 140 0
 915 0764 C8209FE5 		ldr	r2, .L71+4
 916 0768 043092E5 		ldr	r3, [r2, #4]
 917 076c 021083E2 		add	r1, r3, #2
 918 0770 082092E5 		ldr	r2, [r2, #8]
 919 0774 020051E1 		cmp	r1, r2
 141:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 920              		.loc 2 141 0
 921 0778 B0209FE5 		ldr	r2, .L71
 922 077c 08C0D2E5 		ldrb	ip, [r2, #8]	@ zero_extendqisi2
 923 0780 AC109FE5 		ldr	r1, .L71+4
 924 0784 0C0091E5 		ldr	r0, [r1, #12]
 925 0788 03C0C0E7 		strb	ip, [r0, r3]
 926 078c 013083E2 		add	r3, r3, #1
 927 0790 043081E5 		str	r3, [r1, #4]
 142:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 928              		.loc 2 142 0
 929 0794 0830A0B3 		movlt	r3, #8
 146:i2c.c         **** 			I2C1CONCLR = 0x0C; // Transmit NACK on next data receive, Clear SI
 930              		.loc 2 146 0
 931 0798 0C30A0A3 		movge	r3, #12
 932 079c 1830C2E5 		strb	r3, [r2, #24]
 933 07a0 1D0000EA 		b	.L62
 934              	.L66:
 154:i2c.c         **** 		if (buff_pos < buff_size) {
 935              		.loc 2 154 0
 936 07a4 88209FE5 		ldr	r2, .L71+4
 937 07a8 043092E5 		ldr	r3, [r2, #4]
 938 07ac 082092E5 		ldr	r2, [r2, #8]
 939 07b0 020053E1 		cmp	r3, r2
 940 07b4 060000AA 		bge	.L70
 155:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 941              		.loc 2 155 0
 942 07b8 70209FE5 		ldr	r2, .L71
 943 07bc 0800D2E5 		ldrb	r0, [r2, #8]	@ zero_extendqisi2
 944 07c0 6C209FE5 		ldr	r2, .L71+4
 945 07c4 0C1092E5 		ldr	r1, [r2, #12]
 946 07c8 0300C1E7 		strb	r0, [r1, r3]
 947 07cc 013083E2 		add	r3, r3, #1
 948 07d0 043082E5 		str	r3, [r2, #4]
 949              	.L70:
 157:i2c.c         **** 		I2C1CONSET = 0x10; // Transmit stop condition
 950              		.loc 2 157 0
 951 07d4 54309FE5 		ldr	r3, .L71
 952 07d8 1020A0E3 		mov	r2, #16
 953 07dc 0020C3E5 		strb	r2, [r3, #0]
 158:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 954              		.loc 2 158 0
 955 07e0 0820A0E3 		mov	r2, #8
 956 07e4 1820C3E5 		strb	r2, [r3, #24]
 159:i2c.c         **** 		busy = 0; // data ready to be returned
 957              		.loc 2 159 0
 958 07e8 0020A0E3 		mov	r2, #0
 959 07ec 40309FE5 		ldr	r3, .L71+4
 960 07f0 102083E5 		str	r2, [r3, #16]
 160:i2c.c         **** 		break;
 961              		.loc 2 160 0
 962 07f4 080000EA 		b	.L62
 963              	.L58:
 163:i2c.c         **** 		log_string_warning("[i2c] default: ");
 964              		.loc 2 163 0
 965 07f8 38009FE5 		ldr	r0, .L71+8
 966 07fc FEFFFFEB 		bl	log_string
 164:i2c.c         **** 		log_int_warning(temp);
 967              		.loc 2 164 0
 968 0800 04009DE5 		ldr	r0, [sp, #4]
 969 0804 FEFFFFEB 		bl	log_int
 165:i2c.c         **** 		log_string_warning("\n");
 970              		.loc 2 165 0
 971 0808 2C009FE5 		ldr	r0, .L71+12
 972 080c FEFFFFEB 		bl	log_string
 167:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 973              		.loc 2 167 0
 974 0810 0820A0E3 		mov	r2, #8
 975 0814 14309FE5 		ldr	r3, .L71
 976 0818 1820C3E5 		strb	r2, [r3, #24]
 977              	.L62:
 172:i2c.c         **** 	VICVectAddr = 0;
 978              		.loc 2 172 0
 979 081c 0020A0E3 		mov	r2, #0
 980 0820 0030E0E3 		mvn	r3, #0
 981 0824 CF2F03E5 		str	r2, [r3, #-4047]
 173:i2c.c         **** }
 982              		.loc 2 173 0
 983 0828 08D08DE2 		add	sp, sp, #8
 984 082c 0F90FDE8 		ldmfd	sp!, {r0, r1, r2, r3, ip, pc}^
 985              	.L72:
 986              		.align	2
 987              	.L71:
 988 0830 00C005E0 		.word	-536494080
 989 0834 00000000 		.word	.LANCHOR0
 990 0838 0C000000 		.word	.LC1
 991 083c 1C000000 		.word	.LC2
 992              		.cfi_endproc
 993              	.LFE18:
 994              		.fnend
 996              		.align	2
 997              		.global	log_byte
 999              	log_byte:
 1000              		.fnstart
 1001              	.LFB5:
  82:logger.c      **** 
  83:logger.c      **** void log_byte(char c){
 1002              		.loc 1 83 0
 1003              		.cfi_startproc
 1004              		@ Function supports interworking.
 1005              		@ args = 0, pretend = 0, frame = 0
 1006              		@ frame_needed = 0, uses_anonymous_args = 0
 1007              	.LVL36:
 1008 0840 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1009              		.save {r3, r4, r5, lr}
 1010              	.LCFI10:
 1011              		.cfi_def_cfa_offset 16
 1012 0844 0040A0E1 		mov	r4, r0
 1013              		.cfi_offset 14, -4
 1014              		.cfi_offset 5, -8
 1015              		.cfi_offset 4, -12
 1016              		.cfi_offset 3, -16
  84:logger.c      **** 	if(c & 0x80){ // se for negativo
 1017              		.loc 1 84 0
 1018 0848 800010E3 		tst	r0, #128
 1019 084c 0400000A 		beq	.L74
  85:logger.c      **** 		log_char('-');
 1020              		.loc 1 85 0
 1021 0850 2D00A0E3 		mov	r0, #45
 1022              	.LVL37:
 1023 0854 E9FDFFEB 		bl	log_char
 1024              	.LVL38:
  86:logger.c      **** 		c = ~c;
  87:logger.c      **** 		c++;
 1025              		.loc 1 87 0
 1026 0858 004064E2 		rsb	r4, r4, #0
 1027              	.LVL39:
 1028 085c FF4004E2 		and	r4, r4, #255
 1029              	.LVL40:
 1030 0860 010000EA 		b	.L75
 1031              	.LVL41:
 1032              	.L74:
  88:logger.c      **** 	}else
  89:logger.c      **** 		log_char(' ');
 1033              		.loc 1 89 0
 1034 0864 2000A0E3 		mov	r0, #32
 1035              	.LVL42:
 1036 0868 E4FDFFEB 		bl	log_char
 1037              	.L75:
 1038              	.LVL43:
  90:logger.c      **** 	log_char(ascii[c >> 4]);
 1039              		.loc 1 90 0
 1040 086c 18509FE5 		ldr	r5, .L76
 1041 0870 2402D5E7 		ldrb	r0, [r5, r4, lsr #4]	@ zero_extendqisi2
 1042 0874 E1FDFFEB 		bl	log_char
  91:logger.c      **** 	log_char(ascii[c & 0x000f]);
 1043              		.loc 1 91 0
 1044 0878 0F4004E2 		and	r4, r4, #15
 1045              	.LVL44:
 1046 087c 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1047 0880 DEFDFFEB 		bl	log_char
  92:logger.c      **** }
 1048              		.loc 1 92 0
 1049 0884 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1050 0888 1EFF2FE1 		bx	lr
 1051              	.L77:
 1052              		.align	2
 1053              	.L76:
 1054 088c 00000000 		.word	.LANCHOR1
 1055              		.cfi_endproc
 1056              	.LFE5:
 1057              		.fnend
 1059              		.align	2
 1060              		.global	log2bytes
 1062              	log2bytes:
 1063              		.fnstart
 1064              	.LFB6:
  93:logger.c      **** 
  94:logger.c      **** void log2bytes(short c){
 1065              		.loc 1 94 0
 1066              		.cfi_startproc
 1067              		@ Function supports interworking.
 1068              		@ args = 0, pretend = 0, frame = 0
 1069              		@ frame_needed = 0, uses_anonymous_args = 0
 1070              	.LVL45:
 1071 0890 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1072              		.save {r3, r4, r5, lr}
 1073              	.LCFI11:
 1074              		.cfi_def_cfa_offset 16
  95:logger.c      **** 	if(c & 0x8000){ // se for negativo
 1075              		.loc 1 95 0
 1076 0894 004050E2 		subs	r4, r0, #0
 1077              		.cfi_offset 14, -4
 1078              		.cfi_offset 5, -8
 1079              		.cfi_offset 4, -12
 1080              		.cfi_offset 3, -16
 1081 0898 050000AA 		bge	.L79
  96:logger.c      **** 		log_char('-');
 1082              		.loc 1 96 0
 1083 089c 2D00A0E3 		mov	r0, #45
 1084              	.LVL46:
 1085 08a0 D6FDFFEB 		bl	log_char
 1086              	.LVL47:
  97:logger.c      **** 		c = ~c;
  98:logger.c      **** 		c++;
 1087              		.loc 1 98 0
 1088 08a4 004064E2 		rsb	r4, r4, #0
 1089              	.LVL48:
 1090 08a8 0448A0E1 		mov	r4, r4, asl #16
 1091              	.LVL49:
 1092 08ac 4448A0E1 		mov	r4, r4, asr #16
 1093              	.LVL50:
 1094 08b0 010000EA 		b	.L80
 1095              	.LVL51:
 1096              	.L79:
  99:logger.c      **** 	}else
 100:logger.c      **** 		log_char(' ');
 1097              		.loc 1 100 0
 1098 08b4 2000A0E3 		mov	r0, #32
 1099              	.LVL52:
 1100 08b8 D0FDFFEB 		bl	log_char
 1101              	.L80:
 1102              	.LVL53:
 101:logger.c      **** 	log_char(ascii[c >> 12]);
 1103              		.loc 1 101 0
 1104 08bc 38509FE5 		ldr	r5, .L81
 1105 08c0 4406D5E7 		ldrb	r0, [r5, r4, asr #12]	@ zero_extendqisi2
 1106 08c4 CDFDFFEB 		bl	log_char
 102:logger.c      **** 	log_char(ascii[c >> 8 & 0x000f]);
 1107              		.loc 1 102 0
 1108 08c8 2434A0E1 		mov	r3, r4, lsr #8
 1109 08cc 0F3003E2 		and	r3, r3, #15
 1110 08d0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1111 08d4 C9FDFFEB 		bl	log_char
 103:logger.c      **** 	log_char(ascii[c >> 4 & 0x000f]);
 1112              		.loc 1 103 0
 1113 08d8 2432A0E1 		mov	r3, r4, lsr #4
 1114 08dc 0F3003E2 		and	r3, r3, #15
 1115 08e0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1116 08e4 C5FDFFEB 		bl	log_char
 104:logger.c      **** 	log_char(ascii[c & 0x000f]);
 1117              		.loc 1 104 0
 1118 08e8 0F4004E2 		and	r4, r4, #15
 1119              	.LVL54:
 1120 08ec 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1121 08f0 C2FDFFEB 		bl	log_char
 105:logger.c      **** }
 1122              		.loc 1 105 0
 1123 08f4 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1124 08f8 1EFF2FE1 		bx	lr
 1125              	.L82:
 1126              		.align	2
 1127              	.L81:
 1128 08fc 00000000 		.word	.LANCHOR1
 1129              		.cfi_endproc
 1130              	.LFE6:
 1131              		.fnend
 1133              		.align	2
 1134              		.global	log4bytes
 1136              	log4bytes:
 1137              		.fnstart
 1138              	.LFB7:
 106:logger.c      **** 
 107:logger.c      **** void log4bytes(int c){
 1139              		.loc 1 107 0
 1140              		.cfi_startproc
 1141              		@ Function supports interworking.
 1142              		@ args = 0, pretend = 0, frame = 0
 1143              		@ frame_needed = 0, uses_anonymous_args = 0
 1144              	.LVL55:
 1145 0900 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1146              		.save {r3, r4, r5, lr}
 1147              	.LCFI12:
 1148              		.cfi_def_cfa_offset 16
 108:logger.c      **** 	if(c & 0x80000000){ // se for negativo
 1149              		.loc 1 108 0
 1150 0904 004050E2 		subs	r4, r0, #0
 1151              		.cfi_offset 14, -4
 1152              		.cfi_offset 5, -8
 1153              		.cfi_offset 4, -12
 1154              		.cfi_offset 3, -16
 1155 0908 030000AA 		bge	.L84
 109:logger.c      **** 		log_char('-');
 1156              		.loc 1 109 0
 1157 090c 2D00A0E3 		mov	r0, #45
 1158              	.LVL56:
 1159 0910 BAFDFFEB 		bl	log_char
 1160              	.LVL57:
 110:logger.c      **** 		c = ~c;
 111:logger.c      **** 		c += 0x1;
 1161              		.loc 1 111 0
 1162 0914 004064E2 		rsb	r4, r4, #0
 1163              	.LVL58:
 1164 0918 010000EA 		b	.L85
 1165              	.LVL59:
 1166              	.L84:
 112:logger.c      **** 	}else
 113:logger.c      **** 		log_char(' ');
 1167              		.loc 1 113 0
 1168 091c 2000A0E3 		mov	r0, #32
 1169              	.LVL60:
 1170 0920 B6FDFFEB 		bl	log_char
 1171              	.L85:
 114:logger.c      **** 	log_char(ascii[c >> 28]);
 1172              		.loc 1 114 0
 1173 0924 78509FE5 		ldr	r5, .L86
 1174 0928 440ED5E7 		ldrb	r0, [r5, r4, asr #28]	@ zero_extendqisi2
 1175 092c B3FDFFEB 		bl	log_char
 115:logger.c      **** 	log_char(ascii[c >> 24 & 0x0000000f]);
 1176              		.loc 1 115 0
 1177 0930 443CA0E1 		mov	r3, r4, asr #24
 1178 0934 0F3003E2 		and	r3, r3, #15
 1179 0938 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1180 093c AFFDFFEB 		bl	log_char
 116:logger.c      **** 	log_char(ascii[c >> 20 & 0x0000000f]);
 1181              		.loc 1 116 0
 1182 0940 443AA0E1 		mov	r3, r4, asr #20
 1183 0944 0F3003E2 		and	r3, r3, #15
 1184 0948 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1185 094c ABFDFFEB 		bl	log_char
 117:logger.c      **** 	log_char(ascii[c >> 16 & 0x0000000f]);
 1186              		.loc 1 117 0
 1187 0950 4438A0E1 		mov	r3, r4, asr #16
 1188 0954 0F3003E2 		and	r3, r3, #15
 1189 0958 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1190 095c A7FDFFEB 		bl	log_char
 118:logger.c      **** 	log_char(ascii[c >> 12 & 0x0000000f]);
 1191              		.loc 1 118 0
 1192 0960 4436A0E1 		mov	r3, r4, asr #12
 1193 0964 0F3003E2 		and	r3, r3, #15
 1194 0968 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1195 096c A3FDFFEB 		bl	log_char
 119:logger.c      **** 	log_char(ascii[c >> 8 & 0x0000000f]);
 1196              		.loc 1 119 0
 1197 0970 4434A0E1 		mov	r3, r4, asr #8
 1198 0974 0F3003E2 		and	r3, r3, #15
 1199 0978 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1200 097c 9FFDFFEB 		bl	log_char
 120:logger.c      **** 	log_char(ascii[c >> 4 & 0x0000000f]);
 1201              		.loc 1 120 0
 1202 0980 4432A0E1 		mov	r3, r4, asr #4
 1203 0984 0F3003E2 		and	r3, r3, #15
 1204 0988 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1205 098c 9BFDFFEB 		bl	log_char
 121:logger.c      **** 	log_char(ascii[c & 0x0000000f]);
 1206              		.loc 1 121 0
 1207 0990 0F4004E2 		and	r4, r4, #15
 1208              	.LVL61:
 1209 0994 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1210 0998 98FDFFEB 		bl	log_char
 122:logger.c      **** }
 1211              		.loc 1 122 0
 1212 099c 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1213 09a0 1EFF2FE1 		bx	lr
 1214              	.L87:
 1215              		.align	2
 1216              	.L86:
 1217 09a4 00000000 		.word	.LANCHOR1
 1218              		.cfi_endproc
 1219              	.LFE7:
 1220              		.fnend
 1222              		.align	2
 1223              		.global	i2c_init
 1225              	i2c_init:
 1226              		.fnstart
 1227              	.LFB15:
  26:i2c.c         **** void i2c_init(void){
 1228              		.loc 2 26 0
 1229              		.cfi_startproc
 1230              		@ Function supports interworking.
 1231              		@ args = 0, pretend = 0, frame = 0
 1232              		@ frame_needed = 0, uses_anonymous_args = 0
 1233              		@ link register save eliminated.
  31:i2c.c         **** 	PINSEL1 |= 0x1 << 2; // SCL1
 1234              		.loc 2 31 0
 1235 09a8 58309FE5 		ldr	r3, .L89
 1236 09ac 042093E5 		ldr	r2, [r3, #4]
 1237 09b0 042082E3 		orr	r2, r2, #4
 1238 09b4 042083E5 		str	r2, [r3, #4]
  32:i2c.c         **** 	PINSEL1 |= 0x1 << 4; // SDA1
 1239              		.loc 2 32 0
 1240 09b8 042093E5 		ldr	r2, [r3, #4]
 1241 09bc 102082E3 		orr	r2, r2, #16
 1242 09c0 042083E5 		str	r2, [r3, #4]
  34:i2c.c         **** 	I2C1CONCLR = 0x6C; // clear all flags
 1243              		.loc 2 34 0
 1244 09c4 033883E2 		add	r3, r3, #196608
 1245 09c8 6C20A0E3 		mov	r2, #108
 1246 09cc 1820C3E5 		strb	r2, [r3, #24]
  35:i2c.c         **** 	I2C1CONSET |= 0x1 << 6; // enable i2c1
 1247              		.loc 2 35 0
 1248 09d0 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1249 09d4 FF2002E2 		and	r2, r2, #255
 1250 09d8 402082E3 		orr	r2, r2, #64
 1251 09dc 0020C3E5 		strb	r2, [r3, #0]
  36:i2c.c         **** 	I2C1SCLH = 19; // Set the bit rate:
 1252              		.loc 2 36 0
 1253 09e0 1320A0E3 		mov	r2, #19
 1254 09e4 B021C3E1 		strh	r2, [r3, #16]	@ movhi
  37:i2c.c         **** 	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
 1255              		.loc 2 37 0
 1256 09e8 B421C3E1 		strh	r2, [r3, #20]	@ movhi
  40:i2c.c         **** 	VICVectCntl0 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
 1257              		.loc 2 40 0
 1258 09ec 0030E0E3 		mvn	r3, #0
 1259 09f0 3320A0E3 		mov	r2, #51
 1260 09f4 FF2D03E5 		str	r2, [r3, #-3583]
  41:i2c.c         **** 	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
 1261              		.loc 2 41 0
 1262 09f8 EF2F13E5 		ldr	r2, [r3, #-4079]
 1263 09fc 022782E3 		orr	r2, r2, #524288
 1264 0a00 EF2F03E5 		str	r2, [r3, #-4079]
  48:i2c.c         **** }
 1265              		.loc 2 48 0
 1266 0a04 1EFF2FE1 		bx	lr
 1267              	.L90:
 1268              		.align	2
 1269              	.L89:
 1270 0a08 00C002E0 		.word	-536690688
 1271              		.cfi_endproc
 1272              	.LFE15:
 1273              		.fnend
 1275              		.align	2
 1276              		.global	i2c_read_bytes
 1278              	i2c_read_bytes:
 1279              		.fnstart
 1280              	.LFB17:
  63:i2c.c         **** int i2c_read_bytes(char reg_addr, char length, char* data) {
 1281              		.loc 2 63 0
 1282              		.cfi_startproc
 1283              		@ Function supports interworking.
 1284              		@ args = 0, pretend = 0, frame = 0
 1285              		@ frame_needed = 0, uses_anonymous_args = 0
 1286              		@ link register save eliminated.
 1287              	.LVL62:
  66:i2c.c         **** 	buff_size = length;
 1288              		.loc 2 66 0
 1289 0a0c 48309FE5 		ldr	r3, .L94
 1290 0a10 081083E5 		str	r1, [r3, #8]
  67:i2c.c         **** 	buff_pos = 0;
 1291              		.loc 2 67 0
 1292 0a14 0010A0E3 		mov	r1, #0
 1293              	.LVL63:
 1294 0a18 041083E5 		str	r1, [r3, #4]
  68:i2c.c         **** 	ra_buff = reg_addr;
 1295              		.loc 2 68 0
 1296 0a1c 0000C3E5 		strb	r0, [r3, #0]
  69:i2c.c         **** 	c_buff = data;
 1297              		.loc 2 69 0
 1298 0a20 0C2083E5 		str	r2, [r3, #12]
  71:i2c.c         **** 	busy = 1;
 1299              		.loc 2 71 0
 1300 0a24 0120A0E3 		mov	r2, #1
 1301              	.LVL64:
 1302 0a28 102083E5 		str	r2, [r3, #16]
  74:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_read_bytes_isr;
 1303              		.loc 2 74 0
 1304 0a2c 0030E0E3 		mvn	r3, #0
 1305 0a30 28209FE5 		ldr	r2, .L94+4
 1306 0a34 FF2E03E5 		str	r2, [r3, #-3839]
  77:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 1307              		.loc 2 77 0
 1308 0a38 2020A0E3 		mov	r2, #32
 1309 0a3c 20309FE5 		ldr	r3, .L94+8
 1310 0a40 0020C3E5 		strb	r2, [r3, #0]
  81:i2c.c         **** 	while (busy); // busy wait for read process
 1311              		.loc 2 81 0
 1312 0a44 10209FE5 		ldr	r2, .L94
 1313              	.L92:
  81:i2c.c         **** 	while (busy); // busy wait for read process
 1314              		.loc 2 81 0 is_stmt 0 discriminator 1
 1315 0a48 103092E5 		ldr	r3, [r2, #16]
 1316 0a4c 000053E3 		cmp	r3, #0
 1317 0a50 FCFFFF1A 		bne	.L92
  85:i2c.c         **** }
 1318              		.loc 2 85 0 is_stmt 1
 1319 0a54 0100A0E3 		mov	r0, #1
 1320              	.LVL65:
 1321 0a58 1EFF2FE1 		bx	lr
 1322              	.L95:
 1323              		.align	2
 1324              	.L94:
 1325 0a5c 00000000 		.word	.LANCHOR0
 1326 0a60 00000000 		.word	i2c_read_bytes_isr
 1327 0a64 00C005E0 		.word	-536494080
 1328              		.cfi_endproc
 1329              	.LFE17:
 1330              		.fnend
 1332              		.align	2
 1333              		.global	i2c_read_byte
 1335              	i2c_read_byte:
 1336              		.fnstart
 1337              	.LFB16:
  54:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
 1338              		.loc 2 54 0
 1339              		.cfi_startproc
 1340              		@ Function supports interworking.
 1341              		@ args = 0, pretend = 0, frame = 0
 1342              		@ frame_needed = 0, uses_anonymous_args = 0
 1343              	.LVL66:
 1344 0a68 08402DE9 		stmfd	sp!, {r3, lr}
 1345              		.save {r3, lr}
 1346              	.LCFI13:
 1347              		.cfi_def_cfa_offset 8
 1348 0a6c 0120A0E1 		mov	r2, r1
  57:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
 1349              		.loc 2 57 0
 1350 0a70 0110A0E3 		mov	r1, #1
 1351              	.LVL67:
 1352              		.cfi_offset 14, -4
 1353              		.cfi_offset 3, -8
 1354 0a74 FEFFFFEB 		bl	i2c_read_bytes
 1355              	.LVL68:
  61:i2c.c         **** }
 1356              		.loc 2 61 0
 1357 0a78 0840BDE8 		ldmfd	sp!, {r3, lr}
 1358 0a7c 1EFF2FE1 		bx	lr
 1359              		.cfi_endproc
 1360              	.LFE16:
 1361              		.fnend
 1363              		.align	2
 1364              		.global	i2c_write_byte
 1366              	i2c_write_byte:
 1367              		.fnstart
 1368              	.LFB20:
 195:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 1369              		.loc 2 195 0
 1370              		.cfi_startproc
 1371              		@ Function supports interworking.
 1372              		@ args = 0, pretend = 0, frame = 8
 1373              		@ frame_needed = 0, uses_anonymous_args = 0
 1374              		@ link register save eliminated.
 1375              	.LVL69:
 1376              		.pad #8
 1377 0a80 08D04DE2 		sub	sp, sp, #8
 1378              	.LCFI14:
 1379              		.cfi_def_cfa_offset 8
 1380 0a84 08308DE2 		add	r3, sp, #8
 1381 0a88 011063E5 		strb	r1, [r3, #-1]!
 198:i2c.c         **** 	buff_size = 1;
 1382              		.loc 2 198 0
 1383 0a8c 4C209FE5 		ldr	r2, .L100
 1384 0a90 0110A0E3 		mov	r1, #1
 1385              	.LVL70:
 1386 0a94 081082E5 		str	r1, [r2, #8]
 199:i2c.c         **** 	buff_pos = 0;
 1387              		.loc 2 199 0
 1388 0a98 00C0A0E3 		mov	ip, #0
 1389 0a9c 04C082E5 		str	ip, [r2, #4]
 200:i2c.c         **** 	ra_buff = reg_addr;
 1390              		.loc 2 200 0
 1391 0aa0 0000C2E5 		strb	r0, [r2, #0]
 201:i2c.c         **** 	c_buff = &data;
 1392              		.loc 2 201 0
 1393 0aa4 0C3082E5 		str	r3, [r2, #12]
 203:i2c.c         **** 	busy = 1;
 1394              		.loc 2 203 0
 1395 0aa8 101082E5 		str	r1, [r2, #16]
 206:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_write_byte_isr;
 1396              		.loc 2 206 0
 1397 0aac 0030E0E3 		mvn	r3, #0
 1398 0ab0 2C209FE5 		ldr	r2, .L100+4
 1399 0ab4 FF2E03E5 		str	r2, [r3, #-3839]
 209:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 1400              		.loc 2 209 0
 1401 0ab8 2020A0E3 		mov	r2, #32
 1402 0abc 24309FE5 		ldr	r3, .L100+8
 1403 0ac0 0020C3E5 		strb	r2, [r3, #0]
 211:i2c.c         **** 	while (busy); // busy wait for read process
 1404              		.loc 2 211 0
 1405 0ac4 14209FE5 		ldr	r2, .L100
 1406              	.L98:
 211:i2c.c         **** 	while (busy); // busy wait for read process
 1407              		.loc 2 211 0 is_stmt 0 discriminator 1
 1408 0ac8 103092E5 		ldr	r3, [r2, #16]
 1409 0acc 000053E3 		cmp	r3, #0
 1410 0ad0 FCFFFF1A 		bne	.L98
 215:i2c.c         **** }
 1411              		.loc 2 215 0 is_stmt 1
 1412 0ad4 0100A0E3 		mov	r0, #1
 1413              	.LVL71:
 1414 0ad8 08D08DE2 		add	sp, sp, #8
 1415 0adc 1EFF2FE1 		bx	lr
 1416              	.L101:
 1417              		.align	2
 1418              	.L100:
 1419 0ae0 00000000 		.word	.LANCHOR0
 1420 0ae4 00000000 		.word	i2c_write_byte_isr
 1421 0ae8 00C005E0 		.word	-536494080
 1422              		.cfi_endproc
 1423              	.LFE20:
 1424              		.fnend
 1426              		.align	2
 1427              		.global	i2c_write_bits
 1429              	i2c_write_bits:
 1430              		.fnstart
 1431              	.LFB19:
 175:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 1432              		.loc 2 175 0
 1433              		.cfi_startproc
 1434              		@ Function supports interworking.
 1435              		@ args = 0, pretend = 0, frame = 8
 1436              		@ frame_needed = 0, uses_anonymous_args = 0
 1437              	.LVL72:
 1438 0aec F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1439              		.save {r4, r5, r6, r7, lr}
 1440              	.LCFI15:
 1441              		.cfi_def_cfa_offset 20
 1442              		.pad #12
 1443 0af0 0CD04DE2 		sub	sp, sp, #12
 1444              	.LCFI16:
 1445              		.cfi_def_cfa_offset 32
 1446 0af4 0070A0E1 		mov	r7, r0
 1447              		.cfi_offset 14, -4
 1448              		.cfi_offset 7, -8
 1449              		.cfi_offset 6, -12
 1450              		.cfi_offset 5, -16
 1451              		.cfi_offset 4, -20
 1452 0af8 0150A0E1 		mov	r5, r1
 1453 0afc 0240A0E1 		mov	r4, r2
 1454 0b00 0360A0E1 		mov	r6, r3
 185:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 1455              		.loc 2 185 0
 1456 0b04 07108DE2 		add	r1, sp, #7
 1457              	.LVL73:
 1458 0b08 FEFFFFEB 		bl	i2c_read_byte
 1459              	.LVL74:
 186:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 1460              		.loc 2 186 0
 1461 0b0c 015085E2 		add	r5, r5, #1
 1462 0b10 055064E0 		rsb	r5, r4, r5
 1463 0b14 0030E0E3 		mvn	r3, #0
 1464 0b18 1344E0E1 		mvn	r4, r3, asl r4
 1465 0b1c 1445A0E1 		mov	r4, r4, asl r5
 1466 0b20 FF4004E2 		and	r4, r4, #255
 1467              	.LVL75:
 189:i2c.c         **** 	c &= ~(mask); // zero all important bits in existing byte
 1468              		.loc 2 189 0
 1469 0b24 0710DDE5 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
 1470              	.LVL76:
 1471 0b28 0410C1E1 		bic	r1, r1, r4
 1472              	.LVL77:
 188:i2c.c         **** 	data &= mask; // zero all non-important bits in data
 1473              		.loc 2 188 0
 1474 0b2c 166504E0 		and	r6, r4, r6, asl r5
 1475              	.LVL78:
 190:i2c.c         **** 	c |= data; // combine data with existing byte
 1476              		.loc 2 190 0
 1477 0b30 061081E1 		orr	r1, r1, r6
 1478              	.LVL79:
 1479 0b34 0710CDE5 		strb	r1, [sp, #7]
 192:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 1480              		.loc 2 192 0
 1481 0b38 0700A0E1 		mov	r0, r7
 1482 0b3c FEFFFFEB 		bl	i2c_write_byte
 1483              	.LVL80:
 193:i2c.c         **** }
 1484              		.loc 2 193 0
 1485 0b40 0CD08DE2 		add	sp, sp, #12
 1486 0b44 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1487 0b48 1EFF2FE1 		bx	lr
 1488              		.cfi_endproc
 1489              	.LFE19:
 1490              		.fnend
 1492              		.align	2
 1493              		.global	mpu_set_clock_source
 1495              	mpu_set_clock_source:
 1496              		.fnstart
 1497              	.LFB23:
 1498              		.file 4 "mpu6050.c"
   1:mpu6050.c     **** /*
   2:mpu6050.c     ****  * mpu6050.c
   3:mpu6050.c     ****  *
   4:mpu6050.c     ****  *  Created on: Mar 21, 2013
   5:mpu6050.c     ****  *      Author: telmo
   6:mpu6050.c     ****  *
   7:mpu6050.c     ****  *  This code was based on Jeff Rowberg code for arduino https://github.com/jrowberg/i2cdevlib/tree
   8:mpu6050.c     ****  */
   9:mpu6050.c     **** #include "lpc2103.h"
  10:mpu6050.c     **** #include "i2c.h"
  11:mpu6050.c     **** #include "logger.h"
  12:mpu6050.c     **** #include "mpu6050.h"
  13:mpu6050.c     **** 
  14:mpu6050.c     **** /** Power on and prepare for general usage.
  15:mpu6050.c     **** * This will activate the device and take it out of sleep mode (which must be done
  16:mpu6050.c     **** * after start-up). This function also sets both the accelerometer and the gyroscope
  17:mpu6050.c     **** * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
  18:mpu6050.c     **** * the clock source to use the X Gyro for reference, which is slightly better than
  19:mpu6050.c     **** * the default internal clock source.
  20:mpu6050.c     **** */
  21:mpu6050.c     **** void mpu_init(void) {
  22:mpu6050.c     **** 	log_string_mpu(">> mpu_init\n");
  23:mpu6050.c     **** 
  24:mpu6050.c     ****     // configure clock source
  25:mpu6050.c     **** 	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
  26:mpu6050.c     **** 	// disable temperature sensor
  27:mpu6050.c     **** 	mpu_set_temperature_sensor_enabled(0);
  28:mpu6050.c     **** 	// set scale to
  29:mpu6050.c     **** 	// acc ±2g 16384 LSB/g
  30:mpu6050.c     **** 	// gyro ± 250 °/s 131 LSB/°/s
  31:mpu6050.c     ****     mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
  32:mpu6050.c     ****     mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
  33:mpu6050.c     **** 
  34:mpu6050.c     ****     // divide gyro output rate by 7+1, if DLPF>0 set back to 0 to keep output rate 1kHz
  35:mpu6050.c     ****     mpu_set_gyro_rate(7);
  36:mpu6050.c     ****     // set digital low pass filter cut off frequency (disabled)
  37:mpu6050.c     ****     mpu_set_DLPF_mode(0);
  38:mpu6050.c     **** 
  39:mpu6050.c     ****     // FIFO WAS NOT USED
  40:mpu6050.c     ****     // enable FIFO
  41:mpu6050.c     ****     mpu_set_6axis_FIFO_enabled(1);
  42:mpu6050.c     **** 
  43:mpu6050.c     ****     // DATAREADY INTERRUPT WAS NOT USED
  44:mpu6050.c     ****     // configure interruption
  45:mpu6050.c     ****     //mpu_set_interrupt_mode(0); // active high
  46:mpu6050.c     ****     //mpu_set_interrupt_drive(0); // push/pull
  47:mpu6050.c     ****     //mpu_set_interrupt_latch(0); // 50us pulse on interrupt
  48:mpu6050.c     ****     //mpu_set_FIFO_overflow_interrupt(1); // generate interrupt on FIFO overflow
  49:mpu6050.c     ****     //mpu_set_data_ready_interrupt(1); // data ready interrupt
  50:mpu6050.c     **** 
  51:mpu6050.c     ****     // clear interrupts
  52:mpu6050.c     **** 	//char source;
  53:mpu6050.c     **** 	//mpu_clear_interrupt(&source);
  54:mpu6050.c     ****     // reset FIFO
  55:mpu6050.c     ****     mpu_reset_FIFO();
  56:mpu6050.c     ****     // enable fifo
  57:mpu6050.c     ****     mpu_set_FIFO_enabled(1);
  58:mpu6050.c     **** 
  59:mpu6050.c     ****     // stop sleeping
  60:mpu6050.c     ****     mpu_set_sleep_enable(0);
  61:mpu6050.c     **** 
  62:mpu6050.c     **** 	log_string_mpu("<< mpu_init\n");
  63:mpu6050.c     **** }
  64:mpu6050.c     **** 
  65:mpu6050.c     **** /** Set clock source setting.
  66:mpu6050.c     **** * An internal 8MHz oscillator, gyroscope based clock, or external sources can
  67:mpu6050.c     **** * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator
  68:mpu6050.c     **** * or an external source is chosen as the clock source, the MPU-60X0 can operate
  69:mpu6050.c     **** * in low power modes with the gyroscopes disabled.
  70:mpu6050.c     **** *
  71:mpu6050.c     **** * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.
  72:mpu6050.c     **** * However, it is highly recommended that the device be configured to use one of
  73:mpu6050.c     **** * the gyroscopes (or an external clock source) as the clock reference for
  74:mpu6050.c     **** * improved stability. The clock source can be selected according to the following table:
  75:mpu6050.c     **** *
  76:mpu6050.c     **** * <pre>
  77:mpu6050.c     **** * CLK_SEL | Clock Source
  78:mpu6050.c     **** * --------+--------------------------------------
  79:mpu6050.c     **** * 0 | Internal oscillator
  80:mpu6050.c     **** * 1 | PLL with X Gyro reference
  81:mpu6050.c     **** * 2 | PLL with Y Gyro reference
  82:mpu6050.c     **** * 3 | PLL with Z Gyro reference
  83:mpu6050.c     **** * 4 | PLL with external 32.768kHz reference
  84:mpu6050.c     **** * 5 | PLL with external 19.2MHz reference
  85:mpu6050.c     **** * 6 | Reserved
  86:mpu6050.c     **** * 7 | Stops the clock and keeps the timing generator in reset
  87:mpu6050.c     **** * </pre>
  88:mpu6050.c     **** *
  89:mpu6050.c     **** * @param source New clock source setting
  90:mpu6050.c     **** * @see getClockSource()
  91:mpu6050.c     **** * @see MPU6050_RA_PWR_MGMT_1
  92:mpu6050.c     **** * @see MPU6050_PWR1_CLKSEL_BIT
  93:mpu6050.c     **** * @see MPU6050_PWR1_CLKSEL_LENGTH
  94:mpu6050.c     **** */
  95:mpu6050.c     **** void mpu_set_clock_source(char source) {
 1499              		.loc 4 95 0
 1500              		.cfi_startproc
 1501              		@ Function supports interworking.
 1502              		@ args = 0, pretend = 0, frame = 0
 1503              		@ frame_needed = 0, uses_anonymous_args = 0
 1504              	.LVL81:
 1505 0b4c 08402DE9 		stmfd	sp!, {r3, lr}
 1506              		.save {r3, lr}
 1507              	.LCFI17:
 1508              		.cfi_def_cfa_offset 8
 1509 0b50 0030A0E1 		mov	r3, r0
 1510              		.cfi_offset 14, -4
 1511              		.cfi_offset 3, -8
  96:mpu6050.c     ****     i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, sour
 1512              		.loc 4 96 0
 1513 0b54 6B00A0E3 		mov	r0, #107
 1514              	.LVL82:
 1515 0b58 0210A0E3 		mov	r1, #2
 1516 0b5c 0320A0E3 		mov	r2, #3
 1517 0b60 FEFFFFEB 		bl	i2c_write_bits
  97:mpu6050.c     **** }
 1518              		.loc 4 97 0
 1519 0b64 0840BDE8 		ldmfd	sp!, {r3, lr}
 1520 0b68 1EFF2FE1 		bx	lr
 1521              		.cfi_endproc
 1522              	.LFE23:
 1523              		.fnend
 1525              		.align	2
 1526              		.global	mpu_set_full_scale_gyro_range
 1528              	mpu_set_full_scale_gyro_range:
 1529              		.fnstart
 1530              	.LFB24:
  98:mpu6050.c     **** 
  99:mpu6050.c     **** /** Set full-scale gyroscope range.
 100:mpu6050.c     **** * @param range New full-scale gyroscope range value
 101:mpu6050.c     **** * @see getFullScaleRange()
 102:mpu6050.c     **** * @see MPU6050_GYRO_FS_250
 103:mpu6050.c     **** * @see MPU6050_RA_GYRO_CONFIG
 104:mpu6050.c     **** * @see MPU6050_GCONFIG_FS_SEL_BIT
 105:mpu6050.c     **** * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 106:mpu6050.c     **** */
 107:mpu6050.c     **** void mpu_set_full_scale_gyro_range(char range) {
 1531              		.loc 4 107 0
 1532              		.cfi_startproc
 1533              		@ Function supports interworking.
 1534              		@ args = 0, pretend = 0, frame = 0
 1535              		@ frame_needed = 0, uses_anonymous_args = 0
 1536              	.LVL83:
 1537 0b6c 08402DE9 		stmfd	sp!, {r3, lr}
 1538              		.save {r3, lr}
 1539              	.LCFI18:
 1540              		.cfi_def_cfa_offset 8
 1541 0b70 0030A0E1 		mov	r3, r0
 1542              		.cfi_offset 14, -4
 1543              		.cfi_offset 3, -8
 108:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, 
 1544              		.loc 4 108 0
 1545 0b74 1B00A0E3 		mov	r0, #27
 1546              	.LVL84:
 1547 0b78 0410A0E3 		mov	r1, #4
 1548 0b7c 0220A0E3 		mov	r2, #2
 1549 0b80 FEFFFFEB 		bl	i2c_write_bits
 109:mpu6050.c     **** }
 1550              		.loc 4 109 0
 1551 0b84 0840BDE8 		ldmfd	sp!, {r3, lr}
 1552 0b88 1EFF2FE1 		bx	lr
 1553              		.cfi_endproc
 1554              	.LFE24:
 1555              		.fnend
 1557              		.align	2
 1558              		.global	mpu_set_full_scale_accel_range
 1560              	mpu_set_full_scale_accel_range:
 1561              		.fnstart
 1562              	.LFB25:
 110:mpu6050.c     **** 
 111:mpu6050.c     **** /** Set full-scale accelerometer range.
 112:mpu6050.c     **** * @param range New full-scale accelerometer range setting
 113:mpu6050.c     **** * @see getFullScaleAccelRange()
 114:mpu6050.c     **** */
 115:mpu6050.c     **** void mpu_set_full_scale_accel_range(char range) {
 1563              		.loc 4 115 0
 1564              		.cfi_startproc
 1565              		@ Function supports interworking.
 1566              		@ args = 0, pretend = 0, frame = 0
 1567              		@ frame_needed = 0, uses_anonymous_args = 0
 1568              	.LVL85:
 1569 0b8c 08402DE9 		stmfd	sp!, {r3, lr}
 1570              		.save {r3, lr}
 1571              	.LCFI19:
 1572              		.cfi_def_cfa_offset 8
 1573 0b90 0030A0E1 		mov	r3, r0
 1574              		.cfi_offset 14, -4
 1575              		.cfi_offset 3, -8
 116:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGT
 1576              		.loc 4 116 0
 1577 0b94 1C00A0E3 		mov	r0, #28
 1578              	.LVL86:
 1579 0b98 0410A0E3 		mov	r1, #4
 1580 0b9c 0220A0E3 		mov	r2, #2
 1581 0ba0 FEFFFFEB 		bl	i2c_write_bits
 117:mpu6050.c     **** }
 1582              		.loc 4 117 0
 1583 0ba4 0840BDE8 		ldmfd	sp!, {r3, lr}
 1584 0ba8 1EFF2FE1 		bx	lr
 1585              		.cfi_endproc
 1586              	.LFE25:
 1587              		.fnend
 1589              		.align	2
 1590              		.global	mpu_set_sleep_enable
 1592              	mpu_set_sleep_enable:
 1593              		.fnstart
 1594              	.LFB26:
 118:mpu6050.c     **** 
 119:mpu6050.c     **** /** Set sleep mode status.
 120:mpu6050.c     **** * @param enabled New sleep mode enabled status
 121:mpu6050.c     **** * @see getSleepEnabled()
 122:mpu6050.c     **** * @see MPU6050_RA_PWR_MGMT_1
 123:mpu6050.c     **** * @see MPU6050_PWR1_SLEEP_BIT
 124:mpu6050.c     **** */
 125:mpu6050.c     **** void mpu_set_sleep_enable(int enable) {
 1595              		.loc 4 125 0
 1596              		.cfi_startproc
 1597              		@ Function supports interworking.
 1598              		@ args = 0, pretend = 0, frame = 0
 1599              		@ frame_needed = 0, uses_anonymous_args = 0
 1600              	.LVL87:
 1601 0bac 08402DE9 		stmfd	sp!, {r3, lr}
 1602              		.save {r3, lr}
 1603              	.LCFI20:
 1604              		.cfi_def_cfa_offset 8
 126:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, enable);
 1605              		.loc 4 126 0
 1606 0bb0 FF3000E2 		and	r3, r0, #255
 1607              		.cfi_offset 14, -4
 1608              		.cfi_offset 3, -8
 1609 0bb4 6B00A0E3 		mov	r0, #107
 1610              	.LVL88:
 1611 0bb8 0610A0E3 		mov	r1, #6
 1612 0bbc 0120A0E3 		mov	r2, #1
 1613 0bc0 FEFFFFEB 		bl	i2c_write_bits
 127:mpu6050.c     **** }
 1614              		.loc 4 127 0
 1615 0bc4 0840BDE8 		ldmfd	sp!, {r3, lr}
 1616 0bc8 1EFF2FE1 		bx	lr
 1617              		.cfi_endproc
 1618              	.LFE26:
 1619              		.fnend
 1621              		.align	2
 1622              		.global	mpu_set_temperature_sensor_enabled
 1624              	mpu_set_temperature_sensor_enabled:
 1625              		.fnstart
 1626              	.LFB27:
 128:mpu6050.c     **** 
 129:mpu6050.c     **** /**
 130:mpu6050.c     ****  * Set temperature sensor enabled status.
 131:mpu6050.c     ****  * Note: this register stores the *disabled* value, but for consistency with the
 132:mpu6050.c     ****  * rest of the code, the function is named and used with standard true/false
 133:mpu6050.c     ****  * values to indicate whether the sensor is enabled or disabled, respectively.
 134:mpu6050.c     ****  * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 135:mpu6050.c     ****  * bit automatically clears to 0 after the reset has been triggered.
 136:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 137:mpu6050.c     ****  */
 138:mpu6050.c     **** void mpu_set_temperature_sensor_enabled(char enabled) {
 1627              		.loc 4 138 0
 1628              		.cfi_startproc
 1629              		@ Function supports interworking.
 1630              		@ args = 0, pretend = 0, frame = 0
 1631              		@ frame_needed = 0, uses_anonymous_args = 0
 1632              	.LVL89:
 1633 0bcc 08402DE9 		stmfd	sp!, {r3, lr}
 1634              		.save {r3, lr}
 1635              	.LCFI21:
 1636              		.cfi_def_cfa_offset 8
 139:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, 1, 1-enabled);
 1637              		.loc 4 139 0
 1638 0bd0 013060E2 		rsb	r3, r0, #1
 1639              		.cfi_offset 14, -4
 1640              		.cfi_offset 3, -8
 1641 0bd4 FF3003E2 		and	r3, r3, #255
 1642 0bd8 6B00A0E3 		mov	r0, #107
 1643              	.LVL90:
 1644 0bdc 0310A0E3 		mov	r1, #3
 1645 0be0 0120A0E3 		mov	r2, #1
 1646 0be4 FEFFFFEB 		bl	i2c_write_bits
 140:mpu6050.c     **** }
 1647              		.loc 4 140 0
 1648 0be8 0840BDE8 		ldmfd	sp!, {r3, lr}
 1649 0bec 1EFF2FE1 		bx	lr
 1650              		.cfi_endproc
 1651              	.LFE27:
 1652              		.fnend
 1654              		.align	2
 1655              		.global	mpu_set_gyro_rate
 1657              	mpu_set_gyro_rate:
 1658              		.fnstart
 1659              	.LFB28:
 141:mpu6050.c     **** 
 142:mpu6050.c     **** /** Set gyroscope output rate divider.
 143:mpu6050.c     **** * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
 144:mpu6050.c     **** * Motion detection, and Free Fall detection are all based on the Sample Rate.
 145:mpu6050.c     **** * The Sample Rate is generated by dividing the gyroscope output rate by
 146:mpu6050.c     **** * SMPLRT_DIV:
 147:mpu6050.c     **** *
 148:mpu6050.c     **** * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 149:mpu6050.c     **** *
 150:mpu6050.c     **** * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
 151:mpu6050.c     **** * 7), and 1kHz when the DLPF is enabled (see Register 26).
 152:mpu6050.c     **** *
 153:mpu6050.c     **** * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 154:mpu6050.c     **** * Rate greater than 1kHz, the same accelerometer sample may be output to the
 155:mpu6050.c     **** * FIFO, DMP, and sensor registers more than once.
 156:mpu6050.c     **** *
 157:mpu6050.c     **** * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
 158:mpu6050.c     **** * of the MPU-6000/MPU-6050 Product Specification document.
 159:mpu6050.c     **** *
 160:mpu6050.c     **** * @param rate New sample rate divider
 161:mpu6050.c     **** * @see getRate()
 162:mpu6050.c     **** * @see MPU6050_RA_SMPLRT_DIV
 163:mpu6050.c     **** */
 164:mpu6050.c     **** void mpu_set_gyro_rate(char rate) {
 1660              		.loc 4 164 0
 1661              		.cfi_startproc
 1662              		@ Function supports interworking.
 1663              		@ args = 0, pretend = 0, frame = 0
 1664              		@ frame_needed = 0, uses_anonymous_args = 0
 1665              	.LVL91:
 1666 0bf0 08402DE9 		stmfd	sp!, {r3, lr}
 1667              		.save {r3, lr}
 1668              	.LCFI22:
 1669              		.cfi_def_cfa_offset 8
 1670 0bf4 0010A0E1 		mov	r1, r0
 165:mpu6050.c     ****     i2c_write_byte(MPU6050_RA_SMPLRT_DIV, rate);
 1671              		.loc 4 165 0
 1672 0bf8 1900A0E3 		mov	r0, #25
 1673              	.LVL92:
 1674              		.cfi_offset 14, -4
 1675              		.cfi_offset 3, -8
 1676 0bfc FEFFFFEB 		bl	i2c_write_byte
 166:mpu6050.c     **** }
 1677              		.loc 4 166 0
 1678 0c00 0840BDE8 		ldmfd	sp!, {r3, lr}
 1679 0c04 1EFF2FE1 		bx	lr
 1680              		.cfi_endproc
 1681              	.LFE28:
 1682              		.fnend
 1684              		.align	2
 1685              		.global	mpu_set_DLPF_mode
 1687              	mpu_set_DLPF_mode:
 1688              		.fnstart
 1689              	.LFB29:
 167:mpu6050.c     **** 
 168:mpu6050.c     **** /** Get digital low-pass filter configuration.
 169:mpu6050.c     **** * The DLPF_CFG parameter sets the digital low pass filter configuration. It
 170:mpu6050.c     **** * also determines the internal sampling rate used by the device as shown in
 171:mpu6050.c     **** * the table below.
 172:mpu6050.c     **** *
 173:mpu6050.c     **** * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 174:mpu6050.c     **** * Rate greater than 1kHz, the same accelerometer sample may be output to the
 175:mpu6050.c     **** * FIFO, DMP, and sensor registers more than once.
 176:mpu6050.c     **** *
 177:mpu6050.c     **** * <pre>
 178:mpu6050.c     **** * | ACCELEROMETER | GYROSCOPE
 179:mpu6050.c     **** * DLPF_CFG | Bandwidth | Delay | Bandwidth | Delay | Sample Rate
 180:mpu6050.c     **** * ---------+-----------+--------+-----------+--------+-------------
 181:mpu6050.c     **** * 0 | 260Hz | 0ms | 256Hz | 0.98ms | 8kHz
 182:mpu6050.c     **** * 1 | 184Hz | 2.0ms | 188Hz | 1.9ms | 1kHz
 183:mpu6050.c     **** * 2 | 94Hz | 3.0ms | 98Hz | 2.8ms | 1kHz
 184:mpu6050.c     **** * 3 | 44Hz | 4.9ms | 42Hz | 4.8ms | 1kHz
 185:mpu6050.c     **** * 4 | 21Hz | 8.5ms | 20Hz | 8.3ms | 1kHz
 186:mpu6050.c     **** * 5 | 10Hz | 13.8ms | 10Hz | 13.4ms | 1kHz
 187:mpu6050.c     **** * 6 | 5Hz | 19.0ms | 5Hz | 18.6ms | 1kHz
 188:mpu6050.c     **** * 7 | -- Reserved -- | -- Reserved -- | Reserved
 189:mpu6050.c     **** * </pre>
 190:mpu6050.c     **** *
 191:mpu6050.c     **** * @return DLFP configuration
 192:mpu6050.c     **** * @see MPU6050_RA_CONFIG
 193:mpu6050.c     **** * @see MPU6050_CFG_DLPF_CFG_BIT
 194:mpu6050.c     **** * @see MPU6050_CFG_DLPF_CFG_LENGTH
 195:mpu6050.c     **** */
 196:mpu6050.c     **** void mpu_set_DLPF_mode(char mode) {
 1690              		.loc 4 196 0
 1691              		.cfi_startproc
 1692              		@ Function supports interworking.
 1693              		@ args = 0, pretend = 0, frame = 0
 1694              		@ frame_needed = 0, uses_anonymous_args = 0
 1695              	.LVL93:
 1696 0c08 08402DE9 		stmfd	sp!, {r3, lr}
 1697              		.save {r3, lr}
 1698              	.LCFI23:
 1699              		.cfi_def_cfa_offset 8
 1700 0c0c 0030A0E1 		mov	r3, r0
 1701              		.cfi_offset 14, -4
 1702              		.cfi_offset 3, -8
 197:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
 1703              		.loc 4 197 0
 1704 0c10 1A00A0E3 		mov	r0, #26
 1705              	.LVL94:
 1706 0c14 0210A0E3 		mov	r1, #2
 1707 0c18 0320A0E3 		mov	r2, #3
 1708 0c1c FEFFFFEB 		bl	i2c_write_bits
 198:mpu6050.c     **** }
 1709              		.loc 4 198 0
 1710 0c20 0840BDE8 		ldmfd	sp!, {r3, lr}
 1711 0c24 1EFF2FE1 		bx	lr
 1712              		.cfi_endproc
 1713              	.LFE29:
 1714              		.fnend
 1716              		.align	2
 1717              		.global	mpu_set_6axis_FIFO_enabled
 1719              	mpu_set_6axis_FIFO_enabled:
 1720              		.fnstart
 1721              	.LFB30:
 199:mpu6050.c     **** 
 200:mpu6050.c     **** /**
 201:mpu6050.c     ****  * Configure FIFO to store data from accelerometer temp and gyro
 202:mpu6050.c     ****  * @param enabled 0 disabled; 1 enabled
 203:mpu6050.c     ****  */
 204:mpu6050.c     **** void mpu_set_6axis_FIFO_enabled(char enabled) {
 1722              		.loc 4 204 0
 1723              		.cfi_startproc
 1724              		@ Function supports interworking.
 1725              		@ args = 0, pretend = 0, frame = 0
 1726              		@ frame_needed = 0, uses_anonymous_args = 0
 1727              	.LVL95:
 1728 0c28 08402DE9 		stmfd	sp!, {r3, lr}
 1729              		.save {r3, lr}
 1730              	.LCFI24:
 1731              		.cfi_def_cfa_offset 8
 205:mpu6050.c     **** 	i2c_write_byte(MPU6050_RA_FIFO_EN, 0x78);
 1732              		.loc 4 205 0
 1733 0c2c 2300A0E3 		mov	r0, #35
 1734              	.LVL96:
 1735 0c30 7810A0E3 		mov	r1, #120
 1736              		.cfi_offset 14, -4
 1737              		.cfi_offset 3, -8
 1738 0c34 FEFFFFEB 		bl	i2c_write_byte
 206:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, 1, enabled);
 207:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, 1, 0);
 208:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, 1, enabled);
 209:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, 1, enabled);
 210:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, 1, enabled);
 211:mpu6050.c     **** }
 1739              		.loc 4 211 0
 1740 0c38 0840BDE8 		ldmfd	sp!, {r3, lr}
 1741 0c3c 1EFF2FE1 		bx	lr
 1742              		.cfi_endproc
 1743              	.LFE30:
 1744              		.fnend
 1746              		.align	2
 1747              		.global	mpu_set_interrupt_mode
 1749              	mpu_set_interrupt_mode:
 1750              		.fnstart
 1751              	.LFB31:
 212:mpu6050.c     **** 
 213:mpu6050.c     **** /**
 214:mpu6050.c     ****  * Configure interruption mode
 215:mpu6050.c     ****  * @param mode 0 active high; 1 active low
 216:mpu6050.c     ****  */
 217:mpu6050.c     **** void mpu_set_interrupt_mode(char mode) {
 1752              		.loc 4 217 0
 1753              		.cfi_startproc
 1754              		@ Function supports interworking.
 1755              		@ args = 0, pretend = 0, frame = 0
 1756              		@ frame_needed = 0, uses_anonymous_args = 0
 1757              	.LVL97:
 1758 0c40 08402DE9 		stmfd	sp!, {r3, lr}
 1759              		.save {r3, lr}
 1760              	.LCFI25:
 1761              		.cfi_def_cfa_offset 8
 1762 0c44 0030A0E1 		mov	r3, r0
 1763              		.cfi_offset 14, -4
 1764              		.cfi_offset 3, -8
 218:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, 1, mode);
 1765              		.loc 4 218 0
 1766 0c48 3700A0E3 		mov	r0, #55
 1767              	.LVL98:
 1768 0c4c 0710A0E3 		mov	r1, #7
 1769 0c50 0120A0E3 		mov	r2, #1
 1770 0c54 FEFFFFEB 		bl	i2c_write_bits
 219:mpu6050.c     **** }
 1771              		.loc 4 219 0
 1772 0c58 0840BDE8 		ldmfd	sp!, {r3, lr}
 1773 0c5c 1EFF2FE1 		bx	lr
 1774              		.cfi_endproc
 1775              	.LFE31:
 1776              		.fnend
 1778              		.align	2
 1779              		.global	mpu_set_interrupt_drive
 1781              	mpu_set_interrupt_drive:
 1782              		.fnstart
 1783              	.LFB32:
 220:mpu6050.c     **** 
 221:mpu6050.c     **** /**
 222:mpu6050.c     ****  * Set interrupt drive mode
 223:mpu6050.c     ****  * @param drive 0 push/pull; 1 open-drain
 224:mpu6050.c     ****  */
 225:mpu6050.c     **** void mpu_set_interrupt_drive(char drive) {
 1784              		.loc 4 225 0
 1785              		.cfi_startproc
 1786              		@ Function supports interworking.
 1787              		@ args = 0, pretend = 0, frame = 0
 1788              		@ frame_needed = 0, uses_anonymous_args = 0
 1789              	.LVL99:
 1790 0c60 08402DE9 		stmfd	sp!, {r3, lr}
 1791              		.save {r3, lr}
 1792              	.LCFI26:
 1793              		.cfi_def_cfa_offset 8
 1794 0c64 0030A0E1 		mov	r3, r0
 1795              		.cfi_offset 14, -4
 1796              		.cfi_offset 3, -8
 226:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, 1, drive);
 1797              		.loc 4 226 0
 1798 0c68 3700A0E3 		mov	r0, #55
 1799              	.LVL100:
 1800 0c6c 0610A0E3 		mov	r1, #6
 1801 0c70 0120A0E3 		mov	r2, #1
 1802 0c74 FEFFFFEB 		bl	i2c_write_bits
 227:mpu6050.c     **** }
 1803              		.loc 4 227 0
 1804 0c78 0840BDE8 		ldmfd	sp!, {r3, lr}
 1805 0c7c 1EFF2FE1 		bx	lr
 1806              		.cfi_endproc
 1807              	.LFE32:
 1808              		.fnend
 1810              		.align	2
 1811              		.global	mpu_set_interrupt_latch
 1813              	mpu_set_interrupt_latch:
 1814              		.fnstart
 1815              	.LFB33:
 228:mpu6050.c     **** 
 229:mpu6050.c     **** /**
 230:mpu6050.c     ****  * Set interrupt latch mode
 231:mpu6050.c     ****  * @param latch 0 50us pulse; 1 high until interrupt is cleared
 232:mpu6050.c     ****  */
 233:mpu6050.c     **** void mpu_set_interrupt_latch(char latch) {
 1816              		.loc 4 233 0
 1817              		.cfi_startproc
 1818              		@ Function supports interworking.
 1819              		@ args = 0, pretend = 0, frame = 0
 1820              		@ frame_needed = 0, uses_anonymous_args = 0
 1821              	.LVL101:
 1822 0c80 08402DE9 		stmfd	sp!, {r3, lr}
 1823              		.save {r3, lr}
 1824              	.LCFI27:
 1825              		.cfi_def_cfa_offset 8
 1826 0c84 0030A0E1 		mov	r3, r0
 1827              		.cfi_offset 14, -4
 1828              		.cfi_offset 3, -8
 234:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, 1, latch);
 1829              		.loc 4 234 0
 1830 0c88 3700A0E3 		mov	r0, #55
 1831              	.LVL102:
 1832 0c8c 0510A0E3 		mov	r1, #5
 1833 0c90 0120A0E3 		mov	r2, #1
 1834 0c94 FEFFFFEB 		bl	i2c_write_bits
 235:mpu6050.c     **** }
 1835              		.loc 4 235 0
 1836 0c98 0840BDE8 		ldmfd	sp!, {r3, lr}
 1837 0c9c 1EFF2FE1 		bx	lr
 1838              		.cfi_endproc
 1839              	.LFE33:
 1840              		.fnend
 1842              		.align	2
 1843              		.global	mpu_set_FIFO_overflow_interrupt
 1845              	mpu_set_FIFO_overflow_interrupt:
 1846              		.fnstart
 1847              	.LFB34:
 236:mpu6050.c     **** 
 237:mpu6050.c     **** /**
 238:mpu6050.c     ****  * Set FIFO Buffer Overflow interrupt enabled status.
 239:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 240:mpu6050.c     ****  */
 241:mpu6050.c     **** void mpu_set_FIFO_overflow_interrupt(char enabled) {
 1848              		.loc 4 241 0
 1849              		.cfi_startproc
 1850              		@ Function supports interworking.
 1851              		@ args = 0, pretend = 0, frame = 0
 1852              		@ frame_needed = 0, uses_anonymous_args = 0
 1853              	.LVL103:
 1854 0ca0 08402DE9 		stmfd	sp!, {r3, lr}
 1855              		.save {r3, lr}
 1856              	.LCFI28:
 1857              		.cfi_def_cfa_offset 8
 1858 0ca4 0030A0E1 		mov	r3, r0
 1859              		.cfi_offset 14, -4
 1860              		.cfi_offset 3, -8
 242:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, 1, enabled);
 1861              		.loc 4 242 0
 1862 0ca8 3800A0E3 		mov	r0, #56
 1863              	.LVL104:
 1864 0cac 0410A0E3 		mov	r1, #4
 1865 0cb0 0120A0E3 		mov	r2, #1
 1866 0cb4 FEFFFFEB 		bl	i2c_write_bits
 243:mpu6050.c     **** }
 1867              		.loc 4 243 0
 1868 0cb8 0840BDE8 		ldmfd	sp!, {r3, lr}
 1869 0cbc 1EFF2FE1 		bx	lr
 1870              		.cfi_endproc
 1871              	.LFE34:
 1872              		.fnend
 1874              		.align	2
 1875              		.global	mpu_set_data_ready_interrupt
 1877              	mpu_set_data_ready_interrupt:
 1878              		.fnstart
 1879              	.LFB35:
 244:mpu6050.c     **** 
 245:mpu6050.c     **** /**
 246:mpu6050.c     ****  * Set Data Ready interrupt enabled status.
 247:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 248:mpu6050.c     ****  */
 249:mpu6050.c     **** void mpu_set_data_ready_interrupt(char enabled) {
 1880              		.loc 4 249 0
 1881              		.cfi_startproc
 1882              		@ Function supports interworking.
 1883              		@ args = 0, pretend = 0, frame = 0
 1884              		@ frame_needed = 0, uses_anonymous_args = 0
 1885              	.LVL105:
 1886 0cc0 08402DE9 		stmfd	sp!, {r3, lr}
 1887              		.save {r3, lr}
 1888              	.LCFI29:
 1889              		.cfi_def_cfa_offset 8
 1890 0cc4 0030A0E1 		mov	r3, r0
 1891              		.cfi_offset 14, -4
 1892              		.cfi_offset 3, -8
 250:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, 1, enabled);
 1893              		.loc 4 250 0
 1894 0cc8 3800A0E3 		mov	r0, #56
 1895              	.LVL106:
 1896 0ccc 0010A0E3 		mov	r1, #0
 1897 0cd0 0120A0E3 		mov	r2, #1
 1898 0cd4 FEFFFFEB 		bl	i2c_write_bits
 251:mpu6050.c     **** }
 1899              		.loc 4 251 0
 1900 0cd8 0840BDE8 		ldmfd	sp!, {r3, lr}
 1901 0cdc 1EFF2FE1 		bx	lr
 1902              		.cfi_endproc
 1903              	.LFE35:
 1904              		.fnend
 1906              		.align	2
 1907              		.global	mpu_clear_interrupt
 1909              	mpu_clear_interrupt:
 1910              		.fnstart
 1911              	.LFB36:
 252:mpu6050.c     **** 
 253:mpu6050.c     **** /** Get full set of interrupt status bits.
 254:mpu6050.c     **** * These bits clear to 0 after the register has been read. Very useful
 255:mpu6050.c     **** * for getting multiple INT statuses, since each single bit read clears
 256:mpu6050.c     **** * all of them because it has to read the whole byte.
 257:mpu6050.c     **** * @see MPU6050_RA_INT_STATUS
 258:mpu6050.c     **** */
 259:mpu6050.c     **** int mpu_clear_interrupt(char* data) {
 1912              		.loc 4 259 0
 1913              		.cfi_startproc
 1914              		@ Function supports interworking.
 1915              		@ args = 0, pretend = 0, frame = 0
 1916              		@ frame_needed = 0, uses_anonymous_args = 0
 1917              	.LVL107:
 1918 0ce0 08402DE9 		stmfd	sp!, {r3, lr}
 1919              		.save {r3, lr}
 1920              	.LCFI30:
 1921              		.cfi_def_cfa_offset 8
 1922 0ce4 0010A0E1 		mov	r1, r0
 260:mpu6050.c     **** 	return i2c_read_byte(MPU6050_RA_INT_STATUS, data);
 1923              		.loc 4 260 0
 1924 0ce8 3A00A0E3 		mov	r0, #58
 1925              	.LVL108:
 1926              		.cfi_offset 14, -4
 1927              		.cfi_offset 3, -8
 1928 0cec FEFFFFEB 		bl	i2c_read_byte
 1929              	.LVL109:
 261:mpu6050.c     **** }
 1930              		.loc 4 261 0
 1931 0cf0 0840BDE8 		ldmfd	sp!, {r3, lr}
 1932 0cf4 1EFF2FE1 		bx	lr
 1933              		.cfi_endproc
 1934              	.LFE36:
 1935              		.fnend
 1937              		.align	2
 1938              		.global	mpu_set_FIFO_enabled
 1940              	mpu_set_FIFO_enabled:
 1941              		.fnstart
 1942              	.LFB37:
 262:mpu6050.c     **** 
 263:mpu6050.c     **** /** Enable FIFO usage.
 264:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 265:mpu6050.c     ****  */
 266:mpu6050.c     **** void mpu_set_FIFO_enabled(char enabled) {
 1943              		.loc 4 266 0
 1944              		.cfi_startproc
 1945              		@ Function supports interworking.
 1946              		@ args = 0, pretend = 0, frame = 0
 1947              		@ frame_needed = 0, uses_anonymous_args = 0
 1948              	.LVL110:
 1949 0cf8 08402DE9 		stmfd	sp!, {r3, lr}
 1950              		.save {r3, lr}
 1951              	.LCFI31:
 1952              		.cfi_def_cfa_offset 8
 1953 0cfc 0030A0E1 		mov	r3, r0
 1954              		.cfi_offset 14, -4
 1955              		.cfi_offset 3, -8
 267:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, 1, enabled);
 1956              		.loc 4 267 0
 1957 0d00 6A00A0E3 		mov	r0, #106
 1958              	.LVL111:
 1959 0d04 0610A0E3 		mov	r1, #6
 1960 0d08 0120A0E3 		mov	r2, #1
 1961 0d0c FEFFFFEB 		bl	i2c_write_bits
 268:mpu6050.c     **** }
 1962              		.loc 4 268 0
 1963 0d10 0840BDE8 		ldmfd	sp!, {r3, lr}
 1964 0d14 1EFF2FE1 		bx	lr
 1965              		.cfi_endproc
 1966              	.LFE37:
 1967              		.fnend
 1969              		.align	2
 1970              		.global	mpu_reset_FIFO
 1972              	mpu_reset_FIFO:
 1973              		.fnstart
 1974              	.LFB38:
 269:mpu6050.c     **** 
 270:mpu6050.c     **** /**
 271:mpu6050.c     ****  * Reset the FIFO.
 272:mpu6050.c     ****  * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 273:mpu6050.c     ****  * bit automatically clears to 0 after the reset has been triggered.
 274:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 275:mpu6050.c     ****  */
 276:mpu6050.c     **** void mpu_reset_FIFO(void) {
 1975              		.loc 4 276 0
 1976              		.cfi_startproc
 1977              		@ Function supports interworking.
 1978              		@ args = 0, pretend = 0, frame = 0
 1979              		@ frame_needed = 0, uses_anonymous_args = 0
 1980 0d18 08402DE9 		stmfd	sp!, {r3, lr}
 1981              		.save {r3, lr}
 1982              	.LCFI32:
 1983              		.cfi_def_cfa_offset 8
 277:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);
 1984              		.loc 4 277 0
 1985 0d1c 6A00A0E3 		mov	r0, #106
 1986 0d20 0210A0E3 		mov	r1, #2
 1987 0d24 0120A0E3 		mov	r2, #1
 1988 0d28 0230A0E1 		mov	r3, r2
 1989              		.cfi_offset 14, -4
 1990              		.cfi_offset 3, -8
 1991 0d2c FEFFFFEB 		bl	i2c_write_bits
 278:mpu6050.c     **** }
 1992              		.loc 4 278 0
 1993 0d30 0840BDE8 		ldmfd	sp!, {r3, lr}
 1994 0d34 1EFF2FE1 		bx	lr
 1995              		.cfi_endproc
 1996              	.LFE38:
 1997              		.fnend
 1999              		.align	2
 2000              		.global	mpu_init
 2002              	mpu_init:
 2003              		.fnstart
 2004              	.LFB22:
  21:mpu6050.c     **** void mpu_init(void) {
 2005              		.loc 4 21 0
 2006              		.cfi_startproc
 2007              		@ Function supports interworking.
 2008              		@ args = 0, pretend = 0, frame = 0
 2009              		@ frame_needed = 0, uses_anonymous_args = 0
 2010 0d38 08402DE9 		stmfd	sp!, {r3, lr}
 2011              		.save {r3, lr}
 2012              	.LCFI33:
 2013              		.cfi_def_cfa_offset 8
  25:mpu6050.c     **** 	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
 2014              		.loc 4 25 0
 2015 0d3c 0100A0E3 		mov	r0, #1
 2016              		.cfi_offset 14, -4
 2017              		.cfi_offset 3, -8
 2018 0d40 FEFFFFEB 		bl	mpu_set_clock_source
  27:mpu6050.c     **** 	mpu_set_temperature_sensor_enabled(0);
 2019              		.loc 4 27 0
 2020 0d44 0000A0E3 		mov	r0, #0
 2021 0d48 FEFFFFEB 		bl	mpu_set_temperature_sensor_enabled
  31:mpu6050.c     ****     mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
 2022              		.loc 4 31 0
 2023 0d4c 0000A0E3 		mov	r0, #0
 2024 0d50 FEFFFFEB 		bl	mpu_set_full_scale_gyro_range
  32:mpu6050.c     ****     mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
 2025              		.loc 4 32 0
 2026 0d54 0000A0E3 		mov	r0, #0
 2027 0d58 FEFFFFEB 		bl	mpu_set_full_scale_accel_range
  35:mpu6050.c     ****     mpu_set_gyro_rate(7);
 2028              		.loc 4 35 0
 2029 0d5c 0700A0E3 		mov	r0, #7
 2030 0d60 FEFFFFEB 		bl	mpu_set_gyro_rate
  37:mpu6050.c     ****     mpu_set_DLPF_mode(0);
 2031              		.loc 4 37 0
 2032 0d64 0000A0E3 		mov	r0, #0
 2033 0d68 FEFFFFEB 		bl	mpu_set_DLPF_mode
  41:mpu6050.c     ****     mpu_set_6axis_FIFO_enabled(1);
 2034              		.loc 4 41 0
 2035 0d6c 0100A0E3 		mov	r0, #1
 2036 0d70 FEFFFFEB 		bl	mpu_set_6axis_FIFO_enabled
  55:mpu6050.c     ****     mpu_reset_FIFO();
 2037              		.loc 4 55 0
 2038 0d74 FEFFFFEB 		bl	mpu_reset_FIFO
  57:mpu6050.c     ****     mpu_set_FIFO_enabled(1);
 2039              		.loc 4 57 0
 2040 0d78 0100A0E3 		mov	r0, #1
 2041 0d7c FEFFFFEB 		bl	mpu_set_FIFO_enabled
  60:mpu6050.c     ****     mpu_set_sleep_enable(0);
 2042              		.loc 4 60 0
 2043 0d80 0000A0E3 		mov	r0, #0
 2044 0d84 FEFFFFEB 		bl	mpu_set_sleep_enable
  63:mpu6050.c     **** }
 2045              		.loc 4 63 0
 2046 0d88 0840BDE8 		ldmfd	sp!, {r3, lr}
 2047 0d8c 1EFF2FE1 		bx	lr
 2048              		.cfi_endproc
 2049              	.LFE22:
 2050              		.fnend
 2052              		.align	2
 2053              		.global	mpu_get_FIFO_size
 2055              	mpu_get_FIFO_size:
 2056              		.fnstart
 2057              	.LFB39:
 279:mpu6050.c     **** 
 280:mpu6050.c     **** 
 281:mpu6050.c     **** /** Get current FIFO buffer size.
 282:mpu6050.c     **** * This value indicates the number of bytes stored in the FIFO buffer. This
 283:mpu6050.c     **** * number is in turn the number of bytes that can be read from the FIFO buffer
 284:mpu6050.c     **** * and it is directly proportional to the number of samples available given the
 285:mpu6050.c     **** * set of sensor data bound to be stored in the FIFO (register 35 and 36).
 286:mpu6050.c     **** */
 287:mpu6050.c     **** void mpu_get_FIFO_size(int* size) {
 2058              		.loc 4 287 0
 2059              		.cfi_startproc
 2060              		@ Function supports interworking.
 2061              		@ args = 0, pretend = 0, frame = 8
 2062              		@ frame_needed = 0, uses_anonymous_args = 0
 2063              	.LVL112:
 2064 0d90 10402DE9 		stmfd	sp!, {r4, lr}
 2065              		.save {r4, lr}
 2066              	.LCFI34:
 2067              		.cfi_def_cfa_offset 8
 2068              		.pad #8
 2069 0d94 08D04DE2 		sub	sp, sp, #8
 2070              	.LCFI35:
 2071              		.cfi_def_cfa_offset 16
 2072 0d98 0040A0E1 		mov	r4, r0
 2073              		.cfi_offset 14, -4
 2074              		.cfi_offset 4, -8
 288:mpu6050.c     **** 	char count[2];
 289:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_FIFO_COUNTH, 2, count);
 2075              		.loc 4 289 0
 2076 0d9c 7200A0E3 		mov	r0, #114
 2077              	.LVL113:
 2078 0da0 0210A0E3 		mov	r1, #2
 2079 0da4 04208DE2 		add	r2, sp, #4
 2080 0da8 FEFFFFEB 		bl	i2c_read_bytes
 290:mpu6050.c     **** 	*size = (((int)count[0]) << 8) | count[1];
 2081              		.loc 4 290 0
 2082 0dac 0420DDE5 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 2083 0db0 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2084 0db4 023483E1 		orr	r3, r3, r2, asl #8
 2085 0db8 003084E5 		str	r3, [r4, #0]
 291:mpu6050.c     **** }
 2086              		.loc 4 291 0
 2087 0dbc 08D08DE2 		add	sp, sp, #8
 2088 0dc0 1040BDE8 		ldmfd	sp!, {r4, lr}
 2089 0dc4 1EFF2FE1 		bx	lr
 2090              		.cfi_endproc
 2091              	.LFE39:
 2092              		.fnend
 2094              		.align	2
 2095              		.global	mpu_get_motion6
 2097              	mpu_get_motion6:
 2098              		.fnstart
 2099              	.LFB40:
 292:mpu6050.c     **** 
 293:mpu6050.c     **** /** Get raw 6-axis motion sensor readings (accel/gyro).
 294:mpu6050.c     **** * Retrieves all currently available motion sensor values.
 295:mpu6050.c     **** * @param ax 16-bit signed integer container for accelerometer X-axis value
 296:mpu6050.c     **** * @param ay 16-bit signed integer container for accelerometer Y-axis value
 297:mpu6050.c     **** * @param az 16-bit signed integer container for accelerometer Z-axis value
 298:mpu6050.c     **** * @param gx 16-bit signed integer container for gyroscope X-axis value
 299:mpu6050.c     **** * @param gy 16-bit signed integer container for gyroscope Y-axis value
 300:mpu6050.c     **** * @param gz 16-bit signed integer container for gyroscope Z-axis value
 301:mpu6050.c     **** *
 302:mpu6050.c     **** * buff:
 303:mpu6050.c     **** * ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l,
 304:mpu6050.c     **** *
 305:mpu6050.c     **** * @see getAcceleration()
 306:mpu6050.c     **** * @see getRotation()
 307:mpu6050.c     **** * @see MPU6050_RA_ACCEL_XOUT_H
 308:mpu6050.c     **** */
 309:mpu6050.c     **** void mpu_get_motion6(char* buff) {
 2100              		.loc 4 309 0
 2101              		.cfi_startproc
 2102              		@ Function supports interworking.
 2103              		@ args = 0, pretend = 0, frame = 16
 2104              		@ frame_needed = 0, uses_anonymous_args = 0
 2105              	.LVL114:
 2106 0dc8 10402DE9 		stmfd	sp!, {r4, lr}
 2107              		.save {r4, lr}
 2108              	.LCFI36:
 2109              		.cfi_def_cfa_offset 8
 2110              		.pad #16
 2111 0dcc 10D04DE2 		sub	sp, sp, #16
 2112              	.LCFI37:
 2113              		.cfi_def_cfa_offset 24
 2114 0dd0 0040A0E1 		mov	r4, r0
 2115              		.cfi_offset 14, -4
 2116              		.cfi_offset 4, -8
 310:mpu6050.c     **** 
 311:mpu6050.c     **** 	log_string_mpu(">> mpu_get_motion6\n");
 312:mpu6050.c     **** 
 313:mpu6050.c     **** 	char c[14];
 314:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_ACCEL_XOUT_H, 14, c);
 2117              		.loc 4 314 0
 2118 0dd4 3B00A0E3 		mov	r0, #59
 2119              	.LVL115:
 2120 0dd8 0E10A0E3 		mov	r1, #14
 2121 0ddc 0D20A0E1 		mov	r2, sp
 2122 0de0 FEFFFFEB 		bl	i2c_read_bytes
 315:mpu6050.c     **** 	*buff = c[0];
 2123              		.loc 4 315 0
 2124 0de4 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 2125 0de8 0030C4E5 		strb	r3, [r4, #0]
 316:mpu6050.c     **** 	*(buff+1) = c[1];
 2126              		.loc 4 316 0
 2127 0dec 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 2128 0df0 0130C4E5 		strb	r3, [r4, #1]
 317:mpu6050.c     **** 	*(buff+2) = c[2];
 2129              		.loc 4 317 0
 2130 0df4 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 2131 0df8 0230C4E5 		strb	r3, [r4, #2]
 318:mpu6050.c     **** 	*(buff+3) = c[3];
 2132              		.loc 4 318 0
 2133 0dfc 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 2134 0e00 0330C4E5 		strb	r3, [r4, #3]
 319:mpu6050.c     **** 	*(buff+4) = c[4];
 2135              		.loc 4 319 0
 2136 0e04 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2137 0e08 0430C4E5 		strb	r3, [r4, #4]
 320:mpu6050.c     **** 	*(buff+5) = c[5];
 2138              		.loc 4 320 0
 2139 0e0c 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2140 0e10 0530C4E5 		strb	r3, [r4, #5]
 321:mpu6050.c     **** 	*(buff+6) = c[8];
 2141              		.loc 4 321 0
 2142 0e14 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 2143 0e18 0630C4E5 		strb	r3, [r4, #6]
 322:mpu6050.c     **** 	*(buff+7) = c[9];
 2144              		.loc 4 322 0
 2145 0e1c 0930DDE5 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 2146 0e20 0730C4E5 		strb	r3, [r4, #7]
 323:mpu6050.c     **** 	*(buff+8) = c[10];
 2147              		.loc 4 323 0
 2148 0e24 0A30DDE5 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 2149 0e28 0830C4E5 		strb	r3, [r4, #8]
 324:mpu6050.c     **** 	*(buff+9) = c[11];
 2150              		.loc 4 324 0
 2151 0e2c 0B30DDE5 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 2152 0e30 0930C4E5 		strb	r3, [r4, #9]
 325:mpu6050.c     **** 	*(buff+10) = c[12];
 2153              		.loc 4 325 0
 2154 0e34 0C30DDE5 		ldrb	r3, [sp, #12]	@ zero_extendqisi2
 2155 0e38 0A30C4E5 		strb	r3, [r4, #10]
 326:mpu6050.c     **** 	*(buff+11) = c[13];
 2156              		.loc 4 326 0
 2157 0e3c 0D30DDE5 		ldrb	r3, [sp, #13]	@ zero_extendqisi2
 2158 0e40 0B30C4E5 		strb	r3, [r4, #11]
 327:mpu6050.c     **** 
 328:mpu6050.c     **** 	log_string_mpu("<< mpu_get_motion6\n");
 329:mpu6050.c     **** }
 2159              		.loc 4 329 0
 2160 0e44 10D08DE2 		add	sp, sp, #16
 2161 0e48 1040BDE8 		ldmfd	sp!, {r4, lr}
 2162 0e4c 1EFF2FE1 		bx	lr
 2163              		.cfi_endproc
 2164              	.LFE40:
 2165              		.fnend
 2167              		.align	2
 2168              		.global	mpu_get_FIFO_motion6
 2170              	mpu_get_FIFO_motion6:
 2171              		.fnstart
 2172              	.LFB41:
 330:mpu6050.c     **** 
 331:mpu6050.c     **** /** Get byte from FIFO buffer.
 332:mpu6050.c     **** * This register is used to read and write data from the FIFO buffer. Data is
 333:mpu6050.c     **** * written to the FIFO in order of register number (from lowest to highest). If
 334:mpu6050.c     **** * all the FIFO enable flags (see below) are enabled and all External Sensor
 335:mpu6050.c     **** * Data registers (Registers 73 to 96) are associated with a Slave device, the
 336:mpu6050.c     **** * contents of registers 59 through 96 will be written in order at the Sample
 337:mpu6050.c     **** * Rate.
 338:mpu6050.c     **** *
 339:mpu6050.c     **** * The contents of the sensor data registers (Registers 59 to 96) are written
 340:mpu6050.c     **** * into the FIFO buffer when their corresponding FIFO enable flags are set to 1
 341:mpu6050.c     **** * in FIFO_EN (Register 35). An additional flag for the sensor data registers
 342:mpu6050.c     **** * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).
 343:mpu6050.c     **** *
 344:mpu6050.c     **** * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is
 345:mpu6050.c     **** * automatically set to 1. This bit is located in INT_STATUS (Register 58).
 346:mpu6050.c     **** * When the FIFO buffer has overflowed, the oldest data will be lost and new
 347:mpu6050.c     **** * data will be written to the FIFO.
 348:mpu6050.c     **** *
 349:mpu6050.c     **** * If the FIFO buffer is empty, reading this register will return the last byte
 350:mpu6050.c     **** * that was previously read from the FIFO until new data is available. The user
 351:mpu6050.c     **** * should check FIFO_COUNT to ensure that the FIFO buffer is not read when
 352:mpu6050.c     **** * empty.
 353:mpu6050.c     **** *
 354:mpu6050.c     **** * buff:
 355:mpu6050.c     **** * ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l,
 356:mpu6050.c     **** *
 357:mpu6050.c     **** */
 358:mpu6050.c     **** void mpu_get_FIFO_motion6(char* buff) {
 2173              		.loc 4 358 0
 2174              		.cfi_startproc
 2175              		@ Function supports interworking.
 2176              		@ args = 0, pretend = 0, frame = 16
 2177              		@ frame_needed = 0, uses_anonymous_args = 0
 2178              	.LVL116:
 2179 0e50 10402DE9 		stmfd	sp!, {r4, lr}
 2180              		.save {r4, lr}
 2181              	.LCFI38:
 2182              		.cfi_def_cfa_offset 8
 2183              		.pad #16
 2184 0e54 10D04DE2 		sub	sp, sp, #16
 2185              	.LCFI39:
 2186              		.cfi_def_cfa_offset 24
 2187 0e58 0040A0E1 		mov	r4, r0
 2188              		.cfi_offset 14, -4
 2189              		.cfi_offset 4, -8
 359:mpu6050.c     **** 
 360:mpu6050.c     **** 	char c[12];
 361:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_FIFO_R_W, 12, c);
 2190              		.loc 4 361 0
 2191 0e5c 7400A0E3 		mov	r0, #116
 2192              	.LVL117:
 2193 0e60 0C10A0E3 		mov	r1, #12
 2194 0e64 04208DE2 		add	r2, sp, #4
 2195 0e68 FEFFFFEB 		bl	i2c_read_bytes
 362:mpu6050.c     **** 
 363:mpu6050.c     **** 	*buff = c[0];
 2196              		.loc 4 363 0
 2197 0e6c 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2198 0e70 0030C4E5 		strb	r3, [r4, #0]
 364:mpu6050.c     **** 	*(buff+1) = c[1];
 2199              		.loc 4 364 0
 2200 0e74 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2201 0e78 0130C4E5 		strb	r3, [r4, #1]
 365:mpu6050.c     **** 	*(buff+2) = c[2];
 2202              		.loc 4 365 0
 2203 0e7c 0630DDE5 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 2204 0e80 0230C4E5 		strb	r3, [r4, #2]
 366:mpu6050.c     **** 	*(buff+3) = c[3];
 2205              		.loc 4 366 0
 2206 0e84 0730DDE5 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2207 0e88 0330C4E5 		strb	r3, [r4, #3]
 367:mpu6050.c     **** 	*(buff+4) = c[4];
 2208              		.loc 4 367 0
 2209 0e8c 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 2210 0e90 0430C4E5 		strb	r3, [r4, #4]
 368:mpu6050.c     **** 	*(buff+5) = c[5];
 2211              		.loc 4 368 0
 2212 0e94 0930DDE5 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 2213 0e98 0530C4E5 		strb	r3, [r4, #5]
 369:mpu6050.c     **** 	*(buff+6) = c[6];
 2214              		.loc 4 369 0
 2215 0e9c 0A30DDE5 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 2216 0ea0 0630C4E5 		strb	r3, [r4, #6]
 370:mpu6050.c     **** 	*(buff+7) = c[7];
 2217              		.loc 4 370 0
 2218 0ea4 0B30DDE5 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 2219 0ea8 0730C4E5 		strb	r3, [r4, #7]
 371:mpu6050.c     **** 	*(buff+8) = c[8];
 2220              		.loc 4 371 0
 2221 0eac 0C30DDE5 		ldrb	r3, [sp, #12]	@ zero_extendqisi2
 2222 0eb0 0830C4E5 		strb	r3, [r4, #8]
 372:mpu6050.c     **** 	*(buff+9) = c[9];
 2223              		.loc 4 372 0
 2224 0eb4 0D30DDE5 		ldrb	r3, [sp, #13]	@ zero_extendqisi2
 2225 0eb8 0930C4E5 		strb	r3, [r4, #9]
 373:mpu6050.c     **** 	*(buff+10) = c[10];
 2226              		.loc 4 373 0
 2227 0ebc 0E30DDE5 		ldrb	r3, [sp, #14]	@ zero_extendqisi2
 2228 0ec0 0A30C4E5 		strb	r3, [r4, #10]
 374:mpu6050.c     **** 	*(buff+11) = c[11];
 2229              		.loc 4 374 0
 2230 0ec4 0F30DDE5 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 2231 0ec8 0B30C4E5 		strb	r3, [r4, #11]
 375:mpu6050.c     **** 
 376:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ax_h);
 377:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ax_l);
 378:mpu6050.c     **** //
 379:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ay_h);
 380:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ay_l);
 381:mpu6050.c     **** //
 382:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, az_h);
 383:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, az_l);
 384:mpu6050.c     **** //
 385:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gx_h);
 386:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gx_l);
 387:mpu6050.c     **** //
 388:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_h);
 389:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_l);
 390:mpu6050.c     **** //
 391:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_h);
 392:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_l);
 393:mpu6050.c     **** }
 2232              		.loc 4 393 0
 2233 0ecc 10D08DE2 		add	sp, sp, #16
 2234 0ed0 1040BDE8 		ldmfd	sp!, {r4, lr}
 2235 0ed4 1EFF2FE1 		bx	lr
 2236              		.cfi_endproc
 2237              	.LFE41:
 2238              		.fnend
 2240              		.align	2
 2241              		.global	main
 2243              	main:
 2244              		.fnstart
 2245              	.LFB42:
 107:bellator_low_level.c **** int main(void){
 2246              		.loc 3 107 0
 2247              		.cfi_startproc
 2248              		@ Function supports interworking.
 2249              		@ args = 0, pretend = 0, frame = 8
 2250              		@ frame_needed = 0, uses_anonymous_args = 0
 2251 0ed8 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2252              		.save {r4, r5, r6, r7, r8, lr}
 2253              	.LCFI40:
 2254              		.cfi_def_cfa_offset 24
 2255              		.pad #8
 2256 0edc 08D04DE2 		sub	sp, sp, #8
 2257              	.LCFI41:
 2258              		.cfi_def_cfa_offset 32
 2259              	.LBB55:
 2260              	.LBB56:
 199:bellator_low_level.c **** 	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 2261              		.loc 3 199 0
 2262 0ee0 CC349FE5 		ldr	r3, .L137
 2263 0ee4 2420A0E3 		mov	r2, #36
 2264 0ee8 8420C3E5 		strb	r2, [r3, #132]
 205:bellator_low_level.c **** 	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 2265              		.loc 3 205 0
 2266 0eec 0120A0E3 		mov	r2, #1
 2267 0ef0 8020C3E5 		strb	r2, [r3, #128]
 206:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 2268              		.loc 3 206 0
 2269 0ef4 5520E0E3 		mvn	r2, #85
 2270 0ef8 8C20C3E5 		strb	r2, [r3, #140]
 207:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 2271              		.loc 3 207 0
 2272 0efc AB2082E2 		add	r2, r2, #171
 2273 0f00 8C20C3E5 		strb	r2, [r3, #140]
 2274              	.L124:
 208:bellator_low_level.c **** 	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 2275              		.loc 3 208 0
 2276 0f04 B828D3E1 		ldrh	r2, [r3, #136]
 2277 0f08 010B12E3 		tst	r2, #1024
 2278 0f0c FCFFFF0A 		beq	.L124
 2279              		.cfi_offset 14, -4
 2280              		.cfi_offset 8, -8
 2281              		.cfi_offset 7, -12
 2282              		.cfi_offset 6, -16
 2283              		.cfi_offset 5, -20
 2284              		.cfi_offset 4, -24
 209:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 2285              		.loc 3 209 0
 2286 0f10 9C349FE5 		ldr	r3, .L137
 2287 0f14 0320A0E3 		mov	r2, #3
 2288 0f18 8020C3E5 		strb	r2, [r3, #128]
 210:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 2289              		.loc 3 210 0
 2290 0f1c 5520E0E3 		mvn	r2, #85
 2291 0f20 8C20C3E5 		strb	r2, [r3, #140]
 211:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 2292              		.loc 3 211 0
 2293 0f24 AB2082E2 		add	r2, r2, #171
 2294 0f28 8C20C3E5 		strb	r2, [r3, #140]
 2295              	.LBE56:
 2296              	.LBE55:
 2297              	.LBB57:
 2298              	.LBB58:
 225:bellator_low_level.c **** 	MAMTIM = 4; // 4 clock fetches
 2299              		.loc 3 225 0
 2300 0f2c 0420A0E3 		mov	r2, #4
 2301 0f30 0420C3E5 		strb	r2, [r3, #4]
 230:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 2302              		.loc 3 230 0
 2303 0f34 0220A0E3 		mov	r2, #2
 2304 0f38 0020C3E5 		strb	r2, [r3, #0]
 2305              	.LBE58:
 2306              	.LBE57:
 2307              	.LBB59:
 2308              	.LBB60:
 240:bellator_low_level.c **** 	APBDIV &= ~0x03;
 2309              		.loc 3 240 0
 2310 0f3c 013C83E2 		add	r3, r3, #256
 2311 0f40 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2312 0f44 FC2002E2 		and	r2, r2, #252
 2313 0f48 0020C3E5 		strb	r2, [r3, #0]
 2314              	.LBE60:
 2315              	.LBE59:
 113:bellator_low_level.c **** 	logger_init(); // uart0
 2316              		.loc 3 113 0
 2317 0f4c FEFFFFEB 		bl	logger_init
 2318              	.LBB61:
 2319              	.LBB62:
 2320              	.LBB63:
 2321              	.LBB64:
 2322              		.file 5 "irq.c"
   1:irq.c         **** /*
   2:irq.c         ****  * irq.c
   3:irq.c         ****  *
   4:irq.c         ****  *  Created on: Jul 15, 2009
   5:irq.c         ****  *      Author: telmo
   6:irq.c         ****  */
   7:irq.c         **** 
   8:irq.c         **** #include "irq.h"
   9:irq.c         **** 
  10:irq.c         **** static inline unsigned asm_get_cpsr(void)
  11:irq.c         **** {
  12:irq.c         ****   unsigned long retval;
  13:irq.c         ****   asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
 2323              		.loc 5 13 0
 2324              	#APP
 2325              	@ 13 "irq.c" 1
 2326 0f50 00300FE1 		 mrs  r3, cpsr
 2327              	@ 0 "" 2
 2328              	.LVL118:
 2329              	.LBE64:
 2330              	.LBE63:
  14:irq.c         ****   return retval;
  15:irq.c         **** }
  16:irq.c         **** 
  17:irq.c         **** static inline void asm_set_cpsr(unsigned val)
  18:irq.c         **** {
  19:irq.c         ****   asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
  20:irq.c         **** }
  21:irq.c         **** 
  22:irq.c         **** static inline unsigned enableIRQ(void)
  23:irq.c         **** {
  24:irq.c         ****   unsigned _cpsr;
  25:irq.c         **** 
  26:irq.c         ****   _cpsr = asm_get_cpsr();
  27:irq.c         ****   asm_set_cpsr(_cpsr & ~IRQ_MASK);
 2331              		.loc 5 27 0
 2332 0f54 8030C3E3 		bic	r3, r3, #128
 2333              	.LVL119:
 2334              	.LBB65:
 2335              	.LBB66:
  19:irq.c         ****   asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
 2336              		.loc 5 19 0
 2337              	#APP
 2338              	@ 19 "irq.c" 1
 2339 0f58 03F029E1 		 msr  cpsr, r3
 2340              	@ 0 "" 2
 2341              	.LBE66:
 2342              	.LBE65:
 2343              	.LBE62:
 2344              	.LBE61:
 2345              	.LBB67:
 2346              	.LBB68:
 2347              	.LBB69:
 2348              	.LBB70:
  13:irq.c         ****   asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
 2349              		.loc 5 13 0
 2350              	#APP
 2351              	@ 13 "irq.c" 1
 2352 0f5c 00300FE1 		 mrs  r3, cpsr
 2353              	@ 0 "" 2
 2354              	.LVL120:
 2355              	.LBE70:
 2356              	.LBE69:
  28:irq.c         ****   return _cpsr;
  29:irq.c         **** }
  30:irq.c         **** 
  31:irq.c         **** static inline unsigned disableIRQ(void)
  32:irq.c         **** {
  33:irq.c         ****   unsigned _cpsr;
  34:irq.c         **** 
  35:irq.c         ****   _cpsr = asm_get_cpsr();
  36:irq.c         ****   asm_set_cpsr(_cpsr | IRQ_MASK);
  37:irq.c         ****   return _cpsr;
  38:irq.c         **** }
  39:irq.c         **** 
  40:irq.c         **** static inline unsigned restoreIRQ(unsigned oldCPSR)
  41:irq.c         **** {
  42:irq.c         ****   unsigned _cpsr;
  43:irq.c         **** 
  44:irq.c         ****   _cpsr = asm_get_cpsr();
  45:irq.c         ****   asm_set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  46:irq.c         ****   return _cpsr;
  47:irq.c         **** }
  48:irq.c         **** 
  49:irq.c         **** static inline unsigned enableFIQ(void)
  50:irq.c         **** {
  51:irq.c         ****   unsigned _cpsr;
  52:irq.c         **** 
  53:irq.c         ****   _cpsr = asm_get_cpsr();
  54:irq.c         ****   asm_set_cpsr(_cpsr & ~FIQ_MASK);
 2357              		.loc 5 54 0
 2358 0f60 4030C3E3 		bic	r3, r3, #64
 2359              	.LVL121:
 2360              	.LBB71:
 2361              	.LBB72:
  19:irq.c         ****   asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
 2362              		.loc 5 19 0
 2363              	#APP
 2364              	@ 19 "irq.c" 1
 2365 0f64 03F029E1 		 msr  cpsr, r3
 2366              	@ 0 "" 2
 2367              	.LBE72:
 2368              	.LBE71:
 2369              	.LBE68:
 2370              	.LBE67:
 2371              	.LBB73:
 2372              	.LBB74:
 257:bellator_low_level.c **** 	PINSEL1 |= 0x1 << 0;  // EINT0
 2373              		.loc 3 257 0
 2374 0f68 48449FE5 		ldr	r4, .L137+4
 2375 0f6c 043094E5 		ldr	r3, [r4, #4]
 2376 0f70 013083E3 		orr	r3, r3, #1
 2377 0f74 043084E5 		str	r3, [r4, #4]
 258:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 2378              		.loc 3 258 0
 2379 0f78 043094E5 		ldr	r3, [r4, #4]
 2380 0f7c 023583E3 		orr	r3, r3, #8388608
 2381 0f80 043084E5 		str	r3, [r4, #4]
 259:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 24; // CAP2.1
 2382              		.loc 3 259 0
 2383 0f84 043094E5 		ldr	r3, [r4, #4]
 2384 0f88 023483E3 		orr	r3, r3, #33554432
 2385 0f8c 043084E5 		str	r3, [r4, #4]
 260:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 26; // CAP2.2
 2386              		.loc 3 260 0
 2387 0f90 043094E5 		ldr	r3, [r4, #4]
 2388 0f94 023383E3 		orr	r3, r3, #134217728
 2389 0f98 043084E5 		str	r3, [r4, #4]
 263:bellator_low_level.c **** 	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
 2390              		.loc 3 263 0
 2391 0f9c 18349FE5 		ldr	r3, .L137+8
 2392 0fa0 4820D3E5 		ldrb	r2, [r3, #72]	@ zero_extendqisi2
 2393 0fa4 FF2002E2 		and	r2, r2, #255
 2394 0fa8 012082E3 		orr	r2, r2, #1
 2395 0fac 4820C3E5 		strb	r2, [r3, #72]
 264:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
 2396              		.loc 3 264 0
 2397 0fb0 4C20D3E5 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 2398 0fb4 FF2002E2 		and	r2, r2, #255
 2399 0fb8 012082E3 		orr	r2, r2, #1
 2400 0fbc 4C20C3E5 		strb	r2, [r3, #76]
 265:bellator_low_level.c **** 	EXTINT |= 0x1 << 0; // reset EINT0
 2401              		.loc 3 265 0
 2402 0fc0 4020D3E5 		ldrb	r2, [r3, #64]	@ zero_extendqisi2
 2403 0fc4 FF2002E2 		and	r2, r2, #255
 2404 0fc8 012082E3 		orr	r2, r2, #1
 2405 0fcc 4020C3E5 		strb	r2, [r3, #64]
 268:bellator_low_level.c **** 	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
 2406              		.loc 3 268 0
 2407 0fd0 E8339FE5 		ldr	r3, .L137+12
 2408 0fd4 B822D3E1 		ldrh	r2, [r3, #40]
 2409 0fd8 052082E3 		orr	r2, r2, #5
 2410 0fdc B822C3E1 		strh	r2, [r3, #40]	@ movhi
 269:bellator_low_level.c **** 	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
 2411              		.loc 3 269 0
 2412 0fe0 B822D3E1 		ldrh	r2, [r3, #40]
 2413 0fe4 282082E3 		orr	r2, r2, #40
 2414 0fe8 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 270:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 2415              		.loc 3 270 0
 2416 0fec B822D3E1 		ldrh	r2, [r3, #40]
 2417 0ff0 052D82E3 		orr	r2, r2, #320
 2418 0ff4 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 271:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 2419              		.loc 3 271 0
 2420 0ff8 0160A0E3 		mov	r6, #1
 2421 0ffc 0460C3E5 		strb	r6, [r3, #4]
 274:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 14;// EINT2 as FIQ
 2422              		.loc 3 274 0
 2423 1000 0050E0E3 		mvn	r5, #0
 2424 1004 F33F15E5 		ldr	r3, [r5, #-4083]
 2425 1008 013983E3 		orr	r3, r3, #16384
 2426 100c F33F05E5 		str	r3, [r5, #-4083]
 275:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
 2427              		.loc 3 275 0
 2428 1010 EF3F15E5 		ldr	r3, [r5, #-4079]
 2429 1014 013983E3 		orr	r3, r3, #16384
 2430 1018 EF3F05E5 		str	r3, [r5, #-4079]
 276:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 26;// Timer 2 as FIQ
 2431              		.loc 3 276 0
 2432 101c F33F15E5 		ldr	r3, [r5, #-4083]
 2433 1020 013383E3 		orr	r3, r3, #67108864
 2434 1024 F33F05E5 		str	r3, [r5, #-4083]
 277:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
 2435              		.loc 3 277 0
 2436 1028 EF3F15E5 		ldr	r3, [r5, #-4079]
 2437 102c 013383E3 		orr	r3, r3, #67108864
 2438 1030 EF3F05E5 		str	r3, [r5, #-4079]
 2439              	.LBE74:
 2440              	.LBE73:
 2441              	.LBB75:
 2442              	.LBB76:
 292:bellator_low_level.c **** 	i2c_init();
 2443              		.loc 3 292 0
 2444 1034 FEFFFFEB 		bl	i2c_init
 295:bellator_low_level.c **** 	mpu_init();
 2445              		.loc 3 295 0
 2446 1038 FEFFFFEB 		bl	mpu_init
 2447              	.LBE76:
 2448              	.LBE75:
 2449              	.LBB77:
 2450              	.LBB78:
 322:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 12; // AD0.0
 2451              		.loc 3 322 0
 2452 103c 043094E5 		ldr	r3, [r4, #4]
 2453 1040 033A83E3 		orr	r3, r3, #12288
 2454 1044 043084E5 		str	r3, [r4, #4]
 323:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 14; // AD0.1
 2455              		.loc 3 323 0
 2456 1048 043094E5 		ldr	r3, [r4, #4]
 2457 104c 033983E3 		orr	r3, r3, #49152
 2458 1050 043084E5 		str	r3, [r4, #4]
 324:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 16; // AD0.2
 2459              		.loc 3 324 0
 2460 1054 043094E5 		ldr	r3, [r4, #4]
 2461 1058 033883E3 		orr	r3, r3, #196608
 2462 105c 043084E5 		str	r3, [r4, #4]
 325:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 20; // AD0.3
 2463              		.loc 3 325 0
 2464 1060 003094E5 		ldr	r3, [r4, #0]
 2465 1064 033683E3 		orr	r3, r3, #3145728
 2466 1068 003084E5 		str	r3, [r4, #0]
 326:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 22; // AD0.4
 2467              		.loc 3 326 0
 2468 106c 003094E5 		ldr	r3, [r4, #0]
 2469 1070 033583E3 		orr	r3, r3, #12582912
 2470 1074 003084E5 		str	r3, [r4, #0]
 329:bellator_low_level.c **** 	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
 2471              		.loc 3 329 0
 2472 1078 44339FE5 		ldr	r3, .L137+16
 2473 107c 002093E5 		ldr	r2, [r3, #0]
 2474 1080 012882E3 		orr	r2, r2, #65536
 2475 1084 002083E5 		str	r2, [r3, #0]
 330:bellator_low_level.c **** 	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
 2476              		.loc 3 330 0
 2477 1088 002093E5 		ldr	r2, [r3, #0]
 2478 108c 032C82E3 		orr	r2, r2, #768
 2479 1090 002083E5 		str	r2, [r3, #0]
 331:bellator_low_level.c **** 	ADCR |= 0x1F; // Read AD0.0 - AD0.4
 2480              		.loc 3 331 0
 2481 1094 002093E5 		ldr	r2, [r3, #0]
 2482 1098 1F2082E3 		orr	r2, r2, #31
 2483 109c 002083E5 		str	r2, [r3, #0]
 332:bellator_low_level.c **** 	ADCR |= 0x01 << 21; // The ADC is operational
 2484              		.loc 3 332 0
 2485 10a0 002093E5 		ldr	r2, [r3, #0]
 2486 10a4 022682E3 		orr	r2, r2, #2097152
 2487 10a8 002083E5 		str	r2, [r3, #0]
 2488              	.LBE78:
 2489              	.LBE77:
 2490              	.LBB79:
 2491              	.LBB80:
 348:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 6;  // MAT0.0
 2492              		.loc 3 348 0
 2493 10ac 003094E5 		ldr	r3, [r4, #0]
 2494 10b0 803083E3 		orr	r3, r3, #128
 2495 10b4 003084E5 		str	r3, [r4, #0]
 349:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 10; // MAT0.1
 2496              		.loc 3 349 0
 2497 10b8 003094E5 		ldr	r3, [r4, #0]
 2498 10bc 023B83E3 		orr	r3, r3, #2048
 2499 10c0 003084E5 		str	r3, [r4, #0]
 350:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 24; // MAT1.0
 2500              		.loc 3 350 0
 2501 10c4 003094E5 		ldr	r3, [r4, #0]
 2502 10c8 023483E3 		orr	r3, r3, #33554432
 2503 10cc 003084E5 		str	r3, [r4, #0]
 351:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 26; // MAT1.1
 2504              		.loc 3 351 0
 2505 10d0 003094E5 		ldr	r3, [r4, #0]
 2506 10d4 023383E3 		orr	r3, r3, #134217728
 2507 10d8 003084E5 		str	r3, [r4, #0]
 354:bellator_low_level.c **** 	T0PR = 293; // 255 levels for T2TC in 5ms
 2508              		.loc 3 354 0
 2509 10dc E4229FE5 		ldr	r2, .L137+20
 2510 10e0 E4129FE5 		ldr	r1, .L137+24
 2511 10e4 0C1082E5 		str	r1, [r2, #12]
 355:bellator_low_level.c **** 	T1PR = 293; // TC increments every PR + 1 PCLKs
 2512              		.loc 3 355 0
 2513 10e8 E0329FE5 		ldr	r3, .L137+28
 2514 10ec 0C1083E5 		str	r1, [r3, #12]
 362:bellator_low_level.c **** 	T0PC = 0; // Prescale = 0
 2515              		.loc 3 362 0
 2516 10f0 0010A0E3 		mov	r1, #0
 2517 10f4 101082E5 		str	r1, [r2, #16]
 363:bellator_low_level.c **** 	T1PC = 0;
 2518              		.loc 3 363 0
 2519 10f8 101083E5 		str	r1, [r3, #16]
 364:bellator_low_level.c **** 	T0TC = 0; // Counter = 0
 2520              		.loc 3 364 0
 2521 10fc 081082E5 		str	r1, [r2, #8]
 365:bellator_low_level.c **** 	T1TC = 0;
 2522              		.loc 3 365 0
 2523 1100 081083E5 		str	r1, [r3, #8]
 367:bellator_low_level.c **** 	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
 2524              		.loc 3 367 0
 2525 1104 B401D2E1 		ldrh	r0, [r2, #20]
 2526 1108 010B80E3 		orr	r0, r0, #1024
 2527 110c B401C2E1 		strh	r0, [r2, #20]	@ movhi
 368:bellator_low_level.c **** 	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
 2528              		.loc 3 368 0
 2529 1110 B401D3E1 		ldrh	r0, [r3, #20]
 2530 1114 010B80E3 		orr	r0, r0, #1024
 2531 1118 B401C3E1 		strh	r0, [r3, #20]	@ movhi
 369:bellator_low_level.c **** 	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
 2532              		.loc 3 369 0
 2533 111c FF00A0E3 		mov	r0, #255
 2534 1120 240082E5 		str	r0, [r2, #36]
 370:bellator_low_level.c **** 	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
 2535              		.loc 3 370 0
 2536 1124 240083E5 		str	r0, [r3, #36]
 372:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
 2537              		.loc 3 372 0
 2538 1128 740092E5 		ldr	r0, [r2, #116]
 2539 112c 060080E1 		orr	r0, r0, r6
 2540 1130 740082E5 		str	r0, [r2, #116]
 373:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
 2541              		.loc 3 373 0
 2542 1134 740092E5 		ldr	r0, [r2, #116]
 2543 1138 020080E3 		orr	r0, r0, #2
 2544 113c 740082E5 		str	r0, [r2, #116]
 374:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
 2545              		.loc 3 374 0
 2546 1140 740093E5 		ldr	r0, [r3, #116]
 2547 1144 060080E1 		orr	r0, r0, r6
 2548 1148 740083E5 		str	r0, [r3, #116]
 375:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
 2549              		.loc 3 375 0
 2550 114c 740093E5 		ldr	r0, [r3, #116]
 2551 1150 020080E3 		orr	r0, r0, #2
 2552 1154 740083E5 		str	r0, [r3, #116]
 377:bellator_low_level.c **** 	T0MR0 = 256; // initially LOW
 2553              		.loc 3 377 0
 2554 1158 010CA0E3 		mov	r0, #256
 2555 115c 180082E5 		str	r0, [r2, #24]
 378:bellator_low_level.c **** 	T0MR1 = 256; // initially LOW
 2556              		.loc 3 378 0
 2557 1160 1C0082E5 		str	r0, [r2, #28]
 379:bellator_low_level.c **** 	T1MR0 = 256; // initially LOW
 2558              		.loc 3 379 0
 2559 1164 180083E5 		str	r0, [r3, #24]
 380:bellator_low_level.c **** 	T1MR1 = 256; // initially LOW
 2560              		.loc 3 380 0
 2561 1168 1C0083E5 		str	r0, [r3, #28]
 382:bellator_low_level.c **** 	T0TCR = 1; // enable T0
 2562              		.loc 3 382 0
 2563 116c 0460C2E5 		strb	r6, [r2, #4]
 383:bellator_low_level.c **** 	T1TCR = 1; // enable T1
 2564              		.loc 3 383 0
 2565 1170 0460C3E5 		strb	r6, [r3, #4]
 2566              	.LBE80:
 2567              	.LBE79:
 2568              	.LBB81:
 2569              	.LBB82:
 407:bellator_low_level.c **** 	PINSEL0 |= 0x05 << 16; // Set the pins function
 2570              		.loc 3 407 0
 2571 1174 003094E5 		ldr	r3, [r4, #0]
 2572 1178 053883E3 		orr	r3, r3, #327680
 2573 117c 003084E5 		str	r3, [r4, #0]
 408:bellator_low_level.c **** 	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 2574              		.loc 3 408 0
 2575 1180 4C329FE5 		ldr	r3, .L137+32
 2576 1184 0720A0E3 		mov	r2, #7
 2577 1188 0820C3E5 		strb	r2, [r3, #8]
 409:bellator_low_level.c **** 	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 2578              		.loc 3 409 0
 2579 118c 7C20E0E3 		mvn	r2, #124
 2580 1190 0C20C3E5 		strb	r2, [r3, #12]
 412:bellator_low_level.c **** 	U1DLL	 = 0x06; // DivisorLatchLow bit
 2581              		.loc 3 412 0
 2582 1194 832082E2 		add	r2, r2, #131
 2583 1198 0020C3E5 		strb	r2, [r3, #0]
 413:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 2584              		.loc 3 413 0
 2585 119c 0410C3E5 		strb	r1, [r3, #4]
 414:bellator_low_level.c **** 	U1FDR	|= 0x05; // DivAddVal
 2586              		.loc 3 414 0
 2587 11a0 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2588 11a4 FF2002E2 		and	r2, r2, #255
 2589 11a8 052082E3 		orr	r2, r2, #5
 2590 11ac 2820C3E5 		strb	r2, [r3, #40]
 415:bellator_low_level.c **** 	U1FDR	|= 0x0E << 4; // MulVal = 14
 2591              		.loc 3 415 0
 2592 11b0 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2593 11b4 E02082E3 		orr	r2, r2, #224
 2594 11b8 2820C3E5 		strb	r2, [r3, #40]
 422:bellator_low_level.c **** 	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 2595              		.loc 3 422 0
 2596 11bc 0320A0E3 		mov	r2, #3
 2597 11c0 0C20C3E5 		strb	r2, [r3, #12]
 424:bellator_low_level.c **** 	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 2598              		.loc 3 424 0
 2599 11c4 0C229FE5 		ldr	r2, .L137+36
 2600 11c8 F72E05E5 		str	r2, [r5, #-3831]
 425:bellator_low_level.c **** 	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 2601              		.loc 3 425 0
 2602 11cc 2720A0E3 		mov	r2, #39
 2603 11d0 F72D05E5 		str	r2, [r5, #-3575]
 426:bellator_low_level.c **** 	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 2604              		.loc 3 426 0
 2605 11d4 EF2F15E5 		ldr	r2, [r5, #-4079]
 2606 11d8 802082E3 		orr	r2, r2, #128
 2607 11dc EF2F05E5 		str	r2, [r5, #-4079]
 428:bellator_low_level.c **** 	cmd_out.i = 0;
 2608              		.loc 3 428 0
 2609 11e0 F4219FE5 		ldr	r2, .L137+40
 2610 11e4 3C1082E5 		str	r1, [r2, #60]
 429:bellator_low_level.c **** 	cmd_in.i = 0;
 2611              		.loc 3 429 0
 2612 11e8 141082E5 		str	r1, [r2, #20]
 431:bellator_low_level.c **** 	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 2613              		.loc 3 431 0
 2614 11ec 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 2615 11f0 FF2002E2 		and	r2, r2, #255
 2616 11f4 0720CDE5 		strb	r2, [sp, #7]
 2617              	.LVL122:
 432:bellator_low_level.c **** 	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
 2618              		.loc 3 432 0
 2619 11f8 0460C3E5 		strb	r6, [r3, #4]
 2620              	.LBE82:
 2621              	.LBE81:
 2622              	.LBB83:
 2623              	.LBB84:
 444:bellator_low_level.c **** 	T3PR = SAMPLE_RATE; // Increment the timer every PCLK
 2624              		.loc 3 444 0
 2625 11fc 193983E2 		add	r3, r3, #409600
 2626 1200 012AA0E3 		mov	r2, #4096	@ movhi
 2627 1204 BC20C3E1 		strh	r2, [r3, #12]	@ movhi
 446:bellator_low_level.c **** 	T3PC = 0;
 2628              		.loc 3 446 0
 2629 1208 B011C3E1 		strh	r1, [r3, #16]	@ movhi
 447:bellator_low_level.c **** 	T3TC = 0; // Counter = 0
 2630              		.loc 3 447 0
 2631 120c B810C3E1 		strh	r1, [r3, #8]	@ movhi
 449:bellator_low_level.c **** 	T3MCR |= (0x1 << 0); // Interrupt on MAT3.0
 2632              		.loc 3 449 0
 2633 1210 B421D3E1 		ldrh	r2, [r3, #20]
 2634 1214 062082E1 		orr	r2, r2, r6
 2635 1218 B421C3E1 		strh	r2, [r3, #20]	@ movhi
 450:bellator_low_level.c **** 	T3MCR |= (0x1 << 1); // Reset the counter on MAT3.0
 2636              		.loc 3 450 0
 2637 121c B421D3E1 		ldrh	r2, [r3, #20]
 2638 1220 022082E3 		orr	r2, r2, #2
 2639 1224 B421C3E1 		strh	r2, [r3, #20]	@ movhi
 453:bellator_low_level.c **** 	T3MR0 = 15000; // MAT3.0 every 15000/(SAMPLE_RATE + 1) counts (1ms/(SAMPLE_RATE + 1))
 2640              		.loc 3 453 0
 2641 1228 B0219FE5 		ldr	r2, .L137+44
 2642 122c B821C3E1 		strh	r2, [r3, #24]	@ movhi
 459:bellator_low_level.c **** 	VICVectAddr1 = (unsigned int) &sample; //Setting the interrupt handler location
 2643              		.loc 3 459 0
 2644 1230 AC219FE5 		ldr	r2, .L137+48
 2645 1234 FB2E05E5 		str	r2, [r5, #-3835]
 460:bellator_low_level.c **** 	VICVectCntl1 = 0x3B; //Vectored Interrupt slot enabled and with source #27 (TIMER3)
 2646              		.loc 3 460 0
 2647 1238 3B20A0E3 		mov	r2, #59
 2648 123c FB2D05E5 		str	r2, [r5, #-3579]
 461:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 27; //source #27 enabled as FIQ or IRQ
 2649              		.loc 3 461 0
 2650 1240 EF2F15E5 		ldr	r2, [r5, #-4079]
 2651 1244 022382E3 		orr	r2, r2, #134217728
 2652 1248 EF2F05E5 		str	r2, [r5, #-4079]
 463:bellator_low_level.c **** 	T3TCR = 1; // enable T3
 2653              		.loc 3 463 0
 2654 124c 0460C3E5 		strb	r6, [r3, #4]
 2655              	.LBE84:
 2656              	.LBE83:
 126:bellator_low_level.c **** 	VICDefVectAddr = (unsigned int) &error;
 2657              		.loc 3 126 0
 2658 1250 90319FE5 		ldr	r3, .L137+52
 2659 1254 CB3F05E5 		str	r3, [r5, #-4043]
 132:bellator_low_level.c **** 		if (send_data) {
 2660              		.loc 3 132 0
 2661 1258 7C319FE5 		ldr	r3, .L137+40
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 2662              		.loc 3 134 0
 2663 125c 88619FE5 		ldr	r6, .L137+56
 2664              	.LBB85:
 107:bellator_low_level.c **** int main(void){
 2665              		.loc 3 107 0
 2666 1260 587083E2 		add	r7, r3, #88
 2667              	.LBB87:
 2668              	.LBB88:
 2669              	.LBB89:
 2670              	.LBB90:
 723:bellator_low_level.c **** 	}
 724:bellator_low_level.c **** }
 725:bellator_low_level.c **** 
 726:bellator_low_level.c **** /**
 727:bellator_low_level.c ****  *
 728:bellator_low_level.c ****  */
 729:bellator_low_level.c **** static inline void protocol_out_cmd(){
 730:bellator_low_level.c **** 	for (unsigned short i = 0; i < cmd_out.i; i++)
 731:bellator_low_level.c **** 		protocol_out_char(cmd_out.buff[i]);
 732:bellator_low_level.c **** }
 733:bellator_low_level.c **** 
 734:bellator_low_level.c **** /**
 735:bellator_low_level.c ****  *
 736:bellator_low_level.c ****  */
 737:bellator_low_level.c **** static inline void protocol_out_char(char c){
 738:bellator_low_level.c **** 	U1THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
 2671              		.loc 3 738 0
 2672 1264 68519FE5 		ldr	r5, .L137+32
 2673              	.L134:
 2674              	.LBE90:
 2675              	.LBE89:
 2676              	.LBE88:
 2677              	.LBE87:
 2678              	.LBE85:
 132:bellator_low_level.c **** 		if (send_data) {
 2679              		.loc 3 132 0
 2680 1268 3820D3E5 		ldrb	r2, [r3, #56]	@ zero_extendqisi2
 2681 126c 000052E3 		cmp	r2, #0
 2682 1270 FCFFFF0A 		beq	.L134
 2683 1274 440000EA 		b	.L136
 2684              	.L129:
 2685              	.LBB94:
 136:bellator_low_level.c **** 				data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 2686              		.loc 3 136 0
 2687 1278 B026D3E1 		ldrh	r2, [r3, #96]
 2688 127c 012082E2 		add	r2, r2, #1
 2689 1280 0228A0E1 		mov	r2, r2, asl #16
 2690 1284 2228A0E1 		mov	r2, r2, lsr #16
 2691 1288 B026C3E1 		strh	r2, [r3, #96]	@ movhi
 2692 128c B026D3E1 		ldrh	r2, [r3, #96]
 2693 1290 FF2002E2 		and	r2, r2, #255
 2694 1294 B026C3E1 		strh	r2, [r3, #96]	@ movhi
 139:bellator_low_level.c **** 				data = &(sensors_data_buff[data_out_pos]);
 2695              		.loc 3 139 0
 2696 1298 B016D3E1 		ldrh	r1, [r3, #96]
 2697              	.LVL123:
 142:bellator_low_level.c **** 				cmd_out.buff[0] = (data->encoder_left >> 0x8) & 0xFF;
 2698              		.loc 3 142 0
 2699 129c 811081E0 		add	r1, r1, r1, asl #1
 2700              	.LVL124:
 2701 12a0 811183E0 		add	r1, r3, r1, asl #3
 2702 12a4 B426D1E1 		ldrh	r2, [r1, #100]
 2703 12a8 2284A0E1 		mov	r8, r2, lsr #8
 2704 12ac 4080C3E5 		strb	r8, [r3, #64]
 143:bellator_low_level.c **** 				cmd_out.buff[1] = data->encoder_left & 0xFF;
 2705              		.loc 3 143 0
 2706 12b0 4120C3E5 		strb	r2, [r3, #65]
 144:bellator_low_level.c **** 				cmd_out.buff[2] = (data->encoder_right >> 0x8) & 0xFF;
 2707              		.loc 3 144 0
 2708 12b4 B626D1E1 		ldrh	r2, [r1, #102]
 2709 12b8 2284A0E1 		mov	r8, r2, lsr #8
 2710 12bc 4280C3E5 		strb	r8, [r3, #66]
 145:bellator_low_level.c **** 				cmd_out.buff[3] = data->encoder_right & 0xFF;
 2711              		.loc 3 145 0
 2712 12c0 4320C3E5 		strb	r2, [r3, #67]
 148:bellator_low_level.c **** 				cmd_out.buff[4] = data->ir_l;
 2713              		.loc 3 148 0
 2714 12c4 6C80D1E5 		ldrb	r8, [r1, #108]	@ zero_extendqisi2
 2715 12c8 4480C3E5 		strb	r8, [r3, #68]
 149:bellator_low_level.c **** 				cmd_out.buff[5] = data->ir_ml;
 2716              		.loc 3 149 0
 2717 12cc 6B80D1E5 		ldrb	r8, [r1, #107]	@ zero_extendqisi2
 2718 12d0 4580C3E5 		strb	r8, [r3, #69]
 150:bellator_low_level.c **** 				cmd_out.buff[6] = data->ir_m;
 2719              		.loc 3 150 0
 2720 12d4 6A80D1E5 		ldrb	r8, [r1, #106]	@ zero_extendqisi2
 2721 12d8 4680C3E5 		strb	r8, [r3, #70]
 151:bellator_low_level.c **** 				cmd_out.buff[7] = data->ir_mr;
 2722              		.loc 3 151 0
 2723 12dc 6980D1E5 		ldrb	r8, [r1, #105]	@ zero_extendqisi2
 2724 12e0 4780C3E5 		strb	r8, [r3, #71]
 152:bellator_low_level.c **** 				cmd_out.buff[8] = data->ir_r;
 2725              		.loc 3 152 0
 2726 12e4 6800D1E5 		ldrb	r0, [r1, #104]	@ zero_extendqisi2
 2727 12e8 4800C3E5 		strb	r0, [r3, #72]
 155:bellator_low_level.c **** 				cmd_out.buff[9] = data->ax_h;
 2728              		.loc 3 155 0
 2729 12ec 6D00D1E5 		ldrb	r0, [r1, #109]	@ zero_extendqisi2
 2730 12f0 4900C3E5 		strb	r0, [r3, #73]
 156:bellator_low_level.c **** 				cmd_out.buff[10] = data->ax_l;
 2731              		.loc 3 156 0
 2732 12f4 6E00D1E5 		ldrb	r0, [r1, #110]	@ zero_extendqisi2
 2733 12f8 4A00C3E5 		strb	r0, [r3, #74]
 157:bellator_low_level.c **** 				cmd_out.buff[11] = data->ay_h;
 2734              		.loc 3 157 0
 2735 12fc 6F00D1E5 		ldrb	r0, [r1, #111]	@ zero_extendqisi2
 2736 1300 4B00C3E5 		strb	r0, [r3, #75]
 158:bellator_low_level.c **** 				cmd_out.buff[12] = data->ay_l;
 2737              		.loc 3 158 0
 2738 1304 7000D1E5 		ldrb	r0, [r1, #112]	@ zero_extendqisi2
 2739 1308 4C00C3E5 		strb	r0, [r3, #76]
 159:bellator_low_level.c **** 				cmd_out.buff[13] = data->az_h;
 2740              		.loc 3 159 0
 2741 130c 7100D1E5 		ldrb	r0, [r1, #113]	@ zero_extendqisi2
 2742 1310 4D00C3E5 		strb	r0, [r3, #77]
 160:bellator_low_level.c **** 				cmd_out.buff[14] = data->az_l;
 2743              		.loc 3 160 0
 2744 1314 7200D1E5 		ldrb	r0, [r1, #114]	@ zero_extendqisi2
 2745 1318 4E00C3E5 		strb	r0, [r3, #78]
 161:bellator_low_level.c **** 				cmd_out.buff[15] = data->gx_h;
 2746              		.loc 3 161 0
 2747 131c 7320D1E5 		ldrb	r2, [r1, #115]	@ zero_extendqisi2
 2748 1320 4F20C3E5 		strb	r2, [r3, #79]
 162:bellator_low_level.c **** 				cmd_out.buff[16] = data->gx_l;
 2749              		.loc 3 162 0
 2750 1324 742081E2 		add	r2, r1, #116
 2751 1328 7410D1E5 		ldrb	r1, [r1, #116]	@ zero_extendqisi2
 2752 132c 5010C3E5 		strb	r1, [r3, #80]
 163:bellator_low_level.c **** 				cmd_out.buff[17] = data->gy_h;
 2753              		.loc 3 163 0
 2754 1330 0110D2E5 		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 2755 1334 5110C3E5 		strb	r1, [r3, #81]
 164:bellator_low_level.c **** 				cmd_out.buff[18] = data->gy_l;
 2756              		.loc 3 164 0
 2757 1338 0210D2E5 		ldrb	r1, [r2, #2]	@ zero_extendqisi2
 2758 133c 5210C3E5 		strb	r1, [r3, #82]
 165:bellator_low_level.c **** 				cmd_out.buff[19] = data->gz_h;
 2759              		.loc 3 165 0
 2760 1340 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
 2761 1344 5310C3E5 		strb	r1, [r3, #83]
 166:bellator_low_level.c **** 				cmd_out.buff[20] = data->gz_l;
 2762              		.loc 3 166 0
 2763 1348 0410D2E5 		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 2764 134c 5410C3E5 		strb	r1, [r3, #84]
 169:bellator_low_level.c **** 				cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 2765              		.loc 3 169 0
 2766 1350 B620D2E1 		ldrh	r2, [r2, #6]
 2767 1354 2214A0E1 		mov	r1, r2, lsr #8
 2768 1358 5510C3E5 		strb	r1, [r3, #85]
 170:bellator_low_level.c **** 				cmd_out.buff[22] = data->timestamp & 0xFF;
 2769              		.loc 3 170 0
 2770 135c 5620C3E5 		strb	r2, [r3, #86]
 173:bellator_low_level.c **** 				cmd_out.buff[23] = END_CMD;
 2771              		.loc 3 173 0
 2772 1360 5740C3E5 		strb	r4, [r3, #87]
 174:bellator_low_level.c **** 				cmd_out.buff[24] = '\n';
 2773              		.loc 3 174 0
 2774 1364 58E0C3E5 		strb	lr, [r3, #88]
 2775              	.LVL125:
 2776 1368 3F1083E2 		add	r1, r3, #63
 2777              	.LVL126:
 2778              	.L128:
 2779              	.LBB86:
 2780              	.LBB93:
 731:bellator_low_level.c **** 		protocol_out_char(cmd_out.buff[i]);
 2781              		.loc 3 731 0
 2782 136c 0120F1E5 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 2783              	.LVL127:
 2784              	.LBB92:
 2785              	.LBB91:
 2786              		.loc 3 738 0
 2787 1370 0020C5E5 		strb	r2, [r5, #0]
 2788              	.LVL128:
 2789              	.L127:
 739:bellator_low_level.c **** 	while(!(U1LSR & 0x40));
 2790              		.loc 3 739 0
 2791 1374 1420D5E5 		ldrb	r2, [r5, #20]	@ zero_extendqisi2
 2792 1378 400012E3 		tst	r2, #64
 2793 137c FCFFFF0A 		beq	.L127
 2794              	.LBE91:
 2795              	.LBE92:
 730:bellator_low_level.c **** 	for (unsigned short i = 0; i < cmd_out.i; i++)
 2796              		.loc 3 730 0
 2797 1380 070051E1 		cmp	r1, r7
 2798 1384 0300000A 		beq	.L135
 2799 1388 F7FFFFEA 		b	.L128
 2800              	.L136:
 2801              	.LBE93:
 2802              	.LBE86:
 2803              	.LBE94:
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 2804              		.loc 3 134 0 discriminator 1
 2805 138c 5CC09FE5 		ldr	ip, .L137+60
 2806              	.LBB95:
 173:bellator_low_level.c **** 				cmd_out.buff[23] = END_CMD;
 2807              		.loc 3 173 0 discriminator 1
 2808 1390 0140E0E3 		mvn	r4, #1
 174:bellator_low_level.c **** 				cmd_out.buff[24] = '\n';
 2809              		.loc 3 174 0 discriminator 1
 2810 1394 0AE0A0E3 		mov	lr, #10
 2811              	.L135:
 2812              	.LBE95:
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 2813              		.loc 3 134 0 discriminator 1
 2814 1398 B016D3E1 		ldrh	r1, [r3, #96]
 2815 139c BC2096E1 		ldrh	r2, [r6, ip]
 2816 13a0 020051E1 		cmp	r1, r2
 2817 13a4 B3FFFF1A 		bne	.L129
 180:bellator_low_level.c **** 			send_data = 0;
 2818              		.loc 3 180 0
 2819 13a8 0020A0E3 		mov	r2, #0
 2820 13ac 3820C3E5 		strb	r2, [r3, #56]
 2821 13b0 ACFFFFEA 		b	.L134
 2822              	.L138:
 2823              		.align	2
 2824              	.L137:
 2825 13b4 00C01FE0 		.word	-534790144
 2826 13b8 00C002E0 		.word	-536690688
 2827 13bc 00C11FE0 		.word	-534789888
 2828 13c0 000007E0 		.word	-536412160
 2829 13c4 004003E0 		.word	-536657920
 2830 13c8 004000E0 		.word	-536854528
 2831 13cc 25010000 		.word	293
 2832 13d0 008000E0 		.word	-536838144
 2833 13d4 000001E0 		.word	-536805376
 2834 13d8 00000000 		.word	protocol_in
 2835 13dc 00000000 		.word	.LANCHOR0
 2836 13e0 983A0000 		.word	15000
 2837 13e4 00000000 		.word	sample
 2838 13e8 00000000 		.word	error
 2839 13ec F81F0000 		.word	.LANCHOR2
 2840 13f0 6CF8FFFF 		.word	-1940
 2841              		.cfi_endproc
 2842              	.LFE42:
 2843              		.fnend
 2845              		.align	2
 2846              		.global	pulse_in
 2848              	pulse_in:
 2849              		.fnstart
 2850              	.LFB53:
 532:bellator_low_level.c **** void pulse_in(void) {
 2851              		.loc 3 532 0
 2852              		.cfi_startproc
 2853              		@ Fast Interrupt Service Routine.
 2854              		@ args = 0, pretend = 0, frame = 0
 2855              		@ frame_needed = 0, uses_anonymous_args = 0
 2856              		@ link register save eliminated.
 2857 13f4 0C002DE9 		stmfd	sp!, {r2, r3}
 2858              		.save {r2, r3}
 2859              	.LCFI42:
 2860              		.cfi_def_cfa_offset 8
 536:bellator_low_level.c **** 	const unsigned short ir = T2IR;
 2861              		.loc 3 536 0
 2862 13f8 1C319FE5 		ldr	r3, .L148
 2863              		.cfi_offset 3, -4
 2864              		.cfi_offset 2, -8
 2865 13fc 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2866 1400 FF2003E2 		and	r2, r3, #255
 539:bellator_low_level.c **** 	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
 2867              		.loc 3 539 0
 2868 1404 100013E3 		tst	r3, #16
 2869 1408 0900000A 		beq	.L140
 541:bellator_low_level.c **** 		forward_l--;
 2870              		.loc 3 541 0
 2871 140c 0C319FE5 		ldr	r3, .L148+4
 2872 1410 902713E5 		ldr	r2, [r3, #-1936]
 2873 1414 012042E2 		sub	r2, r2, #1
 2874 1418 902703E5 		str	r2, [r3, #-1936]
 542:bellator_low_level.c **** 		T2IR |= 0x1 << 4; // reset CAP2.0
 2875              		.loc 3 542 0
 2876 141c F8309FE5 		ldr	r3, .L148
 2877 1420 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2878 1424 FF2002E2 		and	r2, r2, #255
 2879 1428 102082E3 		orr	r2, r2, #16
 2880 142c 0020C3E5 		strb	r2, [r3, #0]
 2881 1430 340000EA 		b	.L141
 2882              	.L140:
 544:bellator_low_level.c **** 	else if (ir & (0x1 << 5)) { //CAP2.1 right encoder
 2883              		.loc 3 544 0
 2884 1434 200012E3 		tst	r2, #32
 2885 1438 1100000A 		beq	.L142
 546:bellator_low_level.c **** 		forward_r++;
 2886              		.loc 3 546 0
 2887 143c DC209FE5 		ldr	r2, .L148+4
 2888 1440 8C3712E5 		ldr	r3, [r2, #-1932]
 2889 1444 013083E2 		add	r3, r3, #1
 2890 1448 8C3702E5 		str	r3, [r2, #-1932]
 547:bellator_low_level.c **** 		if (forward_r > 0)
 2891              		.loc 3 547 0
 2892 144c 000053E3 		cmp	r3, #0
 548:bellator_low_level.c **** 			encoder_count[1]++;
 2893              		.loc 3 548 0
 2894 1450 0230A0C1 		movgt	r3, r2
 2895 1454 842712C5 		ldrgt	r2, [r2, #-1924]
 2896 1458 012082C2 		addgt	r2, r2, #1
 550:bellator_low_level.c **** 			encoder_count[1]--;
 2897              		.loc 3 550 0
 2898 145c BC309FD5 		ldrle	r3, .L148+4
 2899 1460 842713D5 		ldrle	r2, [r3, #-1924]
 2900 1464 012042D2 		suble	r2, r2, #1
 2901 1468 842703E5 		str	r2, [r3, #-1924]
 551:bellator_low_level.c **** 		T2IR |= 0x1 << 5; // reset CAP2.1
 2902              		.loc 3 551 0
 2903 146c A8309FE5 		ldr	r3, .L148
 2904 1470 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2905 1474 FF2002E2 		and	r2, r2, #255
 2906 1478 202082E3 		orr	r2, r2, #32
 2907 147c 0020C3E5 		strb	r2, [r3, #0]
 2908 1480 200000EA 		b	.L141
 2909              	.L142:
 553:bellator_low_level.c **** 	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
 2910              		.loc 3 553 0
 2911 1484 400012E3 		tst	r2, #64
 2912 1488 0900000A 		beq	.L145
 555:bellator_low_level.c **** 		forward_r--;
 2913              		.loc 3 555 0
 2914 148c 8C309FE5 		ldr	r3, .L148+4
 2915 1490 8C2713E5 		ldr	r2, [r3, #-1932]
 2916 1494 012042E2 		sub	r2, r2, #1
 2917 1498 8C2703E5 		str	r2, [r3, #-1932]
 556:bellator_low_level.c **** 		T2IR |= 0x1 << 6; // reset CAP2.2
 2918              		.loc 3 556 0
 2919 149c 78309FE5 		ldr	r3, .L148
 2920 14a0 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2921 14a4 FF2002E2 		and	r2, r2, #255
 2922 14a8 402082E3 		orr	r2, r2, #64
 2923 14ac 0020C3E5 		strb	r2, [r3, #0]
 2924 14b0 140000EA 		b	.L141
 2925              	.L145:
 558:bellator_low_level.c **** 	else if (EXTINT & 0x1 << 0) { // EINT0 left encoder
 2926              		.loc 3 558 0
 2927 14b4 68309FE5 		ldr	r3, .L148+8
 2928 14b8 4030D3E5 		ldrb	r3, [r3, #64]	@ zero_extendqisi2
 2929 14bc 010013E3 		tst	r3, #1
 2930 14c0 1000000A 		beq	.L141
 560:bellator_low_level.c **** 		forward_l++;
 2931              		.loc 3 560 0
 2932 14c4 54209FE5 		ldr	r2, .L148+4
 2933 14c8 903712E5 		ldr	r3, [r2, #-1936]
 2934 14cc 013083E2 		add	r3, r3, #1
 2935 14d0 903702E5 		str	r3, [r2, #-1936]
 561:bellator_low_level.c **** 		if (forward_l > 0)
 2936              		.loc 3 561 0
 2937 14d4 000053E3 		cmp	r3, #0
 562:bellator_low_level.c **** 			encoder_count[0]++;
 2938              		.loc 3 562 0
 2939 14d8 0230A0C1 		movgt	r3, r2
 2940 14dc 882712C5 		ldrgt	r2, [r2, #-1928]
 2941 14e0 012082C2 		addgt	r2, r2, #1
 564:bellator_low_level.c **** 			encoder_count[0]--;
 2942              		.loc 3 564 0
 2943 14e4 34309FD5 		ldrle	r3, .L148+4
 2944 14e8 882713D5 		ldrle	r2, [r3, #-1928]
 2945 14ec 012042D2 		suble	r2, r2, #1
 2946 14f0 882703E5 		str	r2, [r3, #-1928]
 565:bellator_low_level.c **** 		EXTINT |= 0x1 << 0; // reset EINT0
 2947              		.loc 3 565 0
 2948 14f4 28309FE5 		ldr	r3, .L148+8
 2949 14f8 4020D3E5 		ldrb	r2, [r3, #64]	@ zero_extendqisi2
 2950 14fc FF2002E2 		and	r2, r2, #255
 2951 1500 012082E3 		orr	r2, r2, #1
 2952 1504 4020C3E5 		strb	r2, [r3, #64]
 2953              	.L141:
 570:bellator_low_level.c **** 	VICVectAddr = 0;
 2954              		.loc 3 570 0
 2955 1508 0020A0E3 		mov	r2, #0
 2956 150c 0030E0E3 		mvn	r3, #0
 2957 1510 CF2F03E5 		str	r2, [r3, #-4047]
 571:bellator_low_level.c **** }
 2958              		.loc 3 571 0
 2959 1514 0C00BDE8 		ldmfd	sp!, {r2, r3}
 2960 1518 04F05EE2 		subs	pc, lr, #4
 2961              	.L149:
 2962              		.align	2
 2963              	.L148:
 2964 151c 000007E0 		.word	-536412160
 2965 1520 F81F0000 		.word	.LANCHOR2
 2966 1524 00C11FE0 		.word	-534789888
 2967              		.cfi_endproc
 2968              	.LFE53:
 2969              		.fnend
 2971              		.align	2
 2972              		.global	get_ir_sensor_data
 2974              	get_ir_sensor_data:
 2975              		.fnstart
 2976              	.LFB56:
 652:bellator_low_level.c **** void get_ir_sensor_data(char * buff) {
 2977              		.loc 3 652 0
 2978              		.cfi_startproc
 2979              		@ Function supports interworking.
 2980              		@ args = 0, pretend = 0, frame = 0
 2981              		@ frame_needed = 0, uses_anonymous_args = 0
 2982              		@ link register save eliminated.
 2983              	.LVL129:
 656:bellator_low_level.c **** 	while(ADDR0 & ((0x1 << 31) == 0));
 2984              		.loc 3 656 0
 2985 1528 A0309FE5 		ldr	r3, .L151
 2986 152c 102093E5 		ldr	r2, [r3, #16]
 657:bellator_low_level.c **** 	val = (ADDR0 >> 6) & 0x3FF;
 2987              		.loc 3 657 0
 2988 1530 102093E5 		ldr	r2, [r3, #16]
 658:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 2989              		.loc 3 658 0
 2990 1534 2224A0E1 		mov	r2, r2, lsr #8
 2991              	.LVL130:
 659:bellator_low_level.c **** 	val += (val == 0);
 2992              		.loc 3 659 0
 2993 1538 FF2012E2 		ands	r2, r2, #255
 2994              	.LVL131:
 2995 153c 0010A013 		movne	r1, #0
 2996 1540 0110A003 		moveq	r1, #1
 2997              	.LVL132:
 2998 1544 022081E0 		add	r2, r1, r2
 2999              	.LVL133:
 660:bellator_low_level.c **** 	*buff = (char) val;
 3000              		.loc 3 660 0
 3001 1548 0020C0E5 		strb	r2, [r0, #0]
 662:bellator_low_level.c **** 	while(ADDR1 & ((0x1 << 31) == 0));
 3002              		.loc 3 662 0
 3003 154c 142093E5 		ldr	r2, [r3, #20]
 663:bellator_low_level.c **** 	val = (ADDR1 >> 6) & 0x3FF;
 3004              		.loc 3 663 0
 3005 1550 142093E5 		ldr	r2, [r3, #20]
 664:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3006              		.loc 3 664 0
 3007 1554 2224A0E1 		mov	r2, r2, lsr #8
 3008              	.LVL134:
 665:bellator_low_level.c **** 	val += (val == 0);
 3009              		.loc 3 665 0
 3010 1558 FF2012E2 		ands	r2, r2, #255
 3011              	.LVL135:
 3012 155c 0010A013 		movne	r1, #0
 3013 1560 0110A003 		moveq	r1, #1
 3014              	.LVL136:
 3015 1564 022081E0 		add	r2, r1, r2
 3016              	.LVL137:
 666:bellator_low_level.c **** 	*(buff+1) = (char) val;
 3017              		.loc 3 666 0
 3018 1568 0120C0E5 		strb	r2, [r0, #1]
 668:bellator_low_level.c **** 	while(ADDR2 & ((0x1 << 31) == 0));
 3019              		.loc 3 668 0
 3020 156c 182093E5 		ldr	r2, [r3, #24]
 669:bellator_low_level.c **** 	val = (ADDR2 >> 6) & 0x3FF;
 3021              		.loc 3 669 0
 3022 1570 182093E5 		ldr	r2, [r3, #24]
 670:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3023              		.loc 3 670 0
 3024 1574 2224A0E1 		mov	r2, r2, lsr #8
 3025              	.LVL138:
 671:bellator_low_level.c **** 	val += (val == 0);
 3026              		.loc 3 671 0
 3027 1578 FF2012E2 		ands	r2, r2, #255
 3028              	.LVL139:
 3029 157c 0010A013 		movne	r1, #0
 3030 1580 0110A003 		moveq	r1, #1
 3031              	.LVL140:
 3032 1584 022081E0 		add	r2, r1, r2
 3033              	.LVL141:
 672:bellator_low_level.c **** 	*(buff+2) = (char) val;
 3034              		.loc 3 672 0
 3035 1588 0220C0E5 		strb	r2, [r0, #2]
 674:bellator_low_level.c **** 	while(ADDR3 & ((0x1 << 31) == 0));
 3036              		.loc 3 674 0
 3037 158c 1C2093E5 		ldr	r2, [r3, #28]
 675:bellator_low_level.c **** 	val = (ADDR3 >> 6) & 0x3FF;
 3038              		.loc 3 675 0
 3039 1590 1C2093E5 		ldr	r2, [r3, #28]
 676:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3040              		.loc 3 676 0
 3041 1594 2224A0E1 		mov	r2, r2, lsr #8
 3042              	.LVL142:
 677:bellator_low_level.c **** 	val += (val == 0);
 3043              		.loc 3 677 0
 3044 1598 FF2012E2 		ands	r2, r2, #255
 3045              	.LVL143:
 3046 159c 0010A013 		movne	r1, #0
 3047 15a0 0110A003 		moveq	r1, #1
 3048              	.LVL144:
 3049 15a4 022081E0 		add	r2, r1, r2
 3050              	.LVL145:
 678:bellator_low_level.c **** 	*(buff+3) = (char) val;
 3051              		.loc 3 678 0
 3052 15a8 0320C0E5 		strb	r2, [r0, #3]
 680:bellator_low_level.c **** 	while(ADDR4 & ((0x1 << 31) == 0));
 3053              		.loc 3 680 0
 3054 15ac 202093E5 		ldr	r2, [r3, #32]
 681:bellator_low_level.c **** 	val = (ADDR4 >> 6) & 0x3FF;
 3055              		.loc 3 681 0
 3056 15b0 203093E5 		ldr	r3, [r3, #32]
 682:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3057              		.loc 3 682 0
 3058 15b4 2334A0E1 		mov	r3, r3, lsr #8
 3059              	.LVL146:
 683:bellator_low_level.c **** 	val += (val == 0);
 3060              		.loc 3 683 0
 3061 15b8 FF3013E2 		ands	r3, r3, #255
 3062              	.LVL147:
 3063 15bc 0020A013 		movne	r2, #0
 3064 15c0 0120A003 		moveq	r2, #1
 3065              	.LVL148:
 3066 15c4 033082E0 		add	r3, r2, r3
 3067              	.LVL149:
 684:bellator_low_level.c **** 	*(buff+4) = (char) val;
 3068              		.loc 3 684 0
 3069 15c8 0430C0E5 		strb	r3, [r0, #4]
 685:bellator_low_level.c **** }
 3070              		.loc 3 685 0
 3071 15cc 1EFF2FE1 		bx	lr
 3072              	.L152:
 3073              		.align	2
 3074              	.L151:
 3075 15d0 004003E0 		.word	-536657920
 3076              		.cfi_endproc
 3077              	.LFE56:
 3078              		.fnend
 3080              		.align	2
 3081              		.global	get_encoders_count
 3083              	get_encoders_count:
 3084              		.fnstart
 3085              	.LFB57:
 692:bellator_low_level.c **** void get_encoders_count(short * left_encoder, short * right_encoder) {
 3086              		.loc 3 692 0
 3087              		.cfi_startproc
 3088              		@ Function supports interworking.
 3089              		@ args = 0, pretend = 0, frame = 0
 3090              		@ frame_needed = 0, uses_anonymous_args = 0
 3091              		@ link register save eliminated.
 3092              	.LVL150:
 695:bellator_low_level.c **** 	val = encoder_count[ENCODER_L - ENCODER_L];
 3093              		.loc 3 695 0
 3094 15d4 28309FE5 		ldr	r3, .L154
 3095 15d8 882713E5 		ldr	r2, [r3, #-1928]
 3096              	.LVL151:
 696:bellator_low_level.c **** 	*left_encoder = val - sent_encoder_count[ENCODER_L - ENCODER_L];
 3097              		.loc 3 696 0
 3098 15dc 80C713E5 		ldr	ip, [r3, #-1920]
 3099 15e0 02C06CE0 		rsb	ip, ip, r2
 3100 15e4 B0C0C0E1 		strh	ip, [r0, #0]	@ movhi
 697:bellator_low_level.c **** 	sent_encoder_count[ENCODER_L - ENCODER_L] = val;
 3101              		.loc 3 697 0
 3102 15e8 802703E5 		str	r2, [r3, #-1920]
 699:bellator_low_level.c **** 	val = encoder_count[ENCODER_R - ENCODER_L];
 3103              		.loc 3 699 0
 3104 15ec 842713E5 		ldr	r2, [r3, #-1924]
 3105              	.LVL152:
 700:bellator_low_level.c **** 	*right_encoder = val - sent_encoder_count[ENCODER_R - ENCODER_L];
 3106              		.loc 3 700 0
 3107 15f0 7C0713E5 		ldr	r0, [r3, #-1916]
 3108              	.LVL153:
 3109 15f4 020060E0 		rsb	r0, r0, r2
 3110 15f8 B000C1E1 		strh	r0, [r1, #0]	@ movhi
 701:bellator_low_level.c **** 	sent_encoder_count[ENCODER_R - ENCODER_L] = val;
 3111              		.loc 3 701 0
 3112 15fc 7C2703E5 		str	r2, [r3, #-1916]
 702:bellator_low_level.c **** }
 3113              		.loc 3 702 0
 3114 1600 1EFF2FE1 		bx	lr
 3115              	.L155:
 3116              		.align	2
 3117              	.L154:
 3118 1604 F81F0000 		.word	.LANCHOR2
 3119              		.cfi_endproc
 3120              	.LFE57:
 3121              		.fnend
 3123              		.align	2
 3124              		.global	sample
 3126              	sample:
 3127              		.fnstart
 3128              	.LFB54:
 595:bellator_low_level.c **** void sample(void) {
 3129              		.loc 3 595 0
 3130              		.cfi_startproc
 3131              		@ Interrupt Service Routine.
 3132              		@ args = 0, pretend = 0, frame = 0
 3133              		@ frame_needed = 0, uses_anonymous_args = 0
 3134 1608 04E04EE2 		sub	lr, lr, #4
 3135 160c FF532DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, lr}
 3136              		.save {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, lr}
 3137              	.LCFI43:
 3138              		.cfi_def_cfa_offset 48
 596:bellator_low_level.c **** 	const unsigned short ir = T3IR;
 3139              		.loc 3 596 0
 3140 1610 18319FE5 		ldr	r3, .L159
 3141              		.cfi_offset 14, -4
 3142              		.cfi_offset 12, -8
 3143              		.cfi_offset 9, -12
 3144              		.cfi_offset 8, -16
 3145              		.cfi_offset 7, -20
 3146              		.cfi_offset 6, -24
 3147              		.cfi_offset 5, -28
 3148              		.cfi_offset 4, -32
 3149              		.cfi_offset 3, -36
 3150              		.cfi_offset 2, -40
 3151              		.cfi_offset 1, -44
 3152              		.cfi_offset 0, -48
 3153 1614 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 597:bellator_low_level.c **** 	if(ir & 0x1) { // MAT3.0
 3154              		.loc 3 597 0
 3155 1618 010013E3 		tst	r3, #1
 3156 161c 3F00000A 		beq	.L157
 3157              	.LBB96:
 602:bellator_low_level.c **** 		T3IR |= 0x1 << 0; // clear MAT3.0 interrupt
 3158              		.loc 3 602 0
 3159 1620 08319FE5 		ldr	r3, .L159
 3160 1624 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 3161 1628 FF2002E2 		and	r2, r2, #255
 3162 162c 012082E3 		orr	r2, r2, #1
 3163 1630 0020C3E5 		strb	r2, [r3, #0]
 603:bellator_low_level.c **** 		IENABLE
 3164              		.loc 3 603 0
 3165              	#APP
 3166              	@ 603 "bellator_low_level.c" 1
 3167 1634 00E04FE1 		MRS		LR, SPSR
 3168              	@ 0 "" 2
 3169              	@ 603 "bellator_low_level.c" 1
 3170 1638 04E02DE5 		STMFD	SP!, {LR}
 3171              	@ 0 "" 2
 3172              	@ 603 "bellator_low_level.c" 1
 3173 163c 1FF021E3 		MSR		CPSR_c, #0x1F
 3174              	@ 0 "" 2
 3175              	@ 603 "bellator_low_level.c" 1
 3176 1640 04E02DE5 		STMFD	SP!, {LR}
 3177              	@ 0 "" 2
 606:bellator_low_level.c **** 		data_in_pos = ++data_in_pos % DATA_BUFF_SIZE;
 3178              		.loc 3 606 0
 3179 1644 E8209FE5 		ldr	r2, .L159+4
 3180 1648 E8309FE5 		ldr	r3, .L159+8
 3181 164c B31092E1 		ldrh	r1, [r2, r3]
 3182 1650 011081E2 		add	r1, r1, #1
 3183 1654 0118A0E1 		mov	r1, r1, asl #16
 3184 1658 2118A0E1 		mov	r1, r1, lsr #16
 3185 165c B31082E1 		strh	r1, [r2, r3]	@ movhi
 3186 1660 B31092E1 		ldrh	r1, [r2, r3]
 3187 1664 FF1001E2 		and	r1, r1, #255
 3188 1668 B31082E1 		strh	r1, [r2, r3]	@ movhi
 609:bellator_low_level.c **** 		if (data_in_pos == data_out_pos) {
 3189              		.loc 3 609 0
 3190 166c B32092E1 		ldrh	r2, [r2, r3]
 3191 1670 C4309FE5 		ldr	r3, .L159+12
 3192 1674 B036D3E1 		ldrh	r3, [r3, #96]
 3193 1678 030052E1 		cmp	r2, r3
 3194 167c 0A00001A 		bne	.L158
 610:bellator_low_level.c **** 			log_string_warning("LPC overflow\n");
 3195              		.loc 3 610 0
 3196 1680 B8009FE5 		ldr	r0, .L159+16
 3197 1684 FEFFFFEB 		bl	log_string
 612:bellator_low_level.c **** 			data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 3198              		.loc 3 612 0
 3199 1688 AC309FE5 		ldr	r3, .L159+12
 3200 168c B026D3E1 		ldrh	r2, [r3, #96]
 3201 1690 012082E2 		add	r2, r2, #1
 3202 1694 0228A0E1 		mov	r2, r2, asl #16
 3203 1698 2228A0E1 		mov	r2, r2, lsr #16
 3204 169c B026C3E1 		strh	r2, [r3, #96]	@ movhi
 3205 16a0 B026D3E1 		ldrh	r2, [r3, #96]
 3206 16a4 FF2002E2 		and	r2, r2, #255
 3207 16a8 B026C3E1 		strh	r2, [r3, #96]	@ movhi
 3208              	.L158:
 617:bellator_low_level.c **** 		data = &(sensors_data_buff[data_in_pos]);
 3209              		.loc 3 617 0
 3210 16ac 80709FE5 		ldr	r7, .L159+4
 3211 16b0 80309FE5 		ldr	r3, .L159+8
 3212 16b4 B34097E1 		ldrh	r4, [r7, r3]
 3213              	.LVL154:
 620:bellator_low_level.c **** 		get_encoders_count(&(data->encoder_left), &(data->encoder_right));
 3214              		.loc 3 620 0
 3215 16b8 7C809FE5 		ldr	r8, .L159+12
 3216 16bc 645088E2 		add	r5, r8, #100
 3217 16c0 8460A0E1 		mov	r6, r4, asl #1
 3218 16c4 041086E0 		add	r1, r6, r4
 3219 16c8 811185E0 		add	r1, r5, r1, asl #3
 3220 16cc 0100A0E1 		mov	r0, r1
 3221 16d0 021081E2 		add	r1, r1, #2
 3222 16d4 FEFFFFEB 		bl	get_encoders_count
 623:bellator_low_level.c **** 		mpu_get_motion6(&(data->ax_h));
 3223              		.loc 3 623 0
 3224 16d8 043086E0 		add	r3, r6, r4
 3225 16dc 835185E0 		add	r5, r5, r3, asl #3
 3226 16e0 090085E2 		add	r0, r5, #9
 3227 16e4 085085E2 		add	r5, r5, #8
 3228 16e8 FEFFFFEB 		bl	mpu_get_motion6
 626:bellator_low_level.c **** 		get_ir_sensor_data(&(data->ir_l));
 3229              		.loc 3 626 0
 3230 16ec 0500A0E1 		mov	r0, r5
 3231 16f0 FEFFFFEB 		bl	get_ir_sensor_data
 628:bellator_low_level.c **** 		data->timestamp = timestamp++;
 3232              		.loc 3 628 0
 3233 16f4 48309FE5 		ldr	r3, .L159+20
 3234 16f8 B32097E1 		ldrh	r2, [r7, r3]
 3235 16fc 044086E0 		add	r4, r6, r4
 3236              	.LVL155:
 3237 1700 848188E0 		add	r8, r8, r4, asl #3
 3238 1704 BA27C8E1 		strh	r2, [r8, #122]	@ movhi
 3239 1708 012082E2 		add	r2, r2, #1
 3240 170c B32087E1 		strh	r2, [r7, r3]	@ movhi
 631:bellator_low_level.c **** 		IDISABLE
 3241              		.loc 3 631 0
 3242              	#APP
 3243              	@ 631 "bellator_low_level.c" 1
 3244 1710 04E09DE4 		LDMFD	SP!, {LR}
 3245              	@ 0 "" 2
 3246              	@ 631 "bellator_low_level.c" 1
 3247 1714 92F021E3 		MSR		CPSR_c, #0x92
 3248              	@ 0 "" 2
 3249              	@ 631 "bellator_low_level.c" 1
 3250 1718 04E09DE4 		LDMFD	SP!, {LR}
 3251              	@ 0 "" 2
 3252              	@ 631 "bellator_low_level.c" 1
 3253 171c 0EF06FE1 		MSR		SPSR_cxsf, LR
 3254              	@ 0 "" 2
 3255              	.L157:
 3256              	.LBE96:
 636:bellator_low_level.c **** 	VICVectAddr = 0;
 3257              		.loc 3 636 0
 3258 1720 0020A0E3 		mov	r2, #0
 3259 1724 0030E0E3 		mvn	r3, #0
 3260 1728 CF2F03E5 		str	r2, [r3, #-4047]
 637:bellator_low_level.c **** }
 3261              		.loc 3 637 0
 3262 172c FF93FDE8 		ldmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
 3263              	.L160:
 3264              		.align	2
 3265              	.L159:
 3266 1730 004007E0 		.word	-536395776
 3267 1734 F81F0000 		.word	.LANCHOR2
 3268 1738 6CF8FFFF 		.word	-1940
 3269 173c 00000000 		.word	.LANCHOR0
 3270 1740 20000000 		.word	.LC3
 3271 1744 88F8FFFF 		.word	-1912
 3272              		.cfi_endproc
 3273              	.LFE54:
 3274              		.fnend
 3276              		.global	ascii
 3277              		.section	.rodata
 3278              		.align	2
 3279              	.LANCHOR1 = . + 0
 3282              	ascii:
 3283 0000 30313233 		.ascii	"0123456789ABCDEF\000"
 3283      34353637 
 3283      38394142 
 3283      43444546 
 3283      00
 3284 0011 000000   		.section	.rodata.str1.4,"aMS",%progbits,1
 3285              		.align	2
 3286              	.LC0:
 3287 0000 69727120 		.ascii	"irq error\000"
 3287      6572726F 
 3287      7200
 3288 000a 0000     		.space	2
 3289              	.LC1:
 3290 000c 5B693263 		.ascii	"[i2c] default: \000"
 3290      5D206465 
 3290      6661756C 
 3290      743A2000 
 3291              	.LC2:
 3292 001c 0A00     		.ascii	"\012\000"
 3293 001e 0000     		.space	2
 3294              	.LC3:
 3295 0020 4C504320 		.ascii	"LPC overflow\012\000"
 3295      6F766572 
 3295      666C6F77 
 3295      0A00
 3296 002e 0000     		.bss
 3297              		.align	2
 3298              	.LANCHOR0 = . + 0
 3299              	.LANCHOR2 = . + 8184
 3302              	ra_buff:
 3303 0000 00       		.space	1
 3304 0001 000000   		.space	3
 3307              	buff_pos:
 3308 0004 00000000 		.space	4
 3311              	buff_size:
 3312 0008 00000000 		.space	4
 3315              	c_buff:
 3316 000c 00000000 		.space	4
 3319              	busy:
 3320 0010 00000000 		.space	4
 3323              	cmd_in:
 3324 0014 00000000 		.space	36
 3324      00000000 
 3324      00000000 
 3324      00000000 
 3324      00000000 
 3327              	send_data:
 3328 0038 00       		.space	1
 3329 0039 000000   		.space	3
 3332              	cmd_out:
 3333 003c 00000000 		.space	36
 3333      00000000 
 3333      00000000 
 3333      00000000 
 3333      00000000 
 3336              	data_out_pos:
 3337 0060 0000     		.space	2
 3338 0062 0000     		.space	2
 3341              	sensors_data_buff:
 3342 0064 00000000 		.space	6144
 3342      00000000 
 3342      00000000 
 3342      00000000 
 3342      00000000 
 3345              	data_in_pos:
 3346 1864 0000     		.space	2
 3347 1866 0000     		.space	2
 3350              	forward_l:
 3351 1868 00000000 		.space	4
 3354              	forward_r:
 3355 186c 00000000 		.space	4
 3358              	encoder_count:
 3359 1870 00000000 		.space	8
 3359      00000000 
 3362              	sent_encoder_count:
 3363 1878 00000000 		.space	8
 3363      00000000 
 3366              	timestamp:
 3367 1880 0000     		.space	2
 3368 1882 0000     		.text
 3369              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 bellator_low_level.c
     /tmp/cc0uJMtV.s:21     .text:00000000 $a
     /tmp/cc0uJMtV.s:23     .text:00000000 log_char
     /tmp/cc0uJMtV.s:49     .text:0000001c $d
                       .ARM.exidx:00000000 $d
     /tmp/cc0uJMtV.s:54     .text:00000020 $a
     /tmp/cc0uJMtV.s:57     .text:00000020 i2c_write_byte_isr
     /tmp/cc0uJMtV.s:95     .text:00000054 $d
     /tmp/cc0uJMtV.s:138    .text:000000f8 $a
     /tmp/cc0uJMtV.s:217    .text:000001d4 $d
     /tmp/cc0uJMtV.s:223    .text:000001dc $a
     /tmp/cc0uJMtV.s:226    .text:000001dc protocol_in
     /tmp/cc0uJMtV.s:284    .text:0000021c $d
     /tmp/cc0uJMtV.s:299    .text:00000250 $a
     /tmp/cc0uJMtV.s:425    .text:00000378 $d
                       .ARM.extab:00000000 $d
     /tmp/cc0uJMtV.s:433    .text:00000388 $a
     /tmp/cc0uJMtV.s:436    .text:00000388 logger_init
     /tmp/cc0uJMtV.s:480    .text:000003e4 $d
     /tmp/cc0uJMtV.s:486    .text:000003ec $a
     /tmp/cc0uJMtV.s:489    .text:000003ec log_int
     /tmp/cc0uJMtV.s:570    .text:00000490 $d
     /tmp/cc0uJMtV.s:575    .text:00000494 $a
     /tmp/cc0uJMtV.s:578    .text:00000494 log_short
     /tmp/cc0uJMtV.s:644    .text:00000500 $d
     /tmp/cc0uJMtV.s:649    .text:00000504 $a
     /tmp/cc0uJMtV.s:652    .text:00000504 log_string
     /tmp/cc0uJMtV.s:702    .text:00000544 error
     /tmp/cc0uJMtV.s:729    .text:00000558 $d
     /tmp/cc0uJMtV.s:734    .text:0000055c $a
     /tmp/cc0uJMtV.s:737    .text:0000055c i2c_read_bytes_isr
     /tmp/cc0uJMtV.s:776    .text:00000594 $d
     /tmp/cc0uJMtV.s:859    .text:000006d8 $a
     /tmp/cc0uJMtV.s:988    .text:00000830 $d
     /tmp/cc0uJMtV.s:996    .text:00000840 $a
     /tmp/cc0uJMtV.s:999    .text:00000840 log_byte
     /tmp/cc0uJMtV.s:1054   .text:0000088c $d
     /tmp/cc0uJMtV.s:1059   .text:00000890 $a
     /tmp/cc0uJMtV.s:1062   .text:00000890 log2bytes
     /tmp/cc0uJMtV.s:1128   .text:000008fc $d
     /tmp/cc0uJMtV.s:1133   .text:00000900 $a
     /tmp/cc0uJMtV.s:1136   .text:00000900 log4bytes
     /tmp/cc0uJMtV.s:1217   .text:000009a4 $d
     /tmp/cc0uJMtV.s:1222   .text:000009a8 $a
     /tmp/cc0uJMtV.s:1225   .text:000009a8 i2c_init
     /tmp/cc0uJMtV.s:1270   .text:00000a08 $d
     /tmp/cc0uJMtV.s:1275   .text:00000a0c $a
     /tmp/cc0uJMtV.s:1278   .text:00000a0c i2c_read_bytes
     /tmp/cc0uJMtV.s:1325   .text:00000a5c $d
     /tmp/cc0uJMtV.s:1332   .text:00000a68 $a
     /tmp/cc0uJMtV.s:1335   .text:00000a68 i2c_read_byte
     /tmp/cc0uJMtV.s:1366   .text:00000a80 i2c_write_byte
     /tmp/cc0uJMtV.s:1419   .text:00000ae0 $d
     /tmp/cc0uJMtV.s:1426   .text:00000aec $a
     /tmp/cc0uJMtV.s:1429   .text:00000aec i2c_write_bits
     /tmp/cc0uJMtV.s:1495   .text:00000b4c mpu_set_clock_source
     /tmp/cc0uJMtV.s:1528   .text:00000b6c mpu_set_full_scale_gyro_range
     /tmp/cc0uJMtV.s:1560   .text:00000b8c mpu_set_full_scale_accel_range
     /tmp/cc0uJMtV.s:1592   .text:00000bac mpu_set_sleep_enable
     /tmp/cc0uJMtV.s:1624   .text:00000bcc mpu_set_temperature_sensor_enabled
     /tmp/cc0uJMtV.s:1657   .text:00000bf0 mpu_set_gyro_rate
     /tmp/cc0uJMtV.s:1687   .text:00000c08 mpu_set_DLPF_mode
     /tmp/cc0uJMtV.s:1719   .text:00000c28 mpu_set_6axis_FIFO_enabled
     /tmp/cc0uJMtV.s:1749   .text:00000c40 mpu_set_interrupt_mode
     /tmp/cc0uJMtV.s:1781   .text:00000c60 mpu_set_interrupt_drive
     /tmp/cc0uJMtV.s:1813   .text:00000c80 mpu_set_interrupt_latch
     /tmp/cc0uJMtV.s:1845   .text:00000ca0 mpu_set_FIFO_overflow_interrupt
     /tmp/cc0uJMtV.s:1877   .text:00000cc0 mpu_set_data_ready_interrupt
     /tmp/cc0uJMtV.s:1909   .text:00000ce0 mpu_clear_interrupt
     /tmp/cc0uJMtV.s:1940   .text:00000cf8 mpu_set_FIFO_enabled
     /tmp/cc0uJMtV.s:1972   .text:00000d18 mpu_reset_FIFO
     /tmp/cc0uJMtV.s:2002   .text:00000d38 mpu_init
     /tmp/cc0uJMtV.s:2055   .text:00000d90 mpu_get_FIFO_size
     /tmp/cc0uJMtV.s:2097   .text:00000dc8 mpu_get_motion6
     /tmp/cc0uJMtV.s:2170   .text:00000e50 mpu_get_FIFO_motion6
     /tmp/cc0uJMtV.s:2243   .text:00000ed8 main
     /tmp/cc0uJMtV.s:2825   .text:000013b4 $d
     /tmp/cc0uJMtV.s:3126   .text:00001608 sample
     /tmp/cc0uJMtV.s:2845   .text:000013f4 $a
     /tmp/cc0uJMtV.s:2848   .text:000013f4 pulse_in
     /tmp/cc0uJMtV.s:2964   .text:0000151c $d
     /tmp/cc0uJMtV.s:2971   .text:00001528 $a
     /tmp/cc0uJMtV.s:2974   .text:00001528 get_ir_sensor_data
     /tmp/cc0uJMtV.s:3075   .text:000015d0 $d
     /tmp/cc0uJMtV.s:3080   .text:000015d4 $a
     /tmp/cc0uJMtV.s:3083   .text:000015d4 get_encoders_count
     /tmp/cc0uJMtV.s:3118   .text:00001604 $d
     /tmp/cc0uJMtV.s:3123   .text:00001608 $a
     /tmp/cc0uJMtV.s:3266   .text:00001730 $d
     /tmp/cc0uJMtV.s:3282   .rodata:00000000 ascii
     /tmp/cc0uJMtV.s:3278   .rodata:00000000 $d
     /tmp/cc0uJMtV.s:3285   .rodata.str1.4:00000000 $d
     /tmp/cc0uJMtV.s:3297   .bss:00000000 $d
     /tmp/cc0uJMtV.s:3302   .bss:00000000 ra_buff
     /tmp/cc0uJMtV.s:3307   .bss:00000004 buff_pos
     /tmp/cc0uJMtV.s:3311   .bss:00000008 buff_size
     /tmp/cc0uJMtV.s:3315   .bss:0000000c c_buff
     /tmp/cc0uJMtV.s:3319   .bss:00000010 busy
     /tmp/cc0uJMtV.s:3323   .bss:00000014 cmd_in
     /tmp/cc0uJMtV.s:3327   .bss:00000038 send_data
     /tmp/cc0uJMtV.s:3332   .bss:0000003c cmd_out
     /tmp/cc0uJMtV.s:3336   .bss:00000060 data_out_pos
     /tmp/cc0uJMtV.s:3341   .bss:00000064 sensors_data_buff
     /tmp/cc0uJMtV.s:3345   .bss:00001864 data_in_pos
     /tmp/cc0uJMtV.s:3350   .bss:00001868 forward_l
     /tmp/cc0uJMtV.s:3354   .bss:0000186c forward_r
     /tmp/cc0uJMtV.s:3358   .bss:00001870 encoder_count
     /tmp/cc0uJMtV.s:3362   .bss:00001878 sent_encoder_count
     /tmp/cc0uJMtV.s:3366   .bss:00001880 timestamp
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_unwind_cpp_pr0
__aeabi_unwind_cpp_pr1
