   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 2
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"bellator_low_level.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  23              	log_char:
  24              		.fnstart
  25              	.LFB1:
  26              		.file 1 "logger.c"
   1:logger.c      **** /*
   2:logger.c      ****  * logger.c
   3:logger.c      ****  *
   4:logger.c      ****  *  Created on: Jul 14, 2009
   5:logger.c      ****  *      Author: telmo
   6:logger.c      ****  */
   7:logger.c      **** #include "lpc2103.h"
   8:logger.c      **** #include "logger.h"
   9:logger.c      **** 
  10:logger.c      **** /**
  11:logger.c      ****  * Start logger using UART0
  12:logger.c      ****  * 8N1 (8 data, Non parity, 1 stop)
  13:logger.c      ****  * 115200 bps
  14:logger.c      ****  *
  15:logger.c      ****  * UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL) * ( 1 + DivAddVal/MulVal))
  16:logger.c      ****  * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
  17:logger.c      ****  * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
  18:logger.c      ****  * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
  19:logger.c      ****  */
  20:logger.c      **** void logger_init(void){ // using UART0
  21:logger.c      **** 	PINSEL0 |= 0x05; // Set the pins function
  22:logger.c      **** 	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
  23:logger.c      **** 	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
  24:logger.c      **** 
  25:logger.c      **** #ifdef CRYSTAL12MHz
  26:logger.c      **** 	U0DLL	 = 0x06; // DivisorLatchLow bit
  27:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
  28:logger.c      **** 	U0FDR	|= 0x05; // DivAddVal
  29:logger.c      **** 	U0FDR	|= 0x0E << 4; // MulVal = 14
  30:logger.c      **** #endif
  31:logger.c      **** #ifdef CRYSTAL14745600Hz
  32:logger.c      **** 	U0DLL	 = 0x08; // DivisorLatchLow bit
  33:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
  34:logger.c      **** #endif
  35:logger.c      **** 
  36:logger.c      **** 	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
  37:logger.c      **** }
  38:logger.c      **** 
  39:logger.c      **** static void log_char(char c){
  27              		.loc 1 39 0
  28              		.cfi_startproc
  29              		@ Function supports interworking.
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  40:logger.c      **** 	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
  34              		.loc 1 40 0
  35 0000 14309FE5 		ldr	r3, .L4
  36 0004 0000C3E5 		strb	r0, [r3, #0]
  41:logger.c      **** 	while(!(U0LSR & 0x40));
  37              		.loc 1 41 0
  38 0008 0320A0E1 		mov	r2, r3
  39              	.L2:
  40              		.loc 1 41 0 is_stmt 0 discriminator 1
  41 000c 1430D2E5 		ldrb	r3, [r2, #20]	@ zero_extendqisi2
  42 0010 400013E3 		tst	r3, #64
  43 0014 FCFFFF0A 		beq	.L2
  42:logger.c      **** }
  44              		.loc 1 42 0 is_stmt 1
  45 0018 1EFF2FE1 		bx	lr
  46              	.L5:
  47              		.align	2
  48              	.L4:
  49 001c 00C000E0 		.word	-536821760
  50              		.cfi_endproc
  51              	.LFE1:
  52              		.fnend
  54              		.align	2
  55              		.global	i2c_read_bytes_isr
  57              	i2c_read_bytes_isr:
  58              		.fnstart
  59              	.LFB18:
  60              		.file 2 "i2c.c"
   1:i2c.c         **** /*
   2:i2c.c         ****  * i2c.c
   3:i2c.c         ****  *
   4:i2c.c         ****  *  Created on: Mar 21, 2013
   5:i2c.c         ****  *      Author: telmo
   6:i2c.c         ****  */
   7:i2c.c         **** #include "lpc2103.h"
   8:i2c.c         **** #include "i2c.h"
   9:i2c.c         **** #include "logger.h"
  10:i2c.c         **** #include "mpu6050.h"
  11:i2c.c         **** 
  12:i2c.c         **** /**
  13:i2c.c         ****  * I2C 1
  14:i2c.c         ****  *
  15:i2c.c         ****  * I2Cbitfrequency = PCLK / ( I2C1SCLH + I2C1SCLL )
  16:i2c.c         ****  * 0 < I2Cbitfrequency < 400kHz
  17:i2c.c         ****  * I2C1SCLL >= 4, I2C1SCLH >=4
  18:i2c.c         ****  * pclk=15MHz or pclk=14.7456MHz, depending on previous configuration
  19:i2c.c         ****  *
  20:i2c.c         ****  * MPU Address: b1101000W
  21:i2c.c         ****  * W bit 0 => write on the mpu registers
  22:i2c.c         ****  * I2C Addr + Reg Addr + Data
  23:i2c.c         ****  * I2C Addr + Reg Addr + Data + Data for Addr+1, etc
  24:i2c.c         ****  * W bit 1 => read
  25:i2c.c         ****  */
  26:i2c.c         **** void i2c_init(void){
  27:i2c.c         **** 
  28:i2c.c         **** 	log_string_i2c(">> i2c_init\n");
  29:i2c.c         **** 
  30:i2c.c         **** 	// Set the pin function
  31:i2c.c         **** 	PINSEL1 |= 0x1 << 2; // SCL1
  32:i2c.c         **** 	PINSEL1 |= 0x1 << 4; // SDA1
  33:i2c.c         **** 
  34:i2c.c         **** 	I2C1CONCLR = 0x6C; // clear all flags
  35:i2c.c         **** 	I2C1CONSET |= 0x1 << 6; // enable i2c1
  36:i2c.c         **** 	I2C1SCLH = 19; // Set the bit rate:
  37:i2c.c         **** 	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
  38:i2c.c         **** 
  39:i2c.c         **** 	// Enable the interrupts
  40:i2c.c         **** 	VICVectCntl2 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
  41:i2c.c         **** 	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
  42:i2c.c         **** 
  43:i2c.c         **** 	// Enable i2c as FIQ
  44:i2c.c         **** 	//VICIntSelect |= 0x1 << 19;// I2C1 as FIQ
  45:i2c.c         **** 	//VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
  46:i2c.c         **** 
  47:i2c.c         **** 	log_string_i2c("<< i2c_init\n");
  48:i2c.c         **** }
  49:i2c.c         **** 
  50:i2c.c         **** //void i2c_isr(void) {
  51:i2c.c         **** //	(*current_isr)();
  52:i2c.c         **** //}
  53:i2c.c         **** 
  54:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
  55:i2c.c         **** 	log_string_i2c("read_byte\n");
  56:i2c.c         **** 
  57:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
  58:i2c.c         **** 
  59:i2c.c         **** 	log_string_i2c("read_byte..returning\n");
  60:i2c.c         **** 	return i;
  61:i2c.c         **** }
  62:i2c.c         **** 
  63:i2c.c         **** int i2c_read_bytes(char reg_addr, char length, char* data) {
  64:i2c.c         **** 	log_string_i2c(">> read_bytes\n");
  65:i2c.c         **** 
  66:i2c.c         **** 	buff_size = length;
  67:i2c.c         **** 	buff_pos = 0;
  68:i2c.c         **** 	ra_buff = reg_addr;
  69:i2c.c         **** 	c_buff = data;
  70:i2c.c         **** 
  71:i2c.c         **** 	busy = 1;
  72:i2c.c         **** 
  73:i2c.c         **** 	//Setting the interrupt handler location for write byte
  74:i2c.c         **** 	VICVectAddr2 = (unsigned int) &i2c_read_bytes_isr;
  75:i2c.c         **** 	//current_isr = &i2c_read_bytes_isr;
  76:i2c.c         **** 	// Send Start bit
  77:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
  78:i2c.c         **** 
  79:i2c.c         **** 	log_string_i2c("waiting\n");
  80:i2c.c         **** 
  81:i2c.c         **** 	while (busy); // busy wait for read process
  82:i2c.c         **** 
  83:i2c.c         **** 	log_string_i2c("<< read_bytes\n");
  84:i2c.c         **** 	return 1;
  85:i2c.c         **** }
  86:i2c.c         **** 
  87:i2c.c         **** /**
  88:i2c.c         ****  * i2c interrupt handler
  89:i2c.c         ****  */
  90:i2c.c         **** void i2c_read_bytes_isr(void) {
  61              		.loc 2 90 0
  62              		.cfi_startproc
  63              		@ Interrupt Service Routine.
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67 0020 0F102DE9 		stmfd	sp!, {r0, r1, r2, r3, ip}
  68              		.save {r0, r1, r2, r3, ip}
  69              	.LCFI0:
  70              		.cfi_def_cfa_offset 20
  71              		.pad #12
  72 0024 0CD04DE2 		sub	sp, sp, #12
  73              	.LCFI1:
  74              		.cfi_def_cfa_offset 32
  91:i2c.c         **** 	log_string_i2c(">> read_bytes_isr\n");
  92:i2c.c         **** 	volatile int temp = 0;
  75              		.loc 2 92 0
  76 0028 0030A0E3 		mov	r3, #0
  77              		.cfi_offset 12, -4
  78              		.cfi_offset 3, -8
  79              		.cfi_offset 2, -12
  80              		.cfi_offset 1, -16
  81              		.cfi_offset 0, -20
  82 002c 04308DE5 		str	r3, [sp, #4]
  83              	.LVL1:
  93:i2c.c         **** 	temp = I2C1STAT;
  84              		.loc 2 93 0
  85 0030 A0329FE5 		ldr	r3, .L20
  86 0034 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
  87 0038 FF3003E2 		and	r3, r3, #255
  88 003c 04308DE5 		str	r3, [sp, #4]
  94:i2c.c         **** 
  95:i2c.c         **** 	switch (temp) {
  89              		.loc 2 95 0
  90 0040 04309DE5 		ldr	r3, [sp, #4]
  91 0044 083043E2 		sub	r3, r3, #8
  92 0048 500053E3 		cmp	r3, #80
  93 004c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
  94 0050 970000EA 		b	.L7
  95              	.L16:
  96 0054 98010000 		.word	.L8
  97 0058 B4020000 		.word	.L7
  98 005c B4020000 		.word	.L7
  99 0060 B4020000 		.word	.L7
 100 0064 B4020000 		.word	.L7
 101 0068 B4020000 		.word	.L7
 102 006c B4020000 		.word	.L7
 103 0070 B4020000 		.word	.L7
 104 0074 B0010000 		.word	.L9
 105 0078 B4020000 		.word	.L7
 106 007c B4020000 		.word	.L7
 107 0080 B4020000 		.word	.L7
 108 0084 B4020000 		.word	.L7
 109 0088 B4020000 		.word	.L7
 110 008c B4020000 		.word	.L7
 111 0090 B4020000 		.word	.L7
 112 0094 C8010000 		.word	.L10
 113 0098 B4020000 		.word	.L7
 114 009c B4020000 		.word	.L7
 115 00a0 B4020000 		.word	.L7
 116 00a4 B4020000 		.word	.L7
 117 00a8 B4020000 		.word	.L7
 118 00ac B4020000 		.word	.L7
 119 00b0 B4020000 		.word	.L7
 120 00b4 C0020000 		.word	.L11
 121 00b8 B4020000 		.word	.L7
 122 00bc B4020000 		.word	.L7
 123 00c0 B4020000 		.word	.L7
 124 00c4 B4020000 		.word	.L7
 125 00c8 B4020000 		.word	.L7
 126 00cc B4020000 		.word	.L7
 127 00d0 B4020000 		.word	.L7
 128 00d4 E4010000 		.word	.L12
 129 00d8 B4020000 		.word	.L7
 130 00dc B4020000 		.word	.L7
 131 00e0 B4020000 		.word	.L7
 132 00e4 B4020000 		.word	.L7
 133 00e8 B4020000 		.word	.L7
 134 00ec B4020000 		.word	.L7
 135 00f0 B4020000 		.word	.L7
 136 00f4 C0020000 		.word	.L11
 137 00f8 B4020000 		.word	.L7
 138 00fc B4020000 		.word	.L7
 139 0100 B4020000 		.word	.L7
 140 0104 B4020000 		.word	.L7
 141 0108 B4020000 		.word	.L7
 142 010c B4020000 		.word	.L7
 143 0110 B4020000 		.word	.L7
 144 0114 C0020000 		.word	.L11
 145 0118 B4020000 		.word	.L7
 146 011c B4020000 		.word	.L7
 147 0120 B4020000 		.word	.L7
 148 0124 B4020000 		.word	.L7
 149 0128 B4020000 		.word	.L7
 150 012c B4020000 		.word	.L7
 151 0130 B4020000 		.word	.L7
 152 0134 FC010000 		.word	.L13
 153 0138 B4020000 		.word	.L7
 154 013c B4020000 		.word	.L7
 155 0140 B4020000 		.word	.L7
 156 0144 B4020000 		.word	.L7
 157 0148 B4020000 		.word	.L7
 158 014c B4020000 		.word	.L7
 159 0150 B4020000 		.word	.L7
 160 0154 C0020000 		.word	.L11
 161 0158 B4020000 		.word	.L7
 162 015c B4020000 		.word	.L7
 163 0160 B4020000 		.word	.L7
 164 0164 B4020000 		.word	.L7
 165 0168 B4020000 		.word	.L7
 166 016c B4020000 		.word	.L7
 167 0170 B4020000 		.word	.L7
 168 0174 24020000 		.word	.L14
 169 0178 B4020000 		.word	.L7
 170 017c B4020000 		.word	.L7
 171 0180 B4020000 		.word	.L7
 172 0184 B4020000 		.word	.L7
 173 0188 B4020000 		.word	.L7
 174 018c B4020000 		.word	.L7
 175 0190 B4020000 		.word	.L7
 176 0194 64020000 		.word	.L15
 177              	.L8:
  96:i2c.c         **** 	case TW_START: // A START condition has been transmitted.
  97:i2c.c         **** 		log_string_i2c("TW_START\n");
  98:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
 178              		.loc 2 98 0
 179 0198 38319FE5 		ldr	r3, .L20
 180 019c 2F20E0E3 		mvn	r2, #47
 181 01a0 0820C3E5 		strb	r2, [r3, #8]
  99:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 182              		.loc 2 99 0
 183 01a4 2820A0E3 		mov	r2, #40
 184 01a8 1820C3E5 		strb	r2, [r3, #24]
 100:i2c.c         **** 		break;
 185              		.loc 2 100 0
 186 01ac 430000EA 		b	.L11
 187              	.L9:
 101:i2c.c         **** 	case TW_REP_START: // A repeated START	condition has been transmitted.
 102:i2c.c         **** 		log_string_i2c("TW_REP_START\n");
 103:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_READ; // Slave address + Read
 188              		.loc 2 103 0
 189 01b0 20319FE5 		ldr	r3, .L20
 190 01b4 2E20E0E3 		mvn	r2, #46
 191 01b8 0820C3E5 		strb	r2, [r3, #8]
 104:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 192              		.loc 2 104 0
 193 01bc 2820A0E3 		mov	r2, #40
 194 01c0 1820C3E5 		strb	r2, [r3, #24]
 105:i2c.c         **** 		break;
 195              		.loc 2 105 0
 196 01c4 3D0000EA 		b	.L11
 197              	.L10:
 106:i2c.c         **** 	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
 107:i2c.c         **** 		log_string_i2c("TW_MT_SLA_ACK\n");
 108:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 198              		.loc 2 108 0
 199 01c8 0C319FE5 		ldr	r3, .L20+4
 200 01cc 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 201 01d0 00319FE5 		ldr	r3, .L20
 202 01d4 0820C3E5 		strb	r2, [r3, #8]
 109:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 203              		.loc 2 109 0
 204 01d8 0820A0E3 		mov	r2, #8
 205 01dc 1820C3E5 		strb	r2, [r3, #24]
 110:i2c.c         **** 		break;
 206              		.loc 2 110 0
 207 01e0 360000EA 		b	.L11
 208              	.L12:
 111:i2c.c         **** 	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
 112:i2c.c         **** 		log_string_i2c("TW_MT_SLA_NACK\n");
 113:i2c.c         **** 		break;
 114:i2c.c         **** 	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
 115:i2c.c         **** 		log_string_i2c("TW_MT_DATA_ACK\n");
 116:i2c.c         **** 		I2C1CONSET = 0x20; // Transmit start condition
 209              		.loc 2 116 0
 210 01e4 EC309FE5 		ldr	r3, .L20
 211 01e8 2020A0E3 		mov	r2, #32
 212 01ec 0020C3E5 		strb	r2, [r3, #0]
 117:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 213              		.loc 2 117 0
 214 01f0 0820A0E3 		mov	r2, #8
 215 01f4 1820C3E5 		strb	r2, [r3, #24]
 118:i2c.c         **** 		break;
 216              		.loc 2 118 0
 217 01f8 300000EA 		b	.L11
 218              	.L13:
 119:i2c.c         **** 	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
 120:i2c.c         **** 		log_string_i2c("TW_MT_DATA_NACK\n");
 121:i2c.c         **** 		break;
 122:i2c.c         **** 	case TW_MT_ARB_LOST: // Arbitration lost in SLA+R/W or Data bytes.
 123:i2c.c         **** 		log_string_i2c("TW_MT_ARB_LOST\n");
 124:i2c.c         **** 		break;
 125:i2c.c         **** 
 126:i2c.c         **** 	case TW_MR_SLA_ACK: // SLA+R has been transmitted; ACK has been received.
 127:i2c.c         **** 		log_string_i2c("TW_MR_SLA_ACK\n");
 128:i2c.c         **** 		if(buff_size > 1)
 219              		.loc 2 128 0
 220 01fc D8309FE5 		ldr	r3, .L20+4
 221 0200 043093E5 		ldr	r3, [r3, #4]
 222 0204 010053E3 		cmp	r3, #1
 129:i2c.c         **** 			I2C1CONSET = 0x04; // Transmit ACK on data receives
 223              		.loc 2 129 0
 224 0208 0420A0C3 		movgt	r2, #4
 225 020c C4309FC5 		ldrgt	r3, .L20
 226 0210 0020C3C5 		strgtb	r2, [r3, #0]
 130:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 227              		.loc 2 130 0
 228 0214 0820A0E3 		mov	r2, #8
 229 0218 B8309FE5 		ldr	r3, .L20
 230 021c 1820C3E5 		strb	r2, [r3, #24]
 131:i2c.c         **** 		break;
 231              		.loc 2 131 0
 232 0220 260000EA 		b	.L11
 233              	.L14:
 132:i2c.c         **** 	case TW_MR_SLA_NACK: // SLA+R has been transmitted; NOT ACK or has been received.
 133:i2c.c         **** 		log_string_i2c("TW_MR_SLA_NACK\n");
 134:i2c.c         **** 		break;
 135:i2c.c         **** 	case TW_MR_DATA_ACK: // Data byte has been received; ACK has been returned.
 136:i2c.c         **** 		log_string_i2c("TW_MR_DATA_ACK\n");
 137:i2c.c         **** 		log_string_i2c("pos: ");
 138:i2c.c         **** 		log_int_i2c(buff_pos);
 139:i2c.c         **** 		log_string_i2c("\n");
 140:i2c.c         **** 		if ((buff_pos + 2) < buff_size) {
 234              		.loc 2 140 0
 235 0224 B0209FE5 		ldr	r2, .L20+4
 236 0228 083092E5 		ldr	r3, [r2, #8]
 237 022c 021083E2 		add	r1, r3, #2
 238 0230 042092E5 		ldr	r2, [r2, #4]
 239 0234 020051E1 		cmp	r1, r2
 141:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 240              		.loc 2 141 0
 241 0238 98209FE5 		ldr	r2, .L20
 242 023c 08C0D2E5 		ldrb	ip, [r2, #8]	@ zero_extendqisi2
 243 0240 94109FE5 		ldr	r1, .L20+4
 244 0244 0C0091E5 		ldr	r0, [r1, #12]
 245 0248 03C0C0E7 		strb	ip, [r0, r3]
 246 024c 013083E2 		add	r3, r3, #1
 247 0250 083081E5 		str	r3, [r1, #8]
 142:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 248              		.loc 2 142 0
 249 0254 0830A0B3 		movlt	r3, #8
 143:i2c.c         **** 		}
 144:i2c.c         **** 		else {
 145:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 146:i2c.c         **** 			I2C1CONCLR = 0x0C; // Transmit NACK on next data receive, Clear SI
 250              		.loc 2 146 0
 251 0258 0C30A0A3 		movge	r3, #12
 252 025c 1830C2E5 		strb	r3, [r2, #24]
 253 0260 160000EA 		b	.L11
 254              	.L15:
 147:i2c.c         **** 		}
 148:i2c.c         **** 		break;
 149:i2c.c         **** 	case TW_MR_DATA_NACK: // Data byte has been received; NOT ACK has been returned.
 150:i2c.c         **** 		log_string_i2c("TW_MR_DATA_NACK\n");
 151:i2c.c         **** 		log_string_i2c("pos: ");
 152:i2c.c         **** 		log_int_i2c(buff_pos);
 153:i2c.c         **** 		log_string_i2c("\n");
 154:i2c.c         **** 		if (buff_pos < buff_size) {
 255              		.loc 2 154 0
 256 0264 70209FE5 		ldr	r2, .L20+4
 257 0268 0C0092E9 		ldmib	r2, {r2, r3}	@ phole ldm
 258 026c 020053E1 		cmp	r3, r2
 259 0270 060000AA 		bge	.L19
 155:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 260              		.loc 2 155 0
 261 0274 5C209FE5 		ldr	r2, .L20
 262 0278 0800D2E5 		ldrb	r0, [r2, #8]	@ zero_extendqisi2
 263 027c 58209FE5 		ldr	r2, .L20+4
 264 0280 0C1092E5 		ldr	r1, [r2, #12]
 265 0284 0300C1E7 		strb	r0, [r1, r3]
 266 0288 013083E2 		add	r3, r3, #1
 267 028c 083082E5 		str	r3, [r2, #8]
 268              	.L19:
 156:i2c.c         **** 		}
 157:i2c.c         **** 		I2C1CONSET = 0x10; // Transmit stop condition
 269              		.loc 2 157 0
 270 0290 40309FE5 		ldr	r3, .L20
 271 0294 1020A0E3 		mov	r2, #16
 272 0298 0020C3E5 		strb	r2, [r3, #0]
 158:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 273              		.loc 2 158 0
 274 029c 0820A0E3 		mov	r2, #8
 275 02a0 1820C3E5 		strb	r2, [r3, #24]
 159:i2c.c         **** 		busy = 0; // data ready to be returned
 276              		.loc 2 159 0
 277 02a4 0020A0E3 		mov	r2, #0
 278 02a8 2C309FE5 		ldr	r3, .L20+4
 279 02ac 102083E5 		str	r2, [r3, #16]
 160:i2c.c         **** 		break;
 280              		.loc 2 160 0
 281 02b0 020000EA 		b	.L11
 282              	.L7:
 161:i2c.c         **** 
 162:i2c.c         **** 	default:
 163:i2c.c         **** 		log_string_warning("[i2c] default: ");
 164:i2c.c         **** 		log_int_warning(temp);
 165:i2c.c         **** 		log_string_warning("\n");
 166:i2c.c         **** 		//I2C1CONSET = 0x10; // Transmit stop condition
 167:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 283              		.loc 2 167 0
 284 02b4 0820A0E3 		mov	r2, #8
 285 02b8 18309FE5 		ldr	r3, .L20
 286 02bc 1820C3E5 		strb	r2, [r3, #24]
 287              	.L11:
 168:i2c.c         **** 		//busy = 0; // data ready to be returned
 169:i2c.c         **** 		break;
 170:i2c.c         **** 	}
 171:i2c.c         **** 
 172:i2c.c         **** 	VICVectAddr = 0;
 288              		.loc 2 172 0
 289 02c0 0020A0E3 		mov	r2, #0
 290 02c4 0030E0E3 		mvn	r3, #0
 291 02c8 CF2F03E5 		str	r2, [r3, #-4047]
 173:i2c.c         **** }
 292              		.loc 2 173 0
 293 02cc 0CD08DE2 		add	sp, sp, #12
 294 02d0 0F10BDE8 		ldmfd	sp!, {r0, r1, r2, r3, ip}
 295 02d4 04F05EE2 		subs	pc, lr, #4
 296              	.L21:
 297              		.align	2
 298              	.L20:
 299 02d8 00C005E0 		.word	-536494080
 300 02dc 00000000 		.word	.LANCHOR0
 301              		.cfi_endproc
 302              	.LFE18:
 303              		.fnend
 305              		.align	2
 306              		.global	i2c_write_byte_isr
 308              	i2c_write_byte_isr:
 309              		.fnstart
 310              	.LFB21:
 174:i2c.c         **** 
 175:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 176:i2c.c         **** 	//      010 value to write
 177:i2c.c         **** 	// 76543210 bit numbers
 178:i2c.c         **** 	//    xxx   args: bitStart=4, length=3
 179:i2c.c         **** 	// 00011100 mask byte
 180:i2c.c         **** 	// 10101111 original value (sample)
 181:i2c.c         **** 	// 10100011 original & ~mask
 182:i2c.c         **** 	// 10101011 masked | value
 183:i2c.c         **** 
 184:i2c.c         **** 	char c;
 185:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 186:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 187:i2c.c         **** 	data <<= (bit - length + 1); // shift data into correct position
 188:i2c.c         **** 	data &= mask; // zero all non-important bits in data
 189:i2c.c         **** 	c &= ~(mask); // zero all important bits in existing byte
 190:i2c.c         **** 	c |= data; // combine data with existing byte
 191:i2c.c         **** 
 192:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 193:i2c.c         **** }
 194:i2c.c         **** 
 195:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 196:i2c.c         **** 	log_string_i2c("write_byte\n");
 197:i2c.c         **** 
 198:i2c.c         **** 	buff_size = 1;
 199:i2c.c         **** 	buff_pos = 0;
 200:i2c.c         **** 	ra_buff = reg_addr;
 201:i2c.c         **** 	c_buff = &data;
 202:i2c.c         **** 
 203:i2c.c         **** 	busy = 1;
 204:i2c.c         **** 
 205:i2c.c         **** 	//Setting the interrupt handler location for write byte
 206:i2c.c         **** 	VICVectAddr2 = (unsigned int) &i2c_write_byte_isr;
 207:i2c.c         **** 	//current_isr = &i2c_write_byte_isr;
 208:i2c.c         **** 	// Send Start bit
 209:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 210:i2c.c         **** 
 211:i2c.c         **** 	while (busy); // busy wait for read process
 212:i2c.c         **** 
 213:i2c.c         **** 	log_string_i2c("write_byte..returning\n");
 214:i2c.c         **** 	return 1;
 215:i2c.c         **** }
 216:i2c.c         **** 
 217:i2c.c         **** /**
 218:i2c.c         ****  * i2c interrupt handler
 219:i2c.c         ****  */
 220:i2c.c         **** void i2c_write_byte_isr(void) {
 311              		.loc 2 220 0
 312              		.cfi_startproc
 313              		@ Interrupt Service Routine.
 314              		@ args = 0, pretend = 0, frame = 8
 315              		@ frame_needed = 0, uses_anonymous_args = 0
 316              		@ link register save eliminated.
 317 02e0 0F002DE9 		stmfd	sp!, {r0, r1, r2, r3}
 318              		.save {r0, r1, r2, r3}
 319              	.LCFI2:
 320              		.cfi_def_cfa_offset 16
 321              		.pad #8
 322 02e4 08D04DE2 		sub	sp, sp, #8
 323              	.LCFI3:
 324              		.cfi_def_cfa_offset 24
 221:i2c.c         **** 	log_string_i2c(">> i2c_write_byte_isr\n");
 222:i2c.c         **** 	volatile int temp = 0;
 325              		.loc 2 222 0
 326 02e8 0030A0E3 		mov	r3, #0
 327              		.cfi_offset 3, -4
 328              		.cfi_offset 2, -8
 329              		.cfi_offset 1, -12
 330              		.cfi_offset 0, -16
 331 02ec 04308DE5 		str	r3, [sp, #4]
 332              	.LVL2:
 223:i2c.c         **** 	temp = I2C1STAT;
 333              		.loc 2 223 0
 334 02f0 98319FE5 		ldr	r3, .L30
 335 02f4 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 336 02f8 FF3003E2 		and	r3, r3, #255
 337 02fc 04308DE5 		str	r3, [sp, #4]
 224:i2c.c         **** 
 225:i2c.c         **** 	switch (temp) {
 338              		.loc 2 225 0
 339 0300 04309DE5 		ldr	r3, [sp, #4]
 340 0304 083043E2 		sub	r3, r3, #8
 341 0308 280053E3 		cmp	r3, #40
 342 030c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 343 0310 580000EA 		b	.L23
 344              	.L28:
 345 0314 B8030000 		.word	.L24
 346 0318 78040000 		.word	.L23
 347 031c 78040000 		.word	.L23
 348 0320 78040000 		.word	.L23
 349 0324 78040000 		.word	.L23
 350 0328 78040000 		.word	.L23
 351 032c 78040000 		.word	.L23
 352 0330 78040000 		.word	.L23
 353 0334 78040000 		.word	.L23
 354 0338 78040000 		.word	.L23
 355 033c 78040000 		.word	.L23
 356 0340 78040000 		.word	.L23
 357 0344 78040000 		.word	.L23
 358 0348 78040000 		.word	.L23
 359 034c 78040000 		.word	.L23
 360 0350 78040000 		.word	.L23
 361 0354 D0030000 		.word	.L25
 362 0358 78040000 		.word	.L23
 363 035c 78040000 		.word	.L23
 364 0360 78040000 		.word	.L23
 365 0364 78040000 		.word	.L23
 366 0368 78040000 		.word	.L23
 367 036c 78040000 		.word	.L23
 368 0370 78040000 		.word	.L23
 369 0374 78040000 		.word	.L23
 370 0378 78040000 		.word	.L23
 371 037c 78040000 		.word	.L23
 372 0380 78040000 		.word	.L23
 373 0384 78040000 		.word	.L23
 374 0388 78040000 		.word	.L23
 375 038c 78040000 		.word	.L23
 376 0390 78040000 		.word	.L23
 377 0394 EC030000 		.word	.L26
 378 0398 78040000 		.word	.L23
 379 039c 78040000 		.word	.L23
 380 03a0 78040000 		.word	.L23
 381 03a4 78040000 		.word	.L23
 382 03a8 78040000 		.word	.L23
 383 03ac 78040000 		.word	.L23
 384 03b0 78040000 		.word	.L23
 385 03b4 50040000 		.word	.L27
 386              	.L24:
 226:i2c.c         **** 	case TW_START: // A START condition has been transmitted.
 227:i2c.c         **** 		log_string_i2c("TW_START\n");
 228:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
 387              		.loc 2 228 0
 388 03b8 D0309FE5 		ldr	r3, .L30
 389 03bc 2F20E0E3 		mvn	r2, #47
 390 03c0 0820C3E5 		strb	r2, [r3, #8]
 229:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 391              		.loc 2 229 0
 392 03c4 2820A0E3 		mov	r2, #40
 393 03c8 1820C3E5 		strb	r2, [r3, #24]
 230:i2c.c         **** 		break;
 394              		.loc 2 230 0
 395 03cc 290000EA 		b	.L23
 396              	.L25:
 231:i2c.c         **** 	case TW_REP_START: // A repeated START	condition has been transmitted.
 232:i2c.c         **** 		log_string_i2c("TW_REP_START\n");
 233:i2c.c         **** 		break;
 234:i2c.c         **** 	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
 235:i2c.c         **** 		log_string_i2c("TW_MT_SLA_ACK\n");
 236:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 397              		.loc 2 236 0
 398 03d0 BC309FE5 		ldr	r3, .L30+4
 399 03d4 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 400 03d8 B0309FE5 		ldr	r3, .L30
 401 03dc 0820C3E5 		strb	r2, [r3, #8]
 237:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 402              		.loc 2 237 0
 403 03e0 0820A0E3 		mov	r2, #8
 404 03e4 1820C3E5 		strb	r2, [r3, #24]
 238:i2c.c         **** 		break;
 405              		.loc 2 238 0
 406 03e8 220000EA 		b	.L23
 407              	.L26:
 239:i2c.c         **** 	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
 240:i2c.c         **** 		log_string_i2c("TW_MT_SLA_NACK\n");
 241:i2c.c         **** 		break;
 242:i2c.c         **** 	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
 243:i2c.c         **** 		log_string_i2c("TW_MT_DATA_ACK\n");
 244:i2c.c         **** 		if (buff_pos < buff_size) {
 408              		.loc 2 244 0
 409 03ec A0209FE5 		ldr	r2, .L30+4
 410 03f0 0C0092E9 		ldmib	r2, {r2, r3}	@ phole ldm
 411 03f4 020053E1 		cmp	r3, r2
 412 03f8 090000AA 		bge	.L29
 245:i2c.c         **** 			I2C1DAT = c_buff[buff_pos++]; // Send data
 413              		.loc 2 245 0
 414 03fc 90109FE5 		ldr	r1, .L30+4
 415 0400 0C2091E5 		ldr	r2, [r1, #12]
 416 0404 0300D2E7 		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 417 0408 80209FE5 		ldr	r2, .L30
 418 040c 0800C2E5 		strb	r0, [r2, #8]
 419 0410 013083E2 		add	r3, r3, #1
 420 0414 083081E5 		str	r3, [r1, #8]
 246:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 421              		.loc 2 246 0
 422 0418 0830A0E3 		mov	r3, #8
 423 041c 1830C2E5 		strb	r3, [r2, #24]
 424 0420 140000EA 		b	.L23
 425              	.L29:
 247:i2c.c         **** 		} else {
 248:i2c.c         **** 			I2C1CONSET |= 0x01 << 4; // Transmit stop condition
 426              		.loc 2 248 0
 427 0424 64309FE5 		ldr	r3, .L30
 428 0428 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 429 042c FF2002E2 		and	r2, r2, #255
 430 0430 102082E3 		orr	r2, r2, #16
 431 0434 0020C3E5 		strb	r2, [r3, #0]
 249:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 432              		.loc 2 249 0
 433 0438 0820A0E3 		mov	r2, #8
 434 043c 1820C3E5 		strb	r2, [r3, #24]
 250:i2c.c         **** 			busy = 0; // done
 435              		.loc 2 250 0
 436 0440 0020A0E3 		mov	r2, #0
 437 0444 48309FE5 		ldr	r3, .L30+4
 438 0448 102083E5 		str	r2, [r3, #16]
 439 044c 090000EA 		b	.L23
 440              	.L27:
 251:i2c.c         **** 		}
 252:i2c.c         **** 		break;
 253:i2c.c         **** 	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
 254:i2c.c         **** 		log_string_i2c("TW_MT_DATA_NACK\n");
 255:i2c.c         **** 		I2C1CONSET |= 0x01 << 4; // Transmit stop condition
 441              		.loc 2 255 0
 442 0450 38309FE5 		ldr	r3, .L30
 443 0454 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 444 0458 FF2002E2 		and	r2, r2, #255
 445 045c 102082E3 		orr	r2, r2, #16
 446 0460 0020C3E5 		strb	r2, [r3, #0]
 256:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 447              		.loc 2 256 0
 448 0464 0820A0E3 		mov	r2, #8
 449 0468 1820C3E5 		strb	r2, [r3, #24]
 257:i2c.c         **** 		busy = 0; // done
 450              		.loc 2 257 0
 451 046c 0020A0E3 		mov	r2, #0
 452 0470 1C309FE5 		ldr	r3, .L30+4
 453 0474 102083E5 		str	r2, [r3, #16]
 454              	.L23:
 258:i2c.c         **** 		break;
 259:i2c.c         **** 	case TW_MT_ARB_LOST: // Arbitration lost in SLA+R/W or Data bytes.
 260:i2c.c         **** 		log_string_i2c("TW_MT_ARB_LOST\n");
 261:i2c.c         **** 		break;
 262:i2c.c         **** 
 263:i2c.c         **** 	default:
 264:i2c.c         **** 		log_string_i2c("default\n");
 265:i2c.c         **** 		break;
 266:i2c.c         **** 	}
 267:i2c.c         **** 
 268:i2c.c         **** 	VICVectAddr = 0;
 455              		.loc 2 268 0
 456 0478 0020A0E3 		mov	r2, #0
 457 047c 0030E0E3 		mvn	r3, #0
 458 0480 CF2F03E5 		str	r2, [r3, #-4047]
 269:i2c.c         **** }
 459              		.loc 2 269 0
 460 0484 08D08DE2 		add	sp, sp, #8
 461 0488 0F00BDE8 		ldmfd	sp!, {r0, r1, r2, r3}
 462 048c 04F05EE2 		subs	pc, lr, #4
 463              	.L31:
 464              		.align	2
 465              	.L30:
 466 0490 00C005E0 		.word	-536494080
 467 0494 00000000 		.word	.LANCHOR0
 468              		.cfi_endproc
 469              	.LFE21:
 470              		.fnend
 472              		.align	2
 473              		.global	protocol_in
 475              	protocol_in:
 476              		.fnstart
 477              	.LFB52:
 478              		.file 3 "bellator_low_level.c"
   1:bellator_low_level.c **** /**
   2:bellator_low_level.c ****  *
   3:bellator_low_level.c ****  *
   4:bellator_low_level.c ****  *
   5:bellator_low_level.c ****  */
   6:bellator_low_level.c **** /* global defines */
   7:bellator_low_level.c **** #define CRYSTAL12MHz
   8:bellator_low_level.c **** //#define CRYSTAL14745600Hz
   9:bellator_low_level.c **** #define CMD_BUFF_SIZE 32 // has to be a power of two
  10:bellator_low_level.c **** #define DATA_BUFF_SIZE 16 // has to be a power of two
  11:bellator_low_level.c **** 
  12:bellator_low_level.c **** #define SAMPLE_RATE_1kHZ 0;
  13:bellator_low_level.c **** #define SAMPLE_RATE_500HZ 1;
  14:bellator_low_level.c **** #define SAMPLE_RATE_250HZ 2;
  15:bellator_low_level.c **** #define SAMPLE_RATE_125HZ 4;
  16:bellator_low_level.c **** #define SAMPLE_RATE_012HZ 4096;
  17:bellator_low_level.c **** 
  18:bellator_low_level.c **** #define SAMPLE_RATE SAMPLE_RATE_125HZ
  19:bellator_low_level.c **** 
  20:bellator_low_level.c **** //#define ERROR
  21:bellator_low_level.c **** //#define WARNING
  22:bellator_low_level.c **** //#define DEBUG
  23:bellator_low_level.c **** //#define DEBUG_I2C
  24:bellator_low_level.c **** //#define DEBUG_MPU
  25:bellator_low_level.c **** 
  26:bellator_low_level.c **** #define IENABLE \
  27:bellator_low_level.c **** 		asm volatile ( "MRS		LR, SPSR" 		); /* copy SPSR_irq to LR */ \
  28:bellator_low_level.c **** 		asm volatile ( "STMFD	SP!, {LR}"		); /* save SPSR_irq */ \
  29:bellator_low_level.c **** 		asm volatile ( "MSR		CPSR_c, #0x1F"	); /* enable IRQ */ \
  30:bellator_low_level.c **** 		asm volatile ( "STMFD	SP!, {LR}"		); /* save LR */ \
  31:bellator_low_level.c **** 
  32:bellator_low_level.c **** #define IDISABLE \
  33:bellator_low_level.c **** 		asm volatile ( "LDMFD	SP!, {LR}" 		); /* restore LR */ \
  34:bellator_low_level.c **** 		asm volatile ( "MSR		CPSR_c, #0x92"	); /* disable IRQ */ \
  35:bellator_low_level.c **** 		asm volatile ( "LDMFD	SP!, {LR}"		); /* Restore SPSR_irq to LR */ \
  36:bellator_low_level.c **** 		asm volatile ( "MSR		SPSR_cxsf, LR"	); /* copy LR to SPSR_irq */ \
  37:bellator_low_level.c **** 
  38:bellator_low_level.c **** 
  39:bellator_low_level.c **** /* includes */
  40:bellator_low_level.c **** #include "lpc2103.h"
  41:bellator_low_level.c **** #include "logger.h"
  42:bellator_low_level.c **** #include "logger.c"
  43:bellator_low_level.c **** #include "irq.h"
  44:bellator_low_level.c **** #include "irq.c"
  45:bellator_low_level.c **** #include "i2c.h"
  46:bellator_low_level.c **** #include "i2c.c"
  47:bellator_low_level.c **** #include "protocol.h"
  48:bellator_low_level.c **** #include "mpu6050.h"
  49:bellator_low_level.c **** #include "mpu6050.c"
  50:bellator_low_level.c **** 
  51:bellator_low_level.c **** /* interruptions */
  52:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) pulse_in(void);
  53:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) protocol_in(void);
  54:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) sample(void);
  55:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) error(void);
  56:bellator_low_level.c **** 
  57:bellator_low_level.c **** 
  58:bellator_low_level.c **** /* init functions */
  59:bellator_low_level.c **** inline void PLL_Init(void);
  60:bellator_low_level.c **** inline void MAM_Init(void);
  61:bellator_low_level.c **** inline void APB_Init(void);
  62:bellator_low_level.c **** 
  63:bellator_low_level.c **** inline void pulses_in_init(void);
  64:bellator_low_level.c **** inline void imu_init(void);
  65:bellator_low_level.c **** inline void adc_init(void);
  66:bellator_low_level.c **** inline void pwm_out_init(void);
  67:bellator_low_level.c **** static inline void protocol_init(void);
  68:bellator_low_level.c **** inline void sampler_init(void);
  69:bellator_low_level.c **** 
  70:bellator_low_level.c **** /* getters and setters */
  71:bellator_low_level.c **** void get_ir_sensor_data(char * buff);
  72:bellator_low_level.c **** void get_encoders_count(short * left_encoder, short * right_encoder);
  73:bellator_low_level.c **** inline void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel);
  74:bellator_low_level.c **** 
  75:bellator_low_level.c **** /* auxiliary functions */
  76:bellator_low_level.c **** static inline void protocol_out_cmd(void);
  77:bellator_low_level.c **** static inline void protocol_out_char(char c);
  78:bellator_low_level.c **** 
  79:bellator_low_level.c **** /* data structs defenitions */
  80:bellator_low_level.c **** struct cmd_buff {
  81:bellator_low_level.c ****   unsigned int i;
  82:bellator_low_level.c ****   char buff [CMD_BUFF_SIZE];      // Circular Buffer
  83:bellator_low_level.c **** };
  84:bellator_low_level.c **** 
  85:bellator_low_level.c **** struct sensors_data {
  86:bellator_low_level.c **** 	short encoder_left, encoder_right;
  87:bellator_low_level.c **** 	char ir_r, ir_mr, ir_m, ir_ml, ir_l;
  88:bellator_low_level.c **** 	char ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l;
  89:bellator_low_level.c **** 	unsigned short timestamp;
  90:bellator_low_level.c **** };
  91:bellator_low_level.c **** 
  92:bellator_low_level.c **** /* global variables */
  93:bellator_low_level.c **** static struct cmd_buff cmd_out = { 0, };
  94:bellator_low_level.c **** static struct cmd_buff cmd_in = { 0, };
  95:bellator_low_level.c **** static volatile int encoder_count[2] = { 0, 0};
  96:bellator_low_level.c **** static int sent_encoder_count[2] = { 0, 0};
  97:bellator_low_level.c **** static int forward_r = 0, forward_l = 0;
  98:bellator_low_level.c **** static unsigned volatile char send_data = 0;
  99:bellator_low_level.c **** static struct sensors_data sensors_data_buff[DATA_BUFF_SIZE]; // Circular Buffer
 100:bellator_low_level.c **** static unsigned volatile short data_in_pos = 0; // last valid data in
 101:bellator_low_level.c **** static unsigned volatile short data_out_pos = 0; // last data sent
 102:bellator_low_level.c **** static unsigned short timestamp = 0;
 103:bellator_low_level.c **** 
 104:bellator_low_level.c **** /**
 105:bellator_low_level.c ****  * Entry point
 106:bellator_low_level.c ****  */
 107:bellator_low_level.c **** int main(void){
 108:bellator_low_level.c **** 
 109:bellator_low_level.c **** 	PLL_Init(); // Turn on PLL clock
 110:bellator_low_level.c **** 	MAM_Init(); // Turn on MAM pre-fetcher
 111:bellator_low_level.c **** 	APB_Init(); // Turn on the peripheral devices clock divider
 112:bellator_low_level.c **** 
 113:bellator_low_level.c **** 	logger_init(); // uart0
 114:bellator_low_level.c **** 	log_string_debug("iniciando\n");
 115:bellator_low_level.c **** 
 116:bellator_low_level.c **** 	enableIRQ(); // Enable interruptions
 117:bellator_low_level.c **** 	//enableFIQ();
 118:bellator_low_level.c **** 
 119:bellator_low_level.c **** 	pulses_in_init(); // start counting pulses from the encoder	| Timer 2, FIQ, eint0, FIQ
 120:bellator_low_level.c **** 	imu_init(); // start the IMU								| i2c1 FIQ
 121:bellator_low_level.c **** 	adc_init(); // start reading the IR sensor signals			| Burst mode, no interruption
 122:bellator_low_level.c **** 	pwm_out_init(); // start pwm for the H bridges				| Timer 0 and Timer 1 operating in PWM mode, no 
 123:bellator_low_level.c **** 	protocol_init(); // start the communication protocol		| uart1, Priority 2
 124:bellator_low_level.c **** 	sampler_init(); // start taking samples at 1kHz				| Timer 3, 1kH, Priority 1
 125:bellator_low_level.c **** 
 126:bellator_low_level.c **** 	VICDefVectAddr = (unsigned int) &error;
 127:bellator_low_level.c **** 
 128:bellator_low_level.c **** 	//set_wheel_pwm(RIGHT_WHEEL,0x7F);
 129:bellator_low_level.c **** 	//set_wheel_pwm(LEFT_WHEEL,0x7F);
 130:bellator_low_level.c **** 
 131:bellator_low_level.c **** 	while (1) {
 132:bellator_low_level.c **** 		if (send_data) {
 133:bellator_low_level.c **** 			// while data available
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 135:bellator_low_level.c **** 
 136:bellator_low_level.c **** 				log_string_debug("sending data");
 137:bellator_low_level.c **** 				// send next data
 138:bellator_low_level.c **** 				data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 139:bellator_low_level.c **** 
 140:bellator_low_level.c **** 				struct sensors_data* data;
 141:bellator_low_level.c **** 				data = &(sensors_data_buff[data_out_pos]);
 142:bellator_low_level.c **** 
 143:bellator_low_level.c **** 				// encoders
 144:bellator_low_level.c **** 				cmd_out.buff[0] = (data->encoder_left >> 0x8) & 0xFF;
 145:bellator_low_level.c **** 				cmd_out.buff[1] = data->encoder_left & 0xFF;
 146:bellator_low_level.c **** 				cmd_out.buff[2] = (data->encoder_right >> 0x8) & 0xFF;
 147:bellator_low_level.c **** 				cmd_out.buff[3] = data->encoder_right & 0xFF;
 148:bellator_low_level.c **** 
 149:bellator_low_level.c **** 				// Infra Red
 150:bellator_low_level.c **** 				cmd_out.buff[4] = data->ir_l;
 151:bellator_low_level.c **** 				cmd_out.buff[5] = data->ir_ml;
 152:bellator_low_level.c **** 				cmd_out.buff[6] = data->ir_m;
 153:bellator_low_level.c **** 				cmd_out.buff[7] = data->ir_mr;
 154:bellator_low_level.c **** 				cmd_out.buff[8] = data->ir_r;
 155:bellator_low_level.c **** 
 156:bellator_low_level.c **** 				// IMU data
 157:bellator_low_level.c **** 				cmd_out.buff[9] = data->ax_h;
 158:bellator_low_level.c **** 				cmd_out.buff[10] = data->ax_l;
 159:bellator_low_level.c **** 				cmd_out.buff[11] = data->ay_h;
 160:bellator_low_level.c **** 				cmd_out.buff[12] = data->ay_l;
 161:bellator_low_level.c **** 				cmd_out.buff[13] = data->az_h;
 162:bellator_low_level.c **** 				cmd_out.buff[14] = data->az_l;
 163:bellator_low_level.c **** 				cmd_out.buff[15] = data->gx_h;
 164:bellator_low_level.c **** 				cmd_out.buff[16] = data->gx_l;
 165:bellator_low_level.c **** 				cmd_out.buff[17] = data->gy_h;
 166:bellator_low_level.c **** 				cmd_out.buff[18] = data->gy_l;
 167:bellator_low_level.c **** 				cmd_out.buff[19] = data->gz_h;
 168:bellator_low_level.c **** 				cmd_out.buff[20] = data->gz_l;
 169:bellator_low_level.c **** 
 170:bellator_low_level.c **** 				// Timestamp
 171:bellator_low_level.c **** 				cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 172:bellator_low_level.c **** 				cmd_out.buff[22] = data->timestamp & 0xFF;
 173:bellator_low_level.c **** 
 174:bellator_low_level.c **** 				// end cmd
 175:bellator_low_level.c **** 				cmd_out.buff[23] = END_CMD;
 176:bellator_low_level.c **** 				cmd_out.buff[24] = '\n';
 177:bellator_low_level.c **** 				cmd_out.i = 25;
 178:bellator_low_level.c **** 
 179:bellator_low_level.c **** 				protocol_out_cmd();
 180:bellator_low_level.c **** 			}
 181:bellator_low_level.c **** 
 182:bellator_low_level.c **** 			send_data = 0;
 183:bellator_low_level.c **** 		}
 184:bellator_low_level.c **** 	}
 185:bellator_low_level.c **** 
 186:bellator_low_level.c **** 	return 0;
 187:bellator_low_level.c **** }
 188:bellator_low_level.c **** 
 189:bellator_low_level.c **** /**
 190:bellator_low_level.c ****  * Sets the processor clock
 191:bellator_low_level.c ****  *
 192:bellator_low_level.c ****  * Fosc = External oscilator =	12MHz | 14.7456MHz
 193:bellator_low_level.c ****  * CCLK = PLL Clock output =	60MHz | 58.9824MHz  (desired system clock)
 194:bellator_low_level.c ****  * MSEL = Clock multiplier =	4	  | 3			(MSEL = CCLK/Fosc -1)
 195:bellator_low_level.c ****  * PSEL = Clock divider = 		1	  | 1			(P | 156MHz < Fcco < 320MHz, Fcco = CCLK * 2 * P)
 196:bellator_low_level.c ****  * 													(P=1 -> PSEL=00, P=2 -> PSEL=01, P=4 -> PSEL=10, P=8 -> PSEL=11)
 197:bellator_low_level.c ****  */
 198:bellator_low_level.c **** inline void PLL_Init(void){
 199:bellator_low_level.c **** 
 200:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 201:bellator_low_level.c **** 	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 202:bellator_low_level.c **** #endif
 203:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 204:bellator_low_level.c **** 	PLLCFG=0x23;                // 14.7456MHz crystal -> 58.9824MHz
 205:bellator_low_level.c **** #endif
 206:bellator_low_level.c **** 
 207:bellator_low_level.c **** 	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 208:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 209:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 210:bellator_low_level.c **** 	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 211:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 212:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 213:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 214:bellator_low_level.c **** }
 215:bellator_low_level.c **** 
 216:bellator_low_level.c **** /**
 217:bellator_low_level.c ****  * Starts the Memory Acceleration Module
 218:bellator_low_level.c ****  * System clock
 219:bellator_low_level.c ****  * < 20MHz         -> MAMTIM = 1 CCLK
 220:bellator_low_level.c ****  * 20MHz to 40MHz  -> MAMTIM = 2 CCLK
 221:bellator_low_level.c ****  * 40MHz to 60MHz  -> MAMTIM = 3 CCLK
 222:bellator_low_level.c ****  * > 60MHz         -> MAMTIM = 4 CCLK
 223:bellator_low_level.c ****  */
 224:bellator_low_level.c **** inline void MAM_Init(void){
 225:bellator_low_level.c **** 
 226:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 227:bellator_low_level.c **** 	MAMTIM = 4; // 4 clock fetches
 228:bellator_low_level.c **** #endif
 229:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 230:bellator_low_level.c **** 	MAMTIM = 3; // 3 clock fetches
 231:bellator_low_level.c **** #endif
 232:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 233:bellator_low_level.c **** }
 234:bellator_low_level.c **** 
 235:bellator_low_level.c **** /**
 236:bellator_low_level.c ****  * Configure the peripheral devices clock divider
 237:bellator_low_level.c ****  * for PCLK = CCLK/4
 238:bellator_low_level.c ****  */
 239:bellator_low_level.c **** inline void APB_Init(void){
 240:bellator_low_level.c **** 	// peripheral clock = PCLK = CCLK/4
 241:bellator_low_level.c **** 	//APBDIV |= 0x02;
 242:bellator_low_level.c **** 	APBDIV &= ~0x03;
 243:bellator_low_level.c **** }
 244:bellator_low_level.c **** 
 245:bellator_low_level.c **** /**
 246:bellator_low_level.c ****  * Timer 2, capture pins generating FIQs for event counter
 247:bellator_low_level.c ****  * The timer has no function, except for the interrupt generation.
 248:bellator_low_level.c ****  * and EINT0 also generating FIQs for event counter
 249:bellator_low_level.c ****  * CAP20 - Left encoder
 250:bellator_low_level.c ****  * CAP21 - Left encoder
 251:bellator_low_level.c ****  * CAP22 - Right encoder
 252:bellator_low_level.c ****  * EINT0 - Right encoder
 253:bellator_low_level.c ****  */
 254:bellator_low_level.c **** inline void pulses_in_init(void){
 255:bellator_low_level.c **** 
 256:bellator_low_level.c **** 	log_string_debug(">> pulses_in_init\n");
 257:bellator_low_level.c **** 
 258:bellator_low_level.c **** 	// Set the pin function
 259:bellator_low_level.c **** 	PINSEL1 |= 0x1 << 0;  // EINT0
 260:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 261:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 24; // CAP2.1
 262:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 26; // CAP2.2
 263:bellator_low_level.c **** 
 264:bellator_low_level.c **** 	// EINT setup
 265:bellator_low_level.c **** 	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
 266:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
 267:bellator_low_level.c **** 	EXTINT |= 0x1 << 0; // reset EINT0
 268:bellator_low_level.c **** 
 269:bellator_low_level.c **** 	// Timer Setup
 270:bellator_low_level.c **** 	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
 271:bellator_low_level.c **** 	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
 272:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 273:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 274:bellator_low_level.c **** 
 275:bellator_low_level.c **** 	// Enable the interrupts
 276:bellator_low_level.c **** 	//VICIntSelect |= 0x1 << 14;// EINT2 as FIQ
 277:bellator_low_level.c **** 	VICVectAddr6 = (unsigned int) &pulse_in;
 278:bellator_low_level.c **** 	VICVectCntl6 = 0x2E; // source 14 and enabled
 279:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
 280:bellator_low_level.c **** 
 281:bellator_low_level.c **** 	//VICIntSelect |= 0x1 << 26;// Timer 2 as FIQ
 282:bellator_low_level.c **** 	VICVectAddr7 = (unsigned int) &pulse_in;
 283:bellator_low_level.c **** 	VICVectCntl7 = 0x3A; // source 26 and enabled
 284:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
 285:bellator_low_level.c **** 
 286:bellator_low_level.c **** 	log_string_debug("<< pulses_in_init\n");
 287:bellator_low_level.c **** }
 288:bellator_low_level.c **** 
 289:bellator_low_level.c **** /**
 290:bellator_low_level.c ****  * Start i2c communication
 291:bellator_low_level.c ****  * Configure MPU
 292:bellator_low_level.c ****  * Setup eint2 with priority 1 for data ready interrupt
 293:bellator_low_level.c ****  */
 294:bellator_low_level.c **** inline void imu_init(void){
 295:bellator_low_level.c **** 
 296:bellator_low_level.c **** 	log_string_debug(">> imu_init\n");
 297:bellator_low_level.c **** 
 298:bellator_low_level.c **** 	// start the communication with the IMU
 299:bellator_low_level.c **** 	i2c_init();
 300:bellator_low_level.c **** 
 301:bellator_low_level.c **** 	// configure mpu and start taking samples
 302:bellator_low_level.c **** 	mpu_init();
 303:bellator_low_level.c **** 
 304:bellator_low_level.c **** 	// DATA READY INTERRUPT WAS NOT USED
 305:bellator_low_level.c **** 	// Configure data ready interrupt
 306:bellator_low_level.c **** 	// Set the pin function
 307:bellator_low_level.c **** 	//PINSEL0 |= 0x1 << 30;  // EINT2
 308:bellator_low_level.c **** 
 309:bellator_low_level.c **** 	// EINT setup
 310:bellator_low_level.c **** 	//EXTMODE |= 0x1 << 2; // EINT2 is edge sensitive
 311:bellator_low_level.c **** 	//EXTPOLAR |= 0x1 << 2; // EINT2 is rising edge sensitive
 312:bellator_low_level.c **** 	//EXTINT |= 0x1 << 2; // reset EINT2
 313:bellator_low_level.c **** 
 314:bellator_low_level.c **** 	//VICVectAddr1 = (unsigned int) &imu_data_ready; //Setting the interrupt handler location
 315:bellator_low_level.c **** 	//VICVectCntl1 = 0x30; //Vectored Interrupt slot enabled with source #16 (EINT2)
 316:bellator_low_level.c **** 	//VICIntEnable |= 0x1 << 16; //source #16 enabled as FIQ or IRQ
 317:bellator_low_level.c **** 
 318:bellator_low_level.c **** 	log_string_debug("<< imu_init\n");
 319:bellator_low_level.c **** }
 320:bellator_low_level.c **** 
 321:bellator_low_level.c **** /**
 322:bellator_low_level.c ****  * ADC0 Configured in BURST mode
 323:bellator_low_level.c ****  */
 324:bellator_low_level.c **** inline void adc_init(void){
 325:bellator_low_level.c **** 
 326:bellator_low_level.c **** 	log_string_debug(">> adc_init\n");
 327:bellator_low_level.c **** 
 328:bellator_low_level.c **** 	// Set the pin function
 329:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 12; // AD0.0
 330:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 14; // AD0.1
 331:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 16; // AD0.2
 332:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 20; // AD0.3
 333:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 22; // AD0.4
 334:bellator_low_level.c **** 
 335:bellator_low_level.c **** 	// ADC setup
 336:bellator_low_level.c **** 	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
 337:bellator_low_level.c **** 	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
 338:bellator_low_level.c **** 	ADCR |= 0x1F; // Read AD0.0 - AD0.4
 339:bellator_low_level.c **** 	ADCR |= 0x01 << 21; // The ADC is operational
 340:bellator_low_level.c **** 
 341:bellator_low_level.c **** 	log_string_debug("<< adc_init\n");
 342:bellator_low_level.c **** }
 343:bellator_low_level.c **** 
 344:bellator_low_level.c **** /**
 345:bellator_low_level.c ****  * Timer 0,1, 200Hz, at least 76 levels to comply with the old version
 346:bellator_low_level.c ****  * Timer 0 -> left wheel
 347:bellator_low_level.c ****  * Timer 1 -> right wheel
 348:bellator_low_level.c ****  * PCLK = 15MHz or 14.7456MHz
 349:bellator_low_level.c ****  */
 350:bellator_low_level.c **** inline void pwm_out_init(void){
 351:bellator_low_level.c **** 
 352:bellator_low_level.c **** 	log_string_debug(">> pwm_out_init\n");
 353:bellator_low_level.c **** 
 354:bellator_low_level.c **** 	// Set the pin function
 355:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 6;  // MAT0.0
 356:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 10; // MAT0.1
 357:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 24; // MAT1.0
 358:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 26; // MAT1.1
 359:bellator_low_level.c **** 
 360:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 361:bellator_low_level.c **** 	T0PR = 293; // 255 levels for T2TC in 5ms
 362:bellator_low_level.c **** 	T1PR = 293; // TC increments every PR + 1 PCLKs
 363:bellator_low_level.c **** #endif
 364:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 365:bellator_low_level.c **** 	T0PR = 288; // 255 levels for T2TC in 5ms
 366:bellator_low_level.c **** 	T1PR = 288;
 367:bellator_low_level.c **** #endif
 368:bellator_low_level.c **** 
 369:bellator_low_level.c **** 	T0PC = 0; // Prescale = 0
 370:bellator_low_level.c **** 	T1PC = 0;
 371:bellator_low_level.c **** 	T0TC = 0; // Counter = 0
 372:bellator_low_level.c **** 	T1TC = 0;
 373:bellator_low_level.c **** 
 374:bellator_low_level.c **** 	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
 375:bellator_low_level.c **** 	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
 376:bellator_low_level.c **** 	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
 377:bellator_low_level.c **** 	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
 378:bellator_low_level.c **** 
 379:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
 380:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
 381:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
 382:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
 383:bellator_low_level.c **** 
 384:bellator_low_level.c **** 	T0MR0 = 256; // initially LOW
 385:bellator_low_level.c **** 	T0MR1 = 256; // initially LOW
 386:bellator_low_level.c **** 	T1MR0 = 256; // initially LOW
 387:bellator_low_level.c **** 	T1MR1 = 256; // initially LOW
 388:bellator_low_level.c **** 
 389:bellator_low_level.c **** 	T0TCR = 1; // enable T0
 390:bellator_low_level.c **** 	T1TCR = 1; // enable T1
 391:bellator_low_level.c **** 
 392:bellator_low_level.c **** 	log_string_debug("<< pwm_out_init\n");
 393:bellator_low_level.c **** }
 394:bellator_low_level.c **** 
 395:bellator_low_level.c **** /**
 396:bellator_low_level.c ****  * Set up the protocol using UART1 to communicate with TS-7260
 397:bellator_low_level.c ****  *
 398:bellator_low_level.c ****  * 8N1 (8 data, Non parity, 1 stop)
 399:bellator_low_level.c ****  * 115200 bps
 400:bellator_low_level.c ****  *
 401:bellator_low_level.c ****  * UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL) * ( 1 + DivAddVal/MulVal))
 402:bellator_low_level.c ****  * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
 403:bellator_low_level.c ****  * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
 404:bellator_low_level.c ****  * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
 405:bellator_low_level.c ****  *
 406:bellator_low_level.c ****  * Set UART1 interrupt to the second slot in the vectored interrupts.
 407:bellator_low_level.c ****  */
 408:bellator_low_level.c **** static inline void protocol_init(void){
 409:bellator_low_level.c **** 
 410:bellator_low_level.c **** 	log_string_debug(">> protocol_init\n");
 411:bellator_low_level.c **** 
 412:bellator_low_level.c **** 	volatile char dummy;
 413:bellator_low_level.c **** 
 414:bellator_low_level.c **** 	PINSEL0 |= 0x05 << 16; // Set the pins function
 415:bellator_low_level.c **** 	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 416:bellator_low_level.c **** 	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 417:bellator_low_level.c **** 
 418:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 419:bellator_low_level.c **** 	U1DLL	 = 0x06; // DivisorLatchLow bit
 420:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 421:bellator_low_level.c **** 	U1FDR	|= 0x05; // DivAddVal
 422:bellator_low_level.c **** 	U1FDR	|= 0x0E << 4; // MulVal = 14
 423:bellator_low_level.c **** #endif
 424:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 425:bellator_low_level.c **** 	U1DLL	 = 0x08; // DivisorLatchLow bit
 426:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 427:bellator_low_level.c **** #endif
 428:bellator_low_level.c **** 
 429:bellator_low_level.c **** 	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 430:bellator_low_level.c **** 
 431:bellator_low_level.c **** 	VICVectAddr4 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 432:bellator_low_level.c **** 	VICVectCntl4 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 433:bellator_low_level.c **** 	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 434:bellator_low_level.c **** 
 435:bellator_low_level.c **** 	cmd_out.i = 0;
 436:bellator_low_level.c **** 	cmd_in.i = 0;
 437:bellator_low_level.c **** 
 438:bellator_low_level.c **** 	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 439:bellator_low_level.c **** 	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
 440:bellator_low_level.c **** 
 441:bellator_low_level.c **** 	log_string_debug("<< protocol_init\n");
 442:bellator_low_level.c **** }
 443:bellator_low_level.c **** 
 444:bellator_low_level.c **** /**
 445:bellator_low_level.c ****  * PCLK = 15MHz or 14.7456MHz
 446:bellator_low_level.c ****  */
 447:bellator_low_level.c **** inline void sampler_init(void){
 448:bellator_low_level.c **** 	log_string_debug(">> sampler_init\n");
 449:bellator_low_level.c **** 
 450:bellator_low_level.c **** 	// set pre scale for sample rate
 451:bellator_low_level.c **** 	T3PR = SAMPLE_RATE; // Increment the timer every PCLK
 452:bellator_low_level.c **** 
 453:bellator_low_level.c **** 	T3PC = 0;
 454:bellator_low_level.c **** 	T3TC = 0; // Counter = 0
 455:bellator_low_level.c **** 
 456:bellator_low_level.c **** 	T3MCR |= (0x1 << 0); // Interrupt on MAT3.0
 457:bellator_low_level.c **** 	T3MCR |= (0x1 << 1); // Reset the counter on MAT3.0
 458:bellator_low_level.c **** 
 459:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 460:bellator_low_level.c **** 	T3MR0 = 15000; // MAT3.0 every 15000/(SAMPLE_RATE + 1) counts (1ms/(SAMPLE_RATE + 1))
 461:bellator_low_level.c **** #endif
 462:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 463:bellator_low_level.c **** 	T3MR0 = 14746; // MAT3.0 every 14746/(SAMPLE_RATE + 1) counts (1.000027127ms/(SAMPLE_RATE + 1))
 464:bellator_low_level.c **** #endif
 465:bellator_low_level.c **** 
 466:bellator_low_level.c **** 	VICVectAddr3 = (unsigned int) &sample; //Setting the interrupt handler location
 467:bellator_low_level.c **** 	VICVectCntl3 = 0x3B; //Vectored Interrupt slot enabled and with source #27 (TIMER3)
 468:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 27; //source #27 enabled as FIQ or IRQ
 469:bellator_low_level.c **** 
 470:bellator_low_level.c **** 	T3TCR = 1; // enable T3
 471:bellator_low_level.c **** 
 472:bellator_low_level.c **** 	log_string_debug("<< sampler_init\n");
 473:bellator_low_level.c **** }
 474:bellator_low_level.c **** 
 475:bellator_low_level.c **** /**
 476:bellator_low_level.c ****  * Communication Protocol state machine implementation;
 477:bellator_low_level.c ****  * This is triggered on uart1 interruption
 478:bellator_low_level.c ****  * This handles the following commands
 479:bellator_low_level.c ****  *
 480:bellator_low_level.c ****  */
 481:bellator_low_level.c **** void protocol_in(void){
 479              		.loc 3 481 0
 480              		.cfi_startproc
 481              		@ Interrupt Service Routine.
 482              		@ args = 0, pretend = 0, frame = 8
 483              		@ frame_needed = 0, uses_anonymous_args = 0
 484              		@ link register save eliminated.
 485 0498 FF1F2DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 486              		.save {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 487              	.LCFI4:
 488              		.cfi_def_cfa_offset 52
 489              		.pad #12
 490 049c 0CD04DE2 		sub	sp, sp, #12
 491              	.LCFI5:
 492              		.cfi_def_cfa_offset 64
 493              	.LBB41:
 494              	.LBB43:
 482:bellator_low_level.c **** 
 483:bellator_low_level.c **** 	log_string_debug(">> protocol_in\n");
 484:bellator_low_level.c **** 
 485:bellator_low_level.c **** 	volatile char dummy;
 486:bellator_low_level.c **** 	volatile char iir;
 487:bellator_low_level.c **** 
 488:bellator_low_level.c **** 	// Repeat while there is at least one interrupt source.
 489:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 490:bellator_low_level.c **** 		switch (iir & 0x0E) {
 491:bellator_low_level.c **** 		case 0x06: // Receive Line Status
 492:bellator_low_level.c **** 			dummy = U1LSR; // Just clear the interrupt source
 493:bellator_low_level.c **** 			break;
 494:bellator_low_level.c **** 
 495:bellator_low_level.c **** 		case 0x04: // Receive Data Available
 496:bellator_low_level.c **** 		case 0x0C: // Character Time-Out
 497:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 495              		.loc 3 497 0
 496 04a0 E4319FE5 		ldr	r3, .L53
 497              		.cfi_offset 12, -4
 498              		.cfi_offset 11, -8
 499              		.cfi_offset 10, -12
 500              		.cfi_offset 9, -16
 501              		.cfi_offset 8, -20
 502              		.cfi_offset 7, -24
 503              		.cfi_offset 6, -28
 504              		.cfi_offset 5, -32
 505              		.cfi_offset 4, -36
 506              		.cfi_offset 3, -40
 507              		.cfi_offset 2, -44
 508              		.cfi_offset 1, -48
 509              		.cfi_offset 0, -52
 498:bellator_low_level.c **** 
 499:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 500:bellator_low_level.c **** 				// ENGINES
 501:bellator_low_level.c **** 				if (cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] == ENGINES) {
 502:bellator_low_level.c **** 					log_string_debug("ENGINES\n");
 503:bellator_low_level.c **** 
 504:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)]),
 505:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]));
 506:bellator_low_level.c **** 
 507:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] = 0;
 508:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] = 0;
 509:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
 510:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)] = 0;
 511:bellator_low_level.c **** 				}
 512:bellator_low_level.c **** 				// SYNC
 513:bellator_low_level.c **** 				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
 514:bellator_low_level.c **** 					log_string_debug("SYNC\n");
 515:bellator_low_level.c **** 
 516:bellator_low_level.c **** 					send_data = 1;
 517:bellator_low_level.c **** 
 518:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
 519:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)] = 0;
 520:bellator_low_level.c **** 				}
 521:bellator_low_level.c **** 			}
 522:bellator_low_level.c **** 
 523:bellator_low_level.c **** 			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
 524:bellator_low_level.c **** 			break;
 525:bellator_low_level.c **** 
 526:bellator_low_level.c **** 		case 0x02: // THRE Interrupt, transmit interrupt
 527:bellator_low_level.c **** 			U1THR = dummy; // Just clear the interrupt source
 528:bellator_low_level.c **** 			break;
 529:bellator_low_level.c **** 
 530:bellator_low_level.c **** 		case 0x00: // Modem Interrupt
 531:bellator_low_level.c **** 			dummy = U1MSR; // Just clear the interrupt source
 532:bellator_low_level.c **** 			break;
 533:bellator_low_level.c **** 
 534:bellator_low_level.c **** 		default:
 535:bellator_low_level.c **** 			break;
 536:bellator_low_level.c **** 		}
 537:bellator_low_level.c **** 	}
 538:bellator_low_level.c **** 
 539:bellator_low_level.c **** 	log_string_debug("<< protocol_in\n");
 540:bellator_low_level.c **** 
 541:bellator_low_level.c **** 	VICVectAddr = 0;
 542:bellator_low_level.c **** }
 543:bellator_low_level.c **** 
 544:bellator_low_level.c **** /**
 545:bellator_low_level.c ****  * Hall the FIQ interrupts shoul be handled as fast as possible.
 546:bellator_low_level.c ****  *
 547:bellator_low_level.c ****  * Count the encoder pulses using CAP2.0-2 and EINT0 as interrupt sources
 548:bellator_low_level.c ****  *
 549:bellator_low_level.c ****  * Handle i2c requests
 550:bellator_low_level.c ****  */
 551:bellator_low_level.c **** void pulse_in(void) {
 552:bellator_low_level.c **** 
 553:bellator_low_level.c **** 	//log_string_debug(">> pulse_in\n");
 554:bellator_low_level.c **** 
 555:bellator_low_level.c **** 	volatile unsigned short ir = T2IR;
 556:bellator_low_level.c **** 
 557:bellator_low_level.c **** 	// pulses in int
 558:bellator_low_level.c **** 	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
 559:bellator_low_level.c **** 		//log_string_debug("FIQ2\n");
 560:bellator_low_level.c **** 		forward_l--;
 561:bellator_low_level.c **** 		T2IR |= 0x1 << 4; // reset CAP2.0
 562:bellator_low_level.c **** 	}
 563:bellator_low_level.c **** 	else if (ir & (0x1 << 5)) { //CAP2.1 right encoder
 564:bellator_low_level.c **** 		//log_string_debug("FIQ3\n");
 565:bellator_low_level.c **** 		forward_r++;
 566:bellator_low_level.c **** 		if (forward_r > 0)
 567:bellator_low_level.c **** 			encoder_count[1]++;
 568:bellator_low_level.c **** 		else
 569:bellator_low_level.c **** 			encoder_count[1]--;
 570:bellator_low_level.c **** 		T2IR |= 0x1 << 5; // reset CAP2.1
 571:bellator_low_level.c **** 	}
 572:bellator_low_level.c **** 	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
 573:bellator_low_level.c **** 		//log_string_debug("FIQ4\n");
 574:bellator_low_level.c **** 		forward_r--;
 575:bellator_low_level.c **** 		T2IR |= 0x1 << 6; // reset CAP2.2
 576:bellator_low_level.c **** 	}
 577:bellator_low_level.c **** 	else if (EXTINT & 0x1 << 0) { // EINT0 left encoder
 578:bellator_low_level.c **** 		//log_string_debug("FIQ1\n");
 579:bellator_low_level.c **** 		forward_l++;
 580:bellator_low_level.c **** 		if (forward_l > 0)
 581:bellator_low_level.c **** 			encoder_count[0]++;
 582:bellator_low_level.c **** 		else
 583:bellator_low_level.c **** 			encoder_count[0]--;
 584:bellator_low_level.c **** 		EXTINT |= 0x1 << 0; // reset EINT0
 585:bellator_low_level.c **** 	}
 586:bellator_low_level.c **** 
 587:bellator_low_level.c **** 	//log_string_debug("<< pulse_in\n");
 588:bellator_low_level.c **** 
 589:bellator_low_level.c **** 	VICVectAddr = 0;
 590:bellator_low_level.c **** }
 591:bellator_low_level.c **** 
 592:bellator_low_level.c **** /**
 593:bellator_low_level.c ****  * DATA READY INTERRUPT WAS NOT USED
 594:bellator_low_level.c ****  * Read IMU data when triggered by EINT2
 595:bellator_low_level.c ****  */
 596:bellator_low_level.c **** /*void imu_data_ready(void) {
 597:bellator_low_level.c **** 
 598:bellator_low_level.c **** 	//log_string_debug(">> imu_data_ready\n");
 599:bellator_low_level.c **** 
 600:bellator_low_level.c **** 	imu_data_available = 1;
 601:bellator_low_level.c **** 
 602:bellator_low_level.c **** 	EXTINT |= 0x1 << 2; // reset EINT2
 603:bellator_low_level.c **** 
 604:bellator_low_level.c **** 	//log_string_debug("<< imu_data_ready\n");
 605:bellator_low_level.c **** 
 606:bellator_low_level.c **** 	VICVectAddr = 0;
 607:bellator_low_level.c **** }
 608:bellator_low_level.c **** */
 609:bellator_low_level.c **** 
 610:bellator_low_level.c **** /**
 611:bellator_low_level.c ****  * Sample sensors every 1ms (1kHz)
 612:bellator_low_level.c ****  * data_in_pos -
 613:bellator_low_level.c ****  */
 614:bellator_low_level.c **** void sample(void) {
 615:bellator_low_level.c **** 	volatile unsigned short ir = T3IR;
 616:bellator_low_level.c **** 	if(ir & 0x1) { // MAT3.0
 617:bellator_low_level.c **** 		log_string_debug(">> sample\n");
 618:bellator_low_level.c **** 
 619:bellator_low_level.c **** 		log_string_debug("IENABLE\n");
 620:bellator_low_level.c **** 		// enable nested interrupts for i2c and FIQ
 621:bellator_low_level.c **** 		T3IR |= 0x1 << 0; // clear MAT3.0 interrupt
 622:bellator_low_level.c **** 		IENABLE
 623:bellator_low_level.c **** 
 624:bellator_low_level.c **** 		// next position in buffer
 625:bellator_low_level.c **** 		data_in_pos = ++data_in_pos % DATA_BUFF_SIZE;
 626:bellator_low_level.c **** 
 627:bellator_low_level.c **** 		// check for overflow
 628:bellator_low_level.c **** 		if (data_in_pos == data_out_pos) {
 629:bellator_low_level.c **** 			log_string_warning("LPC overflow\n");
 630:bellator_low_level.c **** 			// the oldest data will be overwritten
 631:bellator_low_level.c **** 			data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 632:bellator_low_level.c **** 		}
 633:bellator_low_level.c **** 
 634:bellator_low_level.c **** 		// read data and put on local circular buffer
 635:bellator_low_level.c **** 		struct sensors_data* data;
 636:bellator_low_level.c **** 		data = &(sensors_data_buff[data_in_pos]);
 637:bellator_low_level.c **** 
 638:bellator_low_level.c **** 		// read encoder counts
 639:bellator_low_level.c **** 		get_encoders_count(&(data->encoder_left), &(data->encoder_right));
 640:bellator_low_level.c **** 
 641:bellator_low_level.c **** 		// read the last IMU data
 642:bellator_low_level.c **** 		mpu_get_motion6(&(data->ax_h));
 643:bellator_low_level.c **** 
 644:bellator_low_level.c **** 		// read IR data
 645:bellator_low_level.c **** 		get_ir_sensor_data(&(data->ir_l));
 646:bellator_low_level.c **** 
 647:bellator_low_level.c **** 		data->timestamp = timestamp++;
 648:bellator_low_level.c **** 
 649:bellator_low_level.c **** 		log_string_debug("IDISABLE\n");
 650:bellator_low_level.c **** 		IDISABLE
 651:bellator_low_level.c **** 
 652:bellator_low_level.c **** 		log_string_debug("<< sample\n");
 653:bellator_low_level.c **** 	}
 654:bellator_low_level.c **** 
 655:bellator_low_level.c **** 	VICVectAddr = 0;
 656:bellator_low_level.c **** }
 657:bellator_low_level.c **** 
 658:bellator_low_level.c **** /**
 659:bellator_low_level.c ****  *
 660:bellator_low_level.c ****  */
 661:bellator_low_level.c **** void error(void){
 662:bellator_low_level.c **** 	log_string_error("irq error");
 663:bellator_low_level.c **** }
 664:bellator_low_level.c **** 
 665:bellator_low_level.c **** /**
 666:bellator_low_level.c ****  * Return the value read from the i'th sensor
 667:bellator_low_level.c ****  * buff
 668:bellator_low_level.c ****  * ir_l, ir_ml, ir_m, ir_mr, ir_r
 669:bellator_low_level.c ****  *
 670:bellator_low_level.c ****  */
 671:bellator_low_level.c **** void get_ir_sensor_data(char * buff) {
 672:bellator_low_level.c **** 
 673:bellator_low_level.c **** 	unsigned short val;
 674:bellator_low_level.c **** 
 675:bellator_low_level.c **** 	while(ADDR0 & ((0x1 << 31) == 0));
 676:bellator_low_level.c **** 	val = (ADDR0 >> 6) & 0x3FF;
 677:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 678:bellator_low_level.c **** 	val += (val == 0);
 679:bellator_low_level.c **** 	*buff = (char) val;
 680:bellator_low_level.c **** 
 681:bellator_low_level.c **** 	while(ADDR1 & ((0x1 << 31) == 0));
 682:bellator_low_level.c **** 	val = (ADDR1 >> 6) & 0x3FF;
 683:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 684:bellator_low_level.c **** 	val += (val == 0);
 685:bellator_low_level.c **** 	*(buff+1) = (char) val;
 686:bellator_low_level.c **** 
 687:bellator_low_level.c **** 	while(ADDR2 & ((0x1 << 31) == 0));
 688:bellator_low_level.c **** 	val = (ADDR2 >> 6) & 0x3FF;
 689:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 690:bellator_low_level.c **** 	val += (val == 0);
 691:bellator_low_level.c **** 	*(buff+2) = (char) val;
 692:bellator_low_level.c **** 
 693:bellator_low_level.c **** 	while(ADDR3 & ((0x1 << 31) == 0));
 694:bellator_low_level.c **** 	val = (ADDR3 >> 6) & 0x3FF;
 695:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 696:bellator_low_level.c **** 	val += (val == 0);
 697:bellator_low_level.c **** 	*(buff+3) = (char) val;
 698:bellator_low_level.c **** 
 699:bellator_low_level.c **** 	while(ADDR4 & ((0x1 << 31) == 0));
 700:bellator_low_level.c **** 	val = (ADDR4 >> 6) & 0x3FF;
 701:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 702:bellator_low_level.c **** 	val += (val == 0);
 703:bellator_low_level.c **** 	*(buff+4) = (char) val;
 704:bellator_low_level.c **** }
 705:bellator_low_level.c **** 
 706:bellator_low_level.c **** 
 707:bellator_low_level.c **** 
 708:bellator_low_level.c **** /**
 709:bellator_low_level.c ****  * Return the count value read from the i'th sensor
 710:bellator_low_level.c ****  */
 711:bellator_low_level.c **** void get_encoders_count(short * left_encoder, short * right_encoder) {
 712:bellator_low_level.c **** 
 713:bellator_low_level.c **** 	int val;
 714:bellator_low_level.c **** 	val = encoder_count[ENCODER_L - ENCODER_L];
 715:bellator_low_level.c **** 	*left_encoder = val - sent_encoder_count[ENCODER_L - ENCODER_L];
 716:bellator_low_level.c **** 	sent_encoder_count[ENCODER_L - ENCODER_L] = val;
 717:bellator_low_level.c **** 
 718:bellator_low_level.c **** 	val = encoder_count[ENCODER_R - ENCODER_L];
 719:bellator_low_level.c **** 	*right_encoder = val - sent_encoder_count[ENCODER_R - ENCODER_L];
 720:bellator_low_level.c **** 	sent_encoder_count[ENCODER_R - ENCODER_L] = val;
 721:bellator_low_level.c **** }
 722:bellator_low_level.c **** 
 723:bellator_low_level.c **** /**
 724:bellator_low_level.c ****  * Set the output pwm value
 725:bellator_low_level.c ****  */
 726:bellator_low_level.c **** inline void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel) {
 727:bellator_low_level.c **** 
 728:bellator_low_level.c **** 	if (left_wheel > 8)
 729:bellator_low_level.c **** 		left_wheel -= 8;
 730:bellator_low_level.c **** 	else
 731:bellator_low_level.c **** 		left_wheel = 8;
 510              		.loc 3 731 0
 511 04a4 142093E5 		ldr	r2, [r3, #20]
 512              	.LBE43:
 513              	.LBE41:
 489:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 514              		.loc 3 489 0
 515 04a8 E0319FE5 		ldr	r3, .L53+4
 497:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 516              		.loc 3 497 0
 517 04ac D8119FE5 		ldr	r1, .L53
 516:bellator_low_level.c **** 					send_data = 1;
 518              		.loc 3 516 0
 519 04b0 01B0A0E3 		mov	fp, #1
 518:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
 520              		.loc 3 518 0
 521 04b4 00C0A0E3 		mov	ip, #0
 522              	.LBB45:
 523              	.LBB42:
 732:bellator_low_level.c **** 
 733:bellator_low_level.c **** 	if (right_wheel & PWM_DIR) { // Forward
 734:bellator_low_level.c **** 		T0MR2 = 256;
 735:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 736:bellator_low_level.c **** 	} else { // Backwards
 737:bellator_low_level.c **** 		T0MR1 = 256;
 738:bellator_low_level.c **** 		T0MR2 = 256 - right_wheel*2;
 739:bellator_low_level.c **** 	}
 740:bellator_low_level.c **** 
 741:bellator_low_level.c **** 	if (left_wheel & PWM_DIR) { // Forward
 742:bellator_low_level.c **** 		T1MR0 = 256;
 743:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 744:bellator_low_level.c **** 	} else { // Backwards
 745:bellator_low_level.c **** 		T1MR1 = 256;
 524              		.loc 3 745 0
 525 04b8 D4619FE5 		ldr	r6, .L53+8
 526 04bc 015CA0E3 		mov	r5, #256
 737:bellator_low_level.c **** 		T0MR1 = 256;
 527              		.loc 3 737 0
 528 04c0 D0419FE5 		ldr	r4, .L53+12
 529              	.LBE42:
 530              	.LBE45:
 489:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 531              		.loc 3 489 0
 532 04c4 620000EA 		b	.L52
 533              	.LVL3:
 534              	.L48:
 490:bellator_low_level.c **** 		switch (iir & 0x0E) {
 535              		.loc 3 490 0
 536 04c8 0600DDE5 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 537 04cc 0E0000E2 		and	r0, r0, #14
 538              	.LVL4:
 539 04d0 0C0050E3 		cmp	r0, #12
 540 04d4 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 541 04d8 5D0000EA 		b	.L52
 542              	.L39:
 543 04dc 48060000 		.word	.L35
 544 04e0 54060000 		.word	.L52
 545 04e4 38060000 		.word	.L36
 546 04e8 54060000 		.word	.L52
 547 04ec 20050000 		.word	.L37
 548 04f0 54060000 		.word	.L52
 549 04f4 10050000 		.word	.L38
 550 04f8 54060000 		.word	.L52
 551 04fc 54060000 		.word	.L52
 552 0500 54060000 		.word	.L52
 553 0504 54060000 		.word	.L52
 554 0508 54060000 		.word	.L52
 555 050c 20050000 		.word	.L37
 556              	.L38:
 492:bellator_low_level.c **** 			dummy = U1LSR; // Just clear the interrupt source
 557              		.loc 3 492 0
 558 0510 1400D3E5 		ldrb	r0, [r3, #20]	@ zero_extendqisi2
 559 0514 FF0000E2 		and	r0, r0, #255
 560              	.LVL5:
 561 0518 0700CDE5 		strb	r0, [sp, #7]
 493:bellator_low_level.c **** 			break;
 562              		.loc 3 493 0
 563 051c 4C0000EA 		b	.L52
 564              	.LVL6:
 565              	.L37:
 497:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 566              		.loc 3 497 0
 567 0520 0000D3E5 		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 568 0524 FF0000E2 		and	r0, r0, #255
 569 0528 027081E0 		add	r7, r1, r2
 570 052c 1800C7E5 		strb	r0, [r7, #24]
 499:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 571              		.loc 3 499 0
 572 0530 FE0050E3 		cmp	r0, #254
 573 0534 3C00001A 		bne	.L41
 501:bellator_low_level.c **** 				if (cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] == ENGINES) {
 574              		.loc 3 501 0
 575 0538 030042E2 		sub	r0, r2, #3
 576 053c 1F0000E2 		and	r0, r0, #31
 577 0540 007081E0 		add	r7, r1, r0
 578 0544 1870D7E5 		ldrb	r7, [r7, #24]	@ zero_extendqisi2
 579 0548 B00057E3 		cmp	r7, #176
 580 054c 2A00001A 		bne	.L42
 504:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)]),
 581              		.loc 3 504 0
 582 0550 027042E2 		sub	r7, r2, #2
 583 0554 1F7007E2 		and	r7, r7, #31
 584 0558 078081E0 		add	r8, r1, r7
 585 055c 18A0D8E5 		ldrb	sl, [r8, #24]	@ zero_extendqisi2
 505:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]));
 586              		.loc 3 505 0
 587 0560 019042E2 		sub	r9, r2, #1
 588 0564 1F9009E2 		and	r9, r9, #31
 589 0568 098081E0 		add	r8, r1, r9
 504:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)]),
 590              		.loc 3 504 0
 591 056c 1880D8E5 		ldrb	r8, [r8, #24]	@ zero_extendqisi2
 592              	.LVL7:
 593              	.LBB46:
 594              	.LBB44:
 728:bellator_low_level.c **** 	if (left_wheel > 8)
 595              		.loc 3 728 0
 596 0570 08005AE3 		cmp	sl, #8
 729:bellator_low_level.c **** 		left_wheel -= 8;
 597              		.loc 3 729 0
 598 0574 08A04A82 		subhi	sl, sl, #8
 599              	.LVL8:
 600 0578 0AA8A081 		movhi	sl, sl, asl #16
 601 057c 2AA8A081 		movhi	sl, sl, lsr #16
 602              	.LVL9:
 731:bellator_low_level.c **** 		left_wheel = 8;
 603              		.loc 3 731 0
 604 0580 08A0A093 		movls	sl, #8
 605              	.LVL10:
 733:bellator_low_level.c **** 	if (right_wheel & PWM_DIR) { // Forward
 606              		.loc 3 733 0
 607 0584 800018E3 		tst	r8, #128
 734:bellator_low_level.c **** 		T0MR2 = 256;
 608              		.loc 3 734 0
 609 0588 20508415 		strne	r5, [r4, #32]
 735:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 610              		.loc 3 735 0
 611 058c 8080C813 		bicne	r8, r8, #128
 612              	.LVL11:
 613 0590 80806812 		rsbne	r8, r8, #128
 614 0594 8880A011 		movne	r8, r8, asl #1
 615 0598 1C808415 		strne	r8, [r4, #28]
 737:bellator_low_level.c **** 		T0MR1 = 256;
 616              		.loc 3 737 0
 617 059c 1C508405 		streq	r5, [r4, #28]
 738:bellator_low_level.c **** 		T0MR2 = 256 - right_wheel*2;
 618              		.loc 3 738 0
 619 05a0 80806802 		rsbeq	r8, r8, #128
 620 05a4 8880A001 		moveq	r8, r8, asl #1
 621 05a8 20808405 		streq	r8, [r4, #32]
 741:bellator_low_level.c **** 	if (left_wheel & PWM_DIR) { // Forward
 622              		.loc 3 741 0
 623 05ac 80001AE3 		tst	sl, #128
 742:bellator_low_level.c **** 		T1MR0 = 256;
 624              		.loc 3 742 0
 625 05b0 18508615 		strne	r5, [r6, #24]
 743:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 626              		.loc 3 743 0
 627 05b4 8080CA13 		bicne	r8, sl, #128
 628 05b8 80806812 		rsbne	r8, r8, #128
 629 05bc 8880A011 		movne	r8, r8, asl #1
 630 05c0 1C808615 		strne	r8, [r6, #28]
 631              		.loc 3 745 0
 632 05c4 1C508605 		streq	r5, [r6, #28]
 746:bellator_low_level.c **** 		T1MR0 = 256 - left_wheel*2;
 633              		.loc 3 746 0
 634 05c8 80806A02 		rsbeq	r8, sl, #128
 635 05cc 8880A001 		moveq	r8, r8, asl #1
 636 05d0 18808605 		streq	r8, [r6, #24]
 637              	.LBE44:
 638              	.LBE46:
 507:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] = 0;
 639              		.loc 3 507 0
 640 05d4 000081E0 		add	r0, r1, r0
 641 05d8 18C0C0E5 		strb	ip, [r0, #24]
 508:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] = 0;
 642              		.loc 3 508 0
 643 05dc 070081E0 		add	r0, r1, r7
 644 05e0 18C0C0E5 		strb	ip, [r0, #24]
 509:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
 645              		.loc 3 509 0
 646 05e4 090081E0 		add	r0, r1, r9
 647 05e8 18C0C0E5 		strb	ip, [r0, #24]
 510:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)] = 0;
 648              		.loc 3 510 0
 649 05ec 1F0002E2 		and	r0, r2, #31
 650 05f0 000081E0 		add	r0, r1, r0
 651 05f4 18C0C0E5 		strb	ip, [r0, #24]
 652 05f8 0B0000EA 		b	.L41
 653              	.LVL12:
 654              	.L42:
 513:bellator_low_level.c **** 				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
 655              		.loc 3 513 0
 656 05fc 010042E2 		sub	r0, r2, #1
 657 0600 1F0000E2 		and	r0, r0, #31
 658 0604 007081E0 		add	r7, r1, r0
 659 0608 1870D7E5 		ldrb	r7, [r7, #24]	@ zero_extendqisi2
 660 060c A00057E3 		cmp	r7, #160
 661 0610 0500001A 		bne	.L41
 516:bellator_low_level.c **** 					send_data = 1;
 662              		.loc 3 516 0
 663 0614 38B0C1E5 		strb	fp, [r1, #56]
 518:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
 664              		.loc 3 518 0
 665 0618 000081E0 		add	r0, r1, r0
 666 061c 18C0C0E5 		strb	ip, [r0, #24]
 519:bellator_low_level.c **** 					cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)] = 0;
 667              		.loc 3 519 0
 668 0620 1F0002E2 		and	r0, r2, #31
 669 0624 000081E0 		add	r0, r1, r0
 670 0628 18C0C0E5 		strb	ip, [r0, #24]
 671              	.L41:
 523:bellator_low_level.c **** 			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
 672              		.loc 3 523 0
 673 062c 012082E2 		add	r2, r2, #1
 674 0630 1F2002E2 		and	r2, r2, #31
 524:bellator_low_level.c **** 			break;
 675              		.loc 3 524 0
 676 0634 060000EA 		b	.L52
 677              	.L36:
 527:bellator_low_level.c **** 			U1THR = dummy; // Just clear the interrupt source
 678              		.loc 3 527 0
 679 0638 0700DDE5 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 680              	.LVL13:
 681 063c FF0000E2 		and	r0, r0, #255
 682              	.LVL14:
 683 0640 0000C3E5 		strb	r0, [r3, #0]
 528:bellator_low_level.c **** 			break;
 684              		.loc 3 528 0
 685 0644 020000EA 		b	.L52
 686              	.LVL15:
 687              	.L35:
 531:bellator_low_level.c **** 			dummy = U1MSR; // Just clear the interrupt source
 688              		.loc 3 531 0
 689 0648 1800D3E5 		ldrb	r0, [r3, #24]	@ zero_extendqisi2
 690 064c FF0000E2 		and	r0, r0, #255
 691              	.LVL16:
 692 0650 0700CDE5 		strb	r0, [sp, #7]
 693              	.L52:
 489:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 694              		.loc 3 489 0 discriminator 1
 695 0654 0800D3E5 		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 696              	.LVL17:
 697 0658 FF0000E2 		and	r0, r0, #255
 698              	.LVL18:
 699 065c 0600CDE5 		strb	r0, [sp, #6]
 700 0660 0600DDE5 		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 701 0664 010010E3 		tst	r0, #1
 702 0668 96FFFF0A 		beq	.L48
 489:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 703              		.loc 3 489 0 is_stmt 0
 704 066c 18309FE5 		ldr	r3, .L53
 705 0670 142083E5 		str	r2, [r3, #20]
 541:bellator_low_level.c **** 	VICVectAddr = 0;
 706              		.loc 3 541 0 is_stmt 1
 707 0674 0020A0E3 		mov	r2, #0
 708 0678 0030E0E3 		mvn	r3, #0
 709 067c CF2F03E5 		str	r2, [r3, #-4047]
 542:bellator_low_level.c **** }
 710              		.loc 3 542 0
 711 0680 0CD08DE2 		add	sp, sp, #12
 712 0684 FF1FBDE8 		ldmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 713 0688 04F05EE2 		subs	pc, lr, #4
 714              	.L54:
 715              		.align	2
 716              	.L53:
 717 068c 00000000 		.word	.LANCHOR0
 718 0690 000001E0 		.word	-536805376
 719 0694 008000E0 		.word	-536838144
 720 0698 004000E0 		.word	-536854528
 721              		.cfi_endproc
 722              	.LFE52:
 723              		.fnend
 725              		.align	2
 726              		.global	pulse_in
 728              	pulse_in:
 729              		.fnstart
 730              	.LFB53:
 551:bellator_low_level.c **** void pulse_in(void) {
 731              		.loc 3 551 0
 732              		.cfi_startproc
 733              		@ Interrupt Service Routine.
 734              		@ args = 0, pretend = 0, frame = 8
 735              		@ frame_needed = 0, uses_anonymous_args = 0
 736              		@ link register save eliminated.
 737 069c 0C002DE9 		stmfd	sp!, {r2, r3}
 738              		.save {r2, r3}
 739              	.LCFI6:
 740              		.cfi_def_cfa_offset 8
 741              		.pad #8
 742 06a0 08D04DE2 		sub	sp, sp, #8
 743              	.LCFI7:
 744              		.cfi_def_cfa_offset 16
 555:bellator_low_level.c **** 	volatile unsigned short ir = T2IR;
 745              		.loc 3 555 0
 746 06a4 30319FE5 		ldr	r3, .L64
 747              		.cfi_offset 3, -4
 748              		.cfi_offset 2, -8
 749 06a8 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 750 06ac FF3003E2 		and	r3, r3, #255
 751 06b0 B630CDE1 		strh	r3, [sp, #6]	@ movhi
 752              	.LVL19:
 558:bellator_low_level.c **** 	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
 753              		.loc 3 558 0
 754 06b4 B630DDE1 		ldrh	r3, [sp, #6]
 755              	.LVL20:
 756 06b8 100013E3 		tst	r3, #16
 757 06bc 0900000A 		beq	.L56
 560:bellator_low_level.c **** 		forward_l--;
 758              		.loc 3 560 0
 759 06c0 18319FE5 		ldr	r3, .L64+4
 760              	.LVL21:
 761 06c4 3C2093E5 		ldr	r2, [r3, #60]
 762 06c8 012042E2 		sub	r2, r2, #1
 763 06cc 3C2083E5 		str	r2, [r3, #60]
 561:bellator_low_level.c **** 		T2IR |= 0x1 << 4; // reset CAP2.0
 764              		.loc 3 561 0
 765 06d0 04319FE5 		ldr	r3, .L64
 766 06d4 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 767 06d8 FF2002E2 		and	r2, r2, #255
 768 06dc 102082E3 		orr	r2, r2, #16
 769 06e0 0020C3E5 		strb	r2, [r3, #0]
 770 06e4 360000EA 		b	.L57
 771              	.LVL22:
 772              	.L56:
 563:bellator_low_level.c **** 	else if (ir & (0x1 << 5)) { //CAP2.1 right encoder
 773              		.loc 3 563 0
 774 06e8 B630DDE1 		ldrh	r3, [sp, #6]
 775 06ec 200013E3 		tst	r3, #32
 776 06f0 1100000A 		beq	.L58
 565:bellator_low_level.c **** 		forward_r++;
 777              		.loc 3 565 0
 778 06f4 E4209FE5 		ldr	r2, .L64+4
 779 06f8 403092E5 		ldr	r3, [r2, #64]
 780              	.LVL23:
 781 06fc 013083E2 		add	r3, r3, #1
 782 0700 403082E5 		str	r3, [r2, #64]
 566:bellator_low_level.c **** 		if (forward_r > 0)
 783              		.loc 3 566 0
 784 0704 000053E3 		cmp	r3, #0
 567:bellator_low_level.c **** 			encoder_count[1]++;
 785              		.loc 3 567 0
 786 0708 0230A0C1 		movgt	r3, r2
 787 070c 482092C5 		ldrgt	r2, [r2, #72]
 788 0710 012082C2 		addgt	r2, r2, #1
 569:bellator_low_level.c **** 			encoder_count[1]--;
 789              		.loc 3 569 0
 790 0714 C4309FD5 		ldrle	r3, .L64+4
 791 0718 482093D5 		ldrle	r2, [r3, #72]
 792 071c 012042D2 		suble	r2, r2, #1
 793 0720 482083E5 		str	r2, [r3, #72]
 570:bellator_low_level.c **** 		T2IR |= 0x1 << 5; // reset CAP2.1
 794              		.loc 3 570 0
 795 0724 B0309FE5 		ldr	r3, .L64
 796 0728 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 797 072c FF2002E2 		and	r2, r2, #255
 798 0730 202082E3 		orr	r2, r2, #32
 799 0734 0020C3E5 		strb	r2, [r3, #0]
 800 0738 210000EA 		b	.L57
 801              	.LVL24:
 802              	.L58:
 572:bellator_low_level.c **** 	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
 803              		.loc 3 572 0
 804 073c B630DDE1 		ldrh	r3, [sp, #6]
 805 0740 400013E3 		tst	r3, #64
 806 0744 0900000A 		beq	.L61
 574:bellator_low_level.c **** 		forward_r--;
 807              		.loc 3 574 0
 808 0748 90309FE5 		ldr	r3, .L64+4
 809              	.LVL25:
 810 074c 402093E5 		ldr	r2, [r3, #64]
 811 0750 012042E2 		sub	r2, r2, #1
 812 0754 402083E5 		str	r2, [r3, #64]
 575:bellator_low_level.c **** 		T2IR |= 0x1 << 6; // reset CAP2.2
 813              		.loc 3 575 0
 814 0758 7C309FE5 		ldr	r3, .L64
 815 075c 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 816 0760 FF2002E2 		and	r2, r2, #255
 817 0764 402082E3 		orr	r2, r2, #64
 818 0768 0020C3E5 		strb	r2, [r3, #0]
 819 076c 140000EA 		b	.L57
 820              	.LVL26:
 821              	.L61:
 577:bellator_low_level.c **** 	else if (EXTINT & 0x1 << 0) { // EINT0 left encoder
 822              		.loc 3 577 0
 823 0770 6C309FE5 		ldr	r3, .L64+8
 824              	.LVL27:
 825 0774 4030D3E5 		ldrb	r3, [r3, #64]	@ zero_extendqisi2
 826 0778 010013E3 		tst	r3, #1
 827 077c 1000000A 		beq	.L57
 579:bellator_low_level.c **** 		forward_l++;
 828              		.loc 3 579 0
 829 0780 58209FE5 		ldr	r2, .L64+4
 830 0784 3C3092E5 		ldr	r3, [r2, #60]
 831 0788 013083E2 		add	r3, r3, #1
 832 078c 3C3082E5 		str	r3, [r2, #60]
 580:bellator_low_level.c **** 		if (forward_l > 0)
 833              		.loc 3 580 0
 834 0790 000053E3 		cmp	r3, #0
 581:bellator_low_level.c **** 			encoder_count[0]++;
 835              		.loc 3 581 0
 836 0794 0230A0C1 		movgt	r3, r2
 837 0798 442092C5 		ldrgt	r2, [r2, #68]
 838 079c 012082C2 		addgt	r2, r2, #1
 583:bellator_low_level.c **** 			encoder_count[0]--;
 839              		.loc 3 583 0
 840 07a0 38309FD5 		ldrle	r3, .L64+4
 841 07a4 442093D5 		ldrle	r2, [r3, #68]
 842 07a8 012042D2 		suble	r2, r2, #1
 843 07ac 442083E5 		str	r2, [r3, #68]
 584:bellator_low_level.c **** 		EXTINT |= 0x1 << 0; // reset EINT0
 844              		.loc 3 584 0
 845 07b0 2C309FE5 		ldr	r3, .L64+8
 846 07b4 4020D3E5 		ldrb	r2, [r3, #64]	@ zero_extendqisi2
 847 07b8 FF2002E2 		and	r2, r2, #255
 848 07bc 012082E3 		orr	r2, r2, #1
 849 07c0 4020C3E5 		strb	r2, [r3, #64]
 850              	.L57:
 589:bellator_low_level.c **** 	VICVectAddr = 0;
 851              		.loc 3 589 0
 852 07c4 0020A0E3 		mov	r2, #0
 853 07c8 0030E0E3 		mvn	r3, #0
 854 07cc CF2F03E5 		str	r2, [r3, #-4047]
 590:bellator_low_level.c **** }
 855              		.loc 3 590 0
 856 07d0 08D08DE2 		add	sp, sp, #8
 857 07d4 0C00BDE8 		ldmfd	sp!, {r2, r3}
 858 07d8 04F05EE2 		subs	pc, lr, #4
 859              	.L65:
 860              		.align	2
 861              	.L64:
 862 07dc 000007E0 		.word	-536412160
 863 07e0 00000000 		.word	.LANCHOR0
 864 07e4 00C11FE0 		.word	-534789888
 865              		.cfi_endproc
 866              	.LFE53:
 867              		.fnend
 869              		.align	2
 870              		.global	error
 872              	error:
 873              		.fnstart
 874              	.LFB55:
 661:bellator_low_level.c **** void error(void){
 875              		.loc 3 661 0
 876              		.cfi_startproc
 877              		@ Interrupt Service Routine.
 878              		@ args = 0, pretend = 0, frame = 0
 879              		@ frame_needed = 0, uses_anonymous_args = 0
 880              		@ link register save eliminated.
 663:bellator_low_level.c **** }
 881              		.loc 3 663 0
 882 07e8 04F05EE2 		subs	pc, lr, #4
 883              		.cfi_endproc
 884              	.LFE55:
 885              		.fnend
 887              		.align	2
 888              		.global	logger_init
 890              	logger_init:
 891              		.fnstart
 892              	.LFB0:
  20:logger.c      **** void logger_init(void){ // using UART0
 893              		.loc 1 20 0
 894              		.cfi_startproc
 895              		@ Function supports interworking.
 896              		@ args = 0, pretend = 0, frame = 0
 897              		@ frame_needed = 0, uses_anonymous_args = 0
 898              		@ link register save eliminated.
  21:logger.c      **** 	PINSEL0 |= 0x05; // Set the pins function
 899              		.loc 1 21 0
 900 07ec 54309FE5 		ldr	r3, .L68
 901 07f0 002093E5 		ldr	r2, [r3, #0]
 902 07f4 052082E3 		orr	r2, r2, #5
 903 07f8 002083E5 		str	r2, [r3, #0]
  22:logger.c      **** 	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
 904              		.loc 1 22 0
 905 07fc 48309FE5 		ldr	r3, .L68+4
 906 0800 0720A0E3 		mov	r2, #7
 907 0804 0820C3E5 		strb	r2, [r3, #8]
  23:logger.c      **** 	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 908              		.loc 1 23 0
 909 0808 7C20E0E3 		mvn	r2, #124
 910 080c 0C20C3E5 		strb	r2, [r3, #12]
  26:logger.c      **** 	U0DLL	 = 0x06; // DivisorLatchLow bit
 911              		.loc 1 26 0
 912 0810 0620A0E3 		mov	r2, #6
 913 0814 0020C3E5 		strb	r2, [r3, #0]
  27:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
 914              		.loc 1 27 0
 915 0818 0020A0E3 		mov	r2, #0
 916 081c 0420C3E5 		strb	r2, [r3, #4]
  28:logger.c      **** 	U0FDR	|= 0x05; // DivAddVal
 917              		.loc 1 28 0
 918 0820 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 919 0824 FF2002E2 		and	r2, r2, #255
 920 0828 052082E3 		orr	r2, r2, #5
 921 082c 2820C3E5 		strb	r2, [r3, #40]
  29:logger.c      **** 	U0FDR	|= 0x0E << 4; // MulVal = 14
 922              		.loc 1 29 0
 923 0830 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 924 0834 E02082E3 		orr	r2, r2, #224
 925 0838 2820C3E5 		strb	r2, [r3, #40]
  36:logger.c      **** 	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 926              		.loc 1 36 0
 927 083c 0320A0E3 		mov	r2, #3
 928 0840 0C20C3E5 		strb	r2, [r3, #12]
  37:logger.c      **** }
 929              		.loc 1 37 0
 930 0844 1EFF2FE1 		bx	lr
 931              	.L69:
 932              		.align	2
 933              	.L68:
 934 0848 00C002E0 		.word	-536690688
 935 084c 00C000E0 		.word	-536821760
 936              		.cfi_endproc
 937              	.LFE0:
 938              		.fnend
 940              		.align	2
 941              		.global	log_int
 943              	log_int:
 944              		.fnstart
 945              	.LFB2:
  43:logger.c      **** 
  44:logger.c      **** void log_int(int num){
 946              		.loc 1 44 0
 947              		.cfi_startproc
 948              		@ Function supports interworking.
 949              		@ args = 0, pretend = 0, frame = 0
 950              		@ frame_needed = 0, uses_anonymous_args = 0
 951              	.LVL28:
 952 0850 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 953              		.save {r3, r4, r5, lr}
 954              	.LCFI8:
 955              		.cfi_def_cfa_offset 16
  45:logger.c      **** 	if(num & 0x80000000){ // se for negativo
 956              		.loc 1 45 0
 957 0854 004050E2 		subs	r4, r0, #0
 958              		.cfi_offset 14, -4
 959              		.cfi_offset 5, -8
 960              		.cfi_offset 4, -12
 961              		.cfi_offset 3, -16
 962 0858 030000AA 		bge	.L71
  46:logger.c      **** 		log_char('-');
 963              		.loc 1 46 0
 964 085c 2D00A0E3 		mov	r0, #45
 965              	.LVL29:
 966 0860 E6FDFFEB 		bl	log_char
 967              	.LVL30:
  47:logger.c      **** 		num = ~num;
  48:logger.c      **** 		num += 0x1;
 968              		.loc 1 48 0
 969 0864 004064E2 		rsb	r4, r4, #0
 970              	.LVL31:
 971 0868 010000EA 		b	.L72
 972              	.LVL32:
 973              	.L71:
  49:logger.c      **** 	}else
  50:logger.c      **** 		log_char(' ');
 974              		.loc 1 50 0
 975 086c 2000A0E3 		mov	r0, #32
 976              	.LVL33:
 977 0870 E2FDFFEB 		bl	log_char
 978              	.L72:
  51:logger.c      **** 	log_char(ascii[num >> 28]);
 979              		.loc 1 51 0
 980 0874 78509FE5 		ldr	r5, .L73
 981 0878 440ED5E7 		ldrb	r0, [r5, r4, asr #28]	@ zero_extendqisi2
 982 087c DFFDFFEB 		bl	log_char
  52:logger.c      **** 	log_char(ascii[num >> 24 & 0x0000000f]);
 983              		.loc 1 52 0
 984 0880 443CA0E1 		mov	r3, r4, asr #24
 985 0884 0F3003E2 		and	r3, r3, #15
 986 0888 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 987 088c DBFDFFEB 		bl	log_char
  53:logger.c      **** 	log_char(ascii[num >> 20 & 0x0000000f]);
 988              		.loc 1 53 0
 989 0890 443AA0E1 		mov	r3, r4, asr #20
 990 0894 0F3003E2 		and	r3, r3, #15
 991 0898 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 992 089c D7FDFFEB 		bl	log_char
  54:logger.c      **** 	log_char(ascii[num >> 16 & 0x0000000f]);
 993              		.loc 1 54 0
 994 08a0 4438A0E1 		mov	r3, r4, asr #16
 995 08a4 0F3003E2 		and	r3, r3, #15
 996 08a8 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 997 08ac D3FDFFEB 		bl	log_char
  55:logger.c      **** 	log_char(ascii[num >> 12 & 0x0000000f]);
 998              		.loc 1 55 0
 999 08b0 4436A0E1 		mov	r3, r4, asr #12
 1000 08b4 0F3003E2 		and	r3, r3, #15
 1001 08b8 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1002 08bc CFFDFFEB 		bl	log_char
  56:logger.c      **** 	log_char(ascii[num >> 8 & 0x0000000f]);
 1003              		.loc 1 56 0
 1004 08c0 4434A0E1 		mov	r3, r4, asr #8
 1005 08c4 0F3003E2 		and	r3, r3, #15
 1006 08c8 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1007 08cc CBFDFFEB 		bl	log_char
  57:logger.c      **** 	log_char(ascii[num >> 4 & 0x0000000f]);
 1008              		.loc 1 57 0
 1009 08d0 4432A0E1 		mov	r3, r4, asr #4
 1010 08d4 0F3003E2 		and	r3, r3, #15
 1011 08d8 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1012 08dc C7FDFFEB 		bl	log_char
  58:logger.c      **** 	log_char(ascii[num & 0x0000000f]);
 1013              		.loc 1 58 0
 1014 08e0 0F4004E2 		and	r4, r4, #15
 1015              	.LVL34:
 1016 08e4 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1017 08e8 C4FDFFEB 		bl	log_char
  59:logger.c      **** }
 1018              		.loc 1 59 0
 1019 08ec 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1020 08f0 1EFF2FE1 		bx	lr
 1021              	.L74:
 1022              		.align	2
 1023              	.L73:
 1024 08f4 00000000 		.word	.LANCHOR1
 1025              		.cfi_endproc
 1026              	.LFE2:
 1027              		.fnend
 1029              		.align	2
 1030              		.global	log_short
 1032              	log_short:
 1033              		.fnstart
 1034              	.LFB3:
  60:logger.c      **** 
  61:logger.c      **** void log_short(short num){
 1035              		.loc 1 61 0
 1036              		.cfi_startproc
 1037              		@ Function supports interworking.
 1038              		@ args = 0, pretend = 0, frame = 0
 1039              		@ frame_needed = 0, uses_anonymous_args = 0
 1040              	.LVL35:
 1041 08f8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1042              		.save {r3, r4, r5, lr}
 1043              	.LCFI9:
 1044              		.cfi_def_cfa_offset 16
  62:logger.c      **** 	if(num & 0x8000){ // se for negativo
 1045              		.loc 1 62 0
 1046 08fc 004050E2 		subs	r4, r0, #0
 1047              		.cfi_offset 14, -4
 1048              		.cfi_offset 5, -8
 1049              		.cfi_offset 4, -12
 1050              		.cfi_offset 3, -16
 1051 0900 050000AA 		bge	.L76
  63:logger.c      **** 		log_char('-');
 1052              		.loc 1 63 0
 1053 0904 2D00A0E3 		mov	r0, #45
 1054              	.LVL36:
 1055 0908 BCFDFFEB 		bl	log_char
 1056              	.LVL37:
  64:logger.c      **** 		num = ~num;
  65:logger.c      **** 		num++;
 1057              		.loc 1 65 0
 1058 090c 004064E2 		rsb	r4, r4, #0
 1059              	.LVL38:
 1060 0910 0448A0E1 		mov	r4, r4, asl #16
 1061              	.LVL39:
 1062 0914 4448A0E1 		mov	r4, r4, asr #16
 1063              	.LVL40:
 1064 0918 010000EA 		b	.L77
 1065              	.LVL41:
 1066              	.L76:
  66:logger.c      **** 	}else
  67:logger.c      **** 		log_char(' ');
 1067              		.loc 1 67 0
 1068 091c 2000A0E3 		mov	r0, #32
 1069              	.LVL42:
 1070 0920 B6FDFFEB 		bl	log_char
 1071              	.L77:
 1072              	.LVL43:
  68:logger.c      **** 	log_char(ascii[num >> 12]);
 1073              		.loc 1 68 0
 1074 0924 38509FE5 		ldr	r5, .L78
 1075 0928 4406D5E7 		ldrb	r0, [r5, r4, asr #12]	@ zero_extendqisi2
 1076 092c B3FDFFEB 		bl	log_char
  69:logger.c      **** 	log_char(ascii[num >> 8 & 0x000f]);
 1077              		.loc 1 69 0
 1078 0930 2434A0E1 		mov	r3, r4, lsr #8
 1079 0934 0F3003E2 		and	r3, r3, #15
 1080 0938 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1081 093c AFFDFFEB 		bl	log_char
  70:logger.c      **** 	log_char(ascii[num >> 4 & 0x000f]);
 1082              		.loc 1 70 0
 1083 0940 2432A0E1 		mov	r3, r4, lsr #4
 1084 0944 0F3003E2 		and	r3, r3, #15
 1085 0948 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1086 094c ABFDFFEB 		bl	log_char
  71:logger.c      **** 	log_char(ascii[num & 0x000f]);
 1087              		.loc 1 71 0
 1088 0950 0F4004E2 		and	r4, r4, #15
 1089              	.LVL44:
 1090 0954 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1091 0958 A8FDFFEB 		bl	log_char
  72:logger.c      **** }
 1092              		.loc 1 72 0
 1093 095c 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1094 0960 1EFF2FE1 		bx	lr
 1095              	.L79:
 1096              		.align	2
 1097              	.L78:
 1098 0964 00000000 		.word	.LANCHOR1
 1099              		.cfi_endproc
 1100              	.LFE3:
 1101              		.fnend
 1103              		.align	2
 1104              		.global	log_string
 1106              	log_string:
 1107              		.fnstart
 1108              	.LFB4:
  73:logger.c      **** 
  74:logger.c      **** void log_string(const char *s){
 1109              		.loc 1 74 0
 1110              		.cfi_startproc
 1111              		@ Function supports interworking.
 1112              		@ args = 0, pretend = 0, frame = 0
 1113              		@ frame_needed = 0, uses_anonymous_args = 0
 1114              	.LVL45:
 1115 0968 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1116              		.save {r3, r4, r5, lr}
 1117              	.LCFI10:
 1118              		.cfi_def_cfa_offset 16
  75:logger.c      **** 	while(*s){
 1119              		.loc 1 75 0
 1120 096c 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 1121              		.cfi_offset 14, -4
 1122              		.cfi_offset 5, -8
 1123              		.cfi_offset 4, -12
 1124              		.cfi_offset 3, -16
 1125 0970 000053E3 		cmp	r3, #0
 1126 0974 0900000A 		beq	.L80
 1127 0978 0040A0E1 		mov	r4, r0
  76:logger.c      **** 		if(*s == '\n')
  77:logger.c      **** 			log_char('\r'); // \n + \r = new line
 1128              		.loc 1 77 0
 1129 097c 0D50A0E3 		mov	r5, #13
 1130              	.LVL46:
 1131              	.L83:
  76:logger.c      **** 		if(*s == '\n')
 1132              		.loc 1 76 0
 1133 0980 0A0053E3 		cmp	r3, #10
 1134              		.loc 1 77 0
 1135 0984 0500A001 		moveq	r0, r5
 1136 0988 9CFDFF0B 		bleq	log_char
 1137              	.L82:
  78:logger.c      **** 		log_char(*s);
 1138              		.loc 1 78 0
 1139 098c 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 1140 0990 9AFDFFEB 		bl	log_char
  75:logger.c      **** 	while(*s){
 1141              		.loc 1 75 0
 1142 0994 0130F4E5 		ldrb	r3, [r4, #1]!	@ zero_extendqisi2
 1143 0998 000053E3 		cmp	r3, #0
 1144 099c F7FFFF1A 		bne	.L83
 1145              	.L80:
  79:logger.c      **** 		s++;
  80:logger.c      **** 	}
  81:logger.c      **** }
 1146              		.loc 1 81 0
 1147 09a0 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1148 09a4 1EFF2FE1 		bx	lr
 1149              		.cfi_endproc
 1150              	.LFE4:
 1151              		.fnend
 1153              		.align	2
 1154              		.global	log_byte
 1156              	log_byte:
 1157              		.fnstart
 1158              	.LFB5:
  82:logger.c      **** 
  83:logger.c      **** void log_byte(char c){
 1159              		.loc 1 83 0
 1160              		.cfi_startproc
 1161              		@ Function supports interworking.
 1162              		@ args = 0, pretend = 0, frame = 0
 1163              		@ frame_needed = 0, uses_anonymous_args = 0
 1164              	.LVL47:
 1165 09a8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1166              		.save {r3, r4, r5, lr}
 1167              	.LCFI11:
 1168              		.cfi_def_cfa_offset 16
 1169 09ac 0040A0E1 		mov	r4, r0
 1170              		.cfi_offset 14, -4
 1171              		.cfi_offset 5, -8
 1172              		.cfi_offset 4, -12
 1173              		.cfi_offset 3, -16
  84:logger.c      **** 	if(c & 0x80){ // se for negativo
 1174              		.loc 1 84 0
 1175 09b0 800010E3 		tst	r0, #128
 1176 09b4 0400000A 		beq	.L86
  85:logger.c      **** 		log_char('-');
 1177              		.loc 1 85 0
 1178 09b8 2D00A0E3 		mov	r0, #45
 1179              	.LVL48:
 1180 09bc 8FFDFFEB 		bl	log_char
 1181              	.LVL49:
  86:logger.c      **** 		c = ~c;
  87:logger.c      **** 		c++;
 1182              		.loc 1 87 0
 1183 09c0 004064E2 		rsb	r4, r4, #0
 1184              	.LVL50:
 1185 09c4 FF4004E2 		and	r4, r4, #255
 1186              	.LVL51:
 1187 09c8 010000EA 		b	.L87
 1188              	.LVL52:
 1189              	.L86:
  88:logger.c      **** 	}else
  89:logger.c      **** 		log_char(' ');
 1190              		.loc 1 89 0
 1191 09cc 2000A0E3 		mov	r0, #32
 1192              	.LVL53:
 1193 09d0 8AFDFFEB 		bl	log_char
 1194              	.L87:
 1195              	.LVL54:
  90:logger.c      **** 	log_char(ascii[c >> 4]);
 1196              		.loc 1 90 0
 1197 09d4 18509FE5 		ldr	r5, .L88
 1198 09d8 2402D5E7 		ldrb	r0, [r5, r4, lsr #4]	@ zero_extendqisi2
 1199 09dc 87FDFFEB 		bl	log_char
  91:logger.c      **** 	log_char(ascii[c & 0x000f]);
 1200              		.loc 1 91 0
 1201 09e0 0F4004E2 		and	r4, r4, #15
 1202              	.LVL55:
 1203 09e4 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1204 09e8 84FDFFEB 		bl	log_char
  92:logger.c      **** }
 1205              		.loc 1 92 0
 1206 09ec 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1207 09f0 1EFF2FE1 		bx	lr
 1208              	.L89:
 1209              		.align	2
 1210              	.L88:
 1211 09f4 00000000 		.word	.LANCHOR1
 1212              		.cfi_endproc
 1213              	.LFE5:
 1214              		.fnend
 1216              		.align	2
 1217              		.global	log2bytes
 1219              	log2bytes:
 1220              		.fnstart
 1221              	.LFB6:
  93:logger.c      **** 
  94:logger.c      **** void log2bytes(short c){
 1222              		.loc 1 94 0
 1223              		.cfi_startproc
 1224              		@ Function supports interworking.
 1225              		@ args = 0, pretend = 0, frame = 0
 1226              		@ frame_needed = 0, uses_anonymous_args = 0
 1227              	.LVL56:
 1228 09f8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1229              		.save {r3, r4, r5, lr}
 1230              	.LCFI12:
 1231              		.cfi_def_cfa_offset 16
  95:logger.c      **** 	if(c & 0x8000){ // se for negativo
 1232              		.loc 1 95 0
 1233 09fc 004050E2 		subs	r4, r0, #0
 1234              		.cfi_offset 14, -4
 1235              		.cfi_offset 5, -8
 1236              		.cfi_offset 4, -12
 1237              		.cfi_offset 3, -16
 1238 0a00 050000AA 		bge	.L91
  96:logger.c      **** 		log_char('-');
 1239              		.loc 1 96 0
 1240 0a04 2D00A0E3 		mov	r0, #45
 1241              	.LVL57:
 1242 0a08 7CFDFFEB 		bl	log_char
 1243              	.LVL58:
  97:logger.c      **** 		c = ~c;
  98:logger.c      **** 		c++;
 1244              		.loc 1 98 0
 1245 0a0c 004064E2 		rsb	r4, r4, #0
 1246              	.LVL59:
 1247 0a10 0448A0E1 		mov	r4, r4, asl #16
 1248              	.LVL60:
 1249 0a14 4448A0E1 		mov	r4, r4, asr #16
 1250              	.LVL61:
 1251 0a18 010000EA 		b	.L92
 1252              	.LVL62:
 1253              	.L91:
  99:logger.c      **** 	}else
 100:logger.c      **** 		log_char(' ');
 1254              		.loc 1 100 0
 1255 0a1c 2000A0E3 		mov	r0, #32
 1256              	.LVL63:
 1257 0a20 76FDFFEB 		bl	log_char
 1258              	.L92:
 1259              	.LVL64:
 101:logger.c      **** 	log_char(ascii[c >> 12]);
 1260              		.loc 1 101 0
 1261 0a24 38509FE5 		ldr	r5, .L93
 1262 0a28 4406D5E7 		ldrb	r0, [r5, r4, asr #12]	@ zero_extendqisi2
 1263 0a2c 73FDFFEB 		bl	log_char
 102:logger.c      **** 	log_char(ascii[c >> 8 & 0x000f]);
 1264              		.loc 1 102 0
 1265 0a30 2434A0E1 		mov	r3, r4, lsr #8
 1266 0a34 0F3003E2 		and	r3, r3, #15
 1267 0a38 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1268 0a3c 6FFDFFEB 		bl	log_char
 103:logger.c      **** 	log_char(ascii[c >> 4 & 0x000f]);
 1269              		.loc 1 103 0
 1270 0a40 2432A0E1 		mov	r3, r4, lsr #4
 1271 0a44 0F3003E2 		and	r3, r3, #15
 1272 0a48 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1273 0a4c 6BFDFFEB 		bl	log_char
 104:logger.c      **** 	log_char(ascii[c & 0x000f]);
 1274              		.loc 1 104 0
 1275 0a50 0F4004E2 		and	r4, r4, #15
 1276              	.LVL65:
 1277 0a54 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1278 0a58 68FDFFEB 		bl	log_char
 105:logger.c      **** }
 1279              		.loc 1 105 0
 1280 0a5c 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1281 0a60 1EFF2FE1 		bx	lr
 1282              	.L94:
 1283              		.align	2
 1284              	.L93:
 1285 0a64 00000000 		.word	.LANCHOR1
 1286              		.cfi_endproc
 1287              	.LFE6:
 1288              		.fnend
 1290              		.align	2
 1291              		.global	log4bytes
 1293              	log4bytes:
 1294              		.fnstart
 1295              	.LFB7:
 106:logger.c      **** 
 107:logger.c      **** void log4bytes(int c){
 1296              		.loc 1 107 0
 1297              		.cfi_startproc
 1298              		@ Function supports interworking.
 1299              		@ args = 0, pretend = 0, frame = 0
 1300              		@ frame_needed = 0, uses_anonymous_args = 0
 1301              	.LVL66:
 1302 0a68 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1303              		.save {r3, r4, r5, lr}
 1304              	.LCFI13:
 1305              		.cfi_def_cfa_offset 16
 108:logger.c      **** 	if(c & 0x80000000){ // se for negativo
 1306              		.loc 1 108 0
 1307 0a6c 004050E2 		subs	r4, r0, #0
 1308              		.cfi_offset 14, -4
 1309              		.cfi_offset 5, -8
 1310              		.cfi_offset 4, -12
 1311              		.cfi_offset 3, -16
 1312 0a70 030000AA 		bge	.L96
 109:logger.c      **** 		log_char('-');
 1313              		.loc 1 109 0
 1314 0a74 2D00A0E3 		mov	r0, #45
 1315              	.LVL67:
 1316 0a78 60FDFFEB 		bl	log_char
 1317              	.LVL68:
 110:logger.c      **** 		c = ~c;
 111:logger.c      **** 		c += 0x1;
 1318              		.loc 1 111 0
 1319 0a7c 004064E2 		rsb	r4, r4, #0
 1320              	.LVL69:
 1321 0a80 010000EA 		b	.L97
 1322              	.LVL70:
 1323              	.L96:
 112:logger.c      **** 	}else
 113:logger.c      **** 		log_char(' ');
 1324              		.loc 1 113 0
 1325 0a84 2000A0E3 		mov	r0, #32
 1326              	.LVL71:
 1327 0a88 5CFDFFEB 		bl	log_char
 1328              	.L97:
 114:logger.c      **** 	log_char(ascii[c >> 28]);
 1329              		.loc 1 114 0
 1330 0a8c 78509FE5 		ldr	r5, .L98
 1331 0a90 440ED5E7 		ldrb	r0, [r5, r4, asr #28]	@ zero_extendqisi2
 1332 0a94 59FDFFEB 		bl	log_char
 115:logger.c      **** 	log_char(ascii[c >> 24 & 0x0000000f]);
 1333              		.loc 1 115 0
 1334 0a98 443CA0E1 		mov	r3, r4, asr #24
 1335 0a9c 0F3003E2 		and	r3, r3, #15
 1336 0aa0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1337 0aa4 55FDFFEB 		bl	log_char
 116:logger.c      **** 	log_char(ascii[c >> 20 & 0x0000000f]);
 1338              		.loc 1 116 0
 1339 0aa8 443AA0E1 		mov	r3, r4, asr #20
 1340 0aac 0F3003E2 		and	r3, r3, #15
 1341 0ab0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1342 0ab4 51FDFFEB 		bl	log_char
 117:logger.c      **** 	log_char(ascii[c >> 16 & 0x0000000f]);
 1343              		.loc 1 117 0
 1344 0ab8 4438A0E1 		mov	r3, r4, asr #16
 1345 0abc 0F3003E2 		and	r3, r3, #15
 1346 0ac0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1347 0ac4 4DFDFFEB 		bl	log_char
 118:logger.c      **** 	log_char(ascii[c >> 12 & 0x0000000f]);
 1348              		.loc 1 118 0
 1349 0ac8 4436A0E1 		mov	r3, r4, asr #12
 1350 0acc 0F3003E2 		and	r3, r3, #15
 1351 0ad0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1352 0ad4 49FDFFEB 		bl	log_char
 119:logger.c      **** 	log_char(ascii[c >> 8 & 0x0000000f]);
 1353              		.loc 1 119 0
 1354 0ad8 4434A0E1 		mov	r3, r4, asr #8
 1355 0adc 0F3003E2 		and	r3, r3, #15
 1356 0ae0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1357 0ae4 45FDFFEB 		bl	log_char
 120:logger.c      **** 	log_char(ascii[c >> 4 & 0x0000000f]);
 1358              		.loc 1 120 0
 1359 0ae8 4432A0E1 		mov	r3, r4, asr #4
 1360 0aec 0F3003E2 		and	r3, r3, #15
 1361 0af0 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 1362 0af4 41FDFFEB 		bl	log_char
 121:logger.c      **** 	log_char(ascii[c & 0x0000000f]);
 1363              		.loc 1 121 0
 1364 0af8 0F4004E2 		and	r4, r4, #15
 1365              	.LVL72:
 1366 0afc 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1367 0b00 3EFDFFEB 		bl	log_char
 122:logger.c      **** }
 1368              		.loc 1 122 0
 1369 0b04 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 1370 0b08 1EFF2FE1 		bx	lr
 1371              	.L99:
 1372              		.align	2
 1373              	.L98:
 1374 0b0c 00000000 		.word	.LANCHOR1
 1375              		.cfi_endproc
 1376              	.LFE7:
 1377              		.fnend
 1379              		.align	2
 1380              		.global	i2c_init
 1382              	i2c_init:
 1383              		.fnstart
 1384              	.LFB15:
  26:i2c.c         **** void i2c_init(void){
 1385              		.loc 2 26 0
 1386              		.cfi_startproc
 1387              		@ Function supports interworking.
 1388              		@ args = 0, pretend = 0, frame = 0
 1389              		@ frame_needed = 0, uses_anonymous_args = 0
 1390              		@ link register save eliminated.
  31:i2c.c         **** 	PINSEL1 |= 0x1 << 2; // SCL1
 1391              		.loc 2 31 0
 1392 0b10 58309FE5 		ldr	r3, .L101
 1393 0b14 042093E5 		ldr	r2, [r3, #4]
 1394 0b18 042082E3 		orr	r2, r2, #4
 1395 0b1c 042083E5 		str	r2, [r3, #4]
  32:i2c.c         **** 	PINSEL1 |= 0x1 << 4; // SDA1
 1396              		.loc 2 32 0
 1397 0b20 042093E5 		ldr	r2, [r3, #4]
 1398 0b24 102082E3 		orr	r2, r2, #16
 1399 0b28 042083E5 		str	r2, [r3, #4]
  34:i2c.c         **** 	I2C1CONCLR = 0x6C; // clear all flags
 1400              		.loc 2 34 0
 1401 0b2c 033883E2 		add	r3, r3, #196608
 1402 0b30 6C20A0E3 		mov	r2, #108
 1403 0b34 1820C3E5 		strb	r2, [r3, #24]
  35:i2c.c         **** 	I2C1CONSET |= 0x1 << 6; // enable i2c1
 1404              		.loc 2 35 0
 1405 0b38 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1406 0b3c FF2002E2 		and	r2, r2, #255
 1407 0b40 402082E3 		orr	r2, r2, #64
 1408 0b44 0020C3E5 		strb	r2, [r3, #0]
  36:i2c.c         **** 	I2C1SCLH = 19; // Set the bit rate:
 1409              		.loc 2 36 0
 1410 0b48 1320A0E3 		mov	r2, #19
 1411 0b4c B021C3E1 		strh	r2, [r3, #16]	@ movhi
  37:i2c.c         **** 	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
 1412              		.loc 2 37 0
 1413 0b50 B421C3E1 		strh	r2, [r3, #20]	@ movhi
  40:i2c.c         **** 	VICVectCntl2 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
 1414              		.loc 2 40 0
 1415 0b54 0030E0E3 		mvn	r3, #0
 1416 0b58 3320A0E3 		mov	r2, #51
 1417 0b5c F72D03E5 		str	r2, [r3, #-3575]
  41:i2c.c         **** 	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
 1418              		.loc 2 41 0
 1419 0b60 EF2F13E5 		ldr	r2, [r3, #-4079]
 1420 0b64 022782E3 		orr	r2, r2, #524288
 1421 0b68 EF2F03E5 		str	r2, [r3, #-4079]
  48:i2c.c         **** }
 1422              		.loc 2 48 0
 1423 0b6c 1EFF2FE1 		bx	lr
 1424              	.L102:
 1425              		.align	2
 1426              	.L101:
 1427 0b70 00C002E0 		.word	-536690688
 1428              		.cfi_endproc
 1429              	.LFE15:
 1430              		.fnend
 1432              		.align	2
 1433              		.global	i2c_read_bytes
 1435              	i2c_read_bytes:
 1436              		.fnstart
 1437              	.LFB17:
  63:i2c.c         **** int i2c_read_bytes(char reg_addr, char length, char* data) {
 1438              		.loc 2 63 0
 1439              		.cfi_startproc
 1440              		@ Function supports interworking.
 1441              		@ args = 0, pretend = 0, frame = 0
 1442              		@ frame_needed = 0, uses_anonymous_args = 0
 1443              		@ link register save eliminated.
 1444              	.LVL73:
  66:i2c.c         **** 	buff_size = length;
 1445              		.loc 2 66 0
 1446 0b74 48309FE5 		ldr	r3, .L106
 1447 0b78 041083E5 		str	r1, [r3, #4]
  67:i2c.c         **** 	buff_pos = 0;
 1448              		.loc 2 67 0
 1449 0b7c 0010A0E3 		mov	r1, #0
 1450              	.LVL74:
 1451 0b80 081083E5 		str	r1, [r3, #8]
  68:i2c.c         **** 	ra_buff = reg_addr;
 1452              		.loc 2 68 0
 1453 0b84 0000C3E5 		strb	r0, [r3, #0]
  69:i2c.c         **** 	c_buff = data;
 1454              		.loc 2 69 0
 1455 0b88 0C2083E5 		str	r2, [r3, #12]
  71:i2c.c         **** 	busy = 1;
 1456              		.loc 2 71 0
 1457 0b8c 0120A0E3 		mov	r2, #1
 1458              	.LVL75:
 1459 0b90 102083E5 		str	r2, [r3, #16]
  74:i2c.c         **** 	VICVectAddr2 = (unsigned int) &i2c_read_bytes_isr;
 1460              		.loc 2 74 0
 1461 0b94 0030E0E3 		mvn	r3, #0
 1462 0b98 28209FE5 		ldr	r2, .L106+4
 1463 0b9c F72E03E5 		str	r2, [r3, #-3831]
  77:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 1464              		.loc 2 77 0
 1465 0ba0 2020A0E3 		mov	r2, #32
 1466 0ba4 20309FE5 		ldr	r3, .L106+8
 1467 0ba8 0020C3E5 		strb	r2, [r3, #0]
  81:i2c.c         **** 	while (busy); // busy wait for read process
 1468              		.loc 2 81 0
 1469 0bac 10209FE5 		ldr	r2, .L106
 1470              	.L104:
  81:i2c.c         **** 	while (busy); // busy wait for read process
 1471              		.loc 2 81 0 is_stmt 0 discriminator 1
 1472 0bb0 103092E5 		ldr	r3, [r2, #16]
 1473 0bb4 000053E3 		cmp	r3, #0
 1474 0bb8 FCFFFF1A 		bne	.L104
  85:i2c.c         **** }
 1475              		.loc 2 85 0 is_stmt 1
 1476 0bbc 0100A0E3 		mov	r0, #1
 1477              	.LVL76:
 1478 0bc0 1EFF2FE1 		bx	lr
 1479              	.L107:
 1480              		.align	2
 1481              	.L106:
 1482 0bc4 00000000 		.word	.LANCHOR0
 1483 0bc8 00000000 		.word	i2c_read_bytes_isr
 1484 0bcc 00C005E0 		.word	-536494080
 1485              		.cfi_endproc
 1486              	.LFE17:
 1487              		.fnend
 1489              		.align	2
 1490              		.global	i2c_read_byte
 1492              	i2c_read_byte:
 1493              		.fnstart
 1494              	.LFB16:
  54:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
 1495              		.loc 2 54 0
 1496              		.cfi_startproc
 1497              		@ Function supports interworking.
 1498              		@ args = 0, pretend = 0, frame = 0
 1499              		@ frame_needed = 0, uses_anonymous_args = 0
 1500              	.LVL77:
 1501 0bd0 08402DE9 		stmfd	sp!, {r3, lr}
 1502              		.save {r3, lr}
 1503              	.LCFI14:
 1504              		.cfi_def_cfa_offset 8
 1505 0bd4 0120A0E1 		mov	r2, r1
  57:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
 1506              		.loc 2 57 0
 1507 0bd8 0110A0E3 		mov	r1, #1
 1508              	.LVL78:
 1509              		.cfi_offset 14, -4
 1510              		.cfi_offset 3, -8
 1511 0bdc FEFFFFEB 		bl	i2c_read_bytes
 1512              	.LVL79:
  61:i2c.c         **** }
 1513              		.loc 2 61 0
 1514 0be0 0840BDE8 		ldmfd	sp!, {r3, lr}
 1515 0be4 1EFF2FE1 		bx	lr
 1516              		.cfi_endproc
 1517              	.LFE16:
 1518              		.fnend
 1520              		.align	2
 1521              		.global	i2c_write_byte
 1523              	i2c_write_byte:
 1524              		.fnstart
 1525              	.LFB20:
 195:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 1526              		.loc 2 195 0
 1527              		.cfi_startproc
 1528              		@ Function supports interworking.
 1529              		@ args = 0, pretend = 0, frame = 8
 1530              		@ frame_needed = 0, uses_anonymous_args = 0
 1531              		@ link register save eliminated.
 1532              	.LVL80:
 1533              		.pad #8
 1534 0be8 08D04DE2 		sub	sp, sp, #8
 1535              	.LCFI15:
 1536              		.cfi_def_cfa_offset 8
 1537 0bec 08308DE2 		add	r3, sp, #8
 1538 0bf0 011063E5 		strb	r1, [r3, #-1]!
 198:i2c.c         **** 	buff_size = 1;
 1539              		.loc 2 198 0
 1540 0bf4 4C209FE5 		ldr	r2, .L112
 1541 0bf8 0110A0E3 		mov	r1, #1
 1542              	.LVL81:
 1543 0bfc 041082E5 		str	r1, [r2, #4]
 199:i2c.c         **** 	buff_pos = 0;
 1544              		.loc 2 199 0
 1545 0c00 00C0A0E3 		mov	ip, #0
 1546 0c04 08C082E5 		str	ip, [r2, #8]
 200:i2c.c         **** 	ra_buff = reg_addr;
 1547              		.loc 2 200 0
 1548 0c08 0000C2E5 		strb	r0, [r2, #0]
 201:i2c.c         **** 	c_buff = &data;
 1549              		.loc 2 201 0
 1550 0c0c 0C3082E5 		str	r3, [r2, #12]
 203:i2c.c         **** 	busy = 1;
 1551              		.loc 2 203 0
 1552 0c10 101082E5 		str	r1, [r2, #16]
 206:i2c.c         **** 	VICVectAddr2 = (unsigned int) &i2c_write_byte_isr;
 1553              		.loc 2 206 0
 1554 0c14 0030E0E3 		mvn	r3, #0
 1555 0c18 2C209FE5 		ldr	r2, .L112+4
 1556 0c1c F72E03E5 		str	r2, [r3, #-3831]
 209:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 1557              		.loc 2 209 0
 1558 0c20 2020A0E3 		mov	r2, #32
 1559 0c24 24309FE5 		ldr	r3, .L112+8
 1560 0c28 0020C3E5 		strb	r2, [r3, #0]
 211:i2c.c         **** 	while (busy); // busy wait for read process
 1561              		.loc 2 211 0
 1562 0c2c 14209FE5 		ldr	r2, .L112
 1563              	.L110:
 211:i2c.c         **** 	while (busy); // busy wait for read process
 1564              		.loc 2 211 0 is_stmt 0 discriminator 1
 1565 0c30 103092E5 		ldr	r3, [r2, #16]
 1566 0c34 000053E3 		cmp	r3, #0
 1567 0c38 FCFFFF1A 		bne	.L110
 215:i2c.c         **** }
 1568              		.loc 2 215 0 is_stmt 1
 1569 0c3c 0100A0E3 		mov	r0, #1
 1570              	.LVL82:
 1571 0c40 08D08DE2 		add	sp, sp, #8
 1572 0c44 1EFF2FE1 		bx	lr
 1573              	.L113:
 1574              		.align	2
 1575              	.L112:
 1576 0c48 00000000 		.word	.LANCHOR0
 1577 0c4c 00000000 		.word	i2c_write_byte_isr
 1578 0c50 00C005E0 		.word	-536494080
 1579              		.cfi_endproc
 1580              	.LFE20:
 1581              		.fnend
 1583              		.align	2
 1584              		.global	i2c_write_bits
 1586              	i2c_write_bits:
 1587              		.fnstart
 1588              	.LFB19:
 175:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 1589              		.loc 2 175 0
 1590              		.cfi_startproc
 1591              		@ Function supports interworking.
 1592              		@ args = 0, pretend = 0, frame = 8
 1593              		@ frame_needed = 0, uses_anonymous_args = 0
 1594              	.LVL83:
 1595 0c54 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1596              		.save {r4, r5, r6, r7, lr}
 1597              	.LCFI16:
 1598              		.cfi_def_cfa_offset 20
 1599              		.pad #12
 1600 0c58 0CD04DE2 		sub	sp, sp, #12
 1601              	.LCFI17:
 1602              		.cfi_def_cfa_offset 32
 1603 0c5c 0070A0E1 		mov	r7, r0
 1604              		.cfi_offset 14, -4
 1605              		.cfi_offset 7, -8
 1606              		.cfi_offset 6, -12
 1607              		.cfi_offset 5, -16
 1608              		.cfi_offset 4, -20
 1609 0c60 0150A0E1 		mov	r5, r1
 1610 0c64 0240A0E1 		mov	r4, r2
 1611 0c68 0360A0E1 		mov	r6, r3
 185:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 1612              		.loc 2 185 0
 1613 0c6c 07108DE2 		add	r1, sp, #7
 1614              	.LVL84:
 1615 0c70 FEFFFFEB 		bl	i2c_read_byte
 1616              	.LVL85:
 186:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 1617              		.loc 2 186 0
 1618 0c74 015085E2 		add	r5, r5, #1
 1619 0c78 055064E0 		rsb	r5, r4, r5
 1620 0c7c 0030E0E3 		mvn	r3, #0
 1621 0c80 1344E0E1 		mvn	r4, r3, asl r4
 1622 0c84 1445A0E1 		mov	r4, r4, asl r5
 1623 0c88 FF4004E2 		and	r4, r4, #255
 1624              	.LVL86:
 189:i2c.c         **** 	c &= ~(mask); // zero all important bits in existing byte
 1625              		.loc 2 189 0
 1626 0c8c 0710DDE5 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
 1627              	.LVL87:
 1628 0c90 0410C1E1 		bic	r1, r1, r4
 1629              	.LVL88:
 188:i2c.c         **** 	data &= mask; // zero all non-important bits in data
 1630              		.loc 2 188 0
 1631 0c94 166504E0 		and	r6, r4, r6, asl r5
 1632              	.LVL89:
 190:i2c.c         **** 	c |= data; // combine data with existing byte
 1633              		.loc 2 190 0
 1634 0c98 061081E1 		orr	r1, r1, r6
 1635              	.LVL90:
 1636 0c9c 0710CDE5 		strb	r1, [sp, #7]
 192:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 1637              		.loc 2 192 0
 1638 0ca0 0700A0E1 		mov	r0, r7
 1639 0ca4 FEFFFFEB 		bl	i2c_write_byte
 1640              	.LVL91:
 193:i2c.c         **** }
 1641              		.loc 2 193 0
 1642 0ca8 0CD08DE2 		add	sp, sp, #12
 1643 0cac F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1644 0cb0 1EFF2FE1 		bx	lr
 1645              		.cfi_endproc
 1646              	.LFE19:
 1647              		.fnend
 1649              		.align	2
 1650              		.global	mpu_set_clock_source
 1652              	mpu_set_clock_source:
 1653              		.fnstart
 1654              	.LFB23:
 1655              		.file 4 "mpu6050.c"
   1:mpu6050.c     **** /*
   2:mpu6050.c     ****  * mpu6050.c
   3:mpu6050.c     ****  *
   4:mpu6050.c     ****  *  Created on: Mar 21, 2013
   5:mpu6050.c     ****  *      Author: telmo
   6:mpu6050.c     ****  *
   7:mpu6050.c     ****  *  This code was based on Jeff Rowberg code for arduino https://github.com/jrowberg/i2cdevlib/tree
   8:mpu6050.c     ****  */
   9:mpu6050.c     **** #include "lpc2103.h"
  10:mpu6050.c     **** #include "i2c.h"
  11:mpu6050.c     **** #include "logger.h"
  12:mpu6050.c     **** #include "mpu6050.h"
  13:mpu6050.c     **** 
  14:mpu6050.c     **** /** Power on and prepare for general usage.
  15:mpu6050.c     **** * This will activate the device and take it out of sleep mode (which must be done
  16:mpu6050.c     **** * after start-up). This function also sets both the accelerometer and the gyroscope
  17:mpu6050.c     **** * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
  18:mpu6050.c     **** * the clock source to use the X Gyro for reference, which is slightly better than
  19:mpu6050.c     **** * the default internal clock source.
  20:mpu6050.c     **** */
  21:mpu6050.c     **** void mpu_init(void) {
  22:mpu6050.c     **** 	log_string_mpu(">> mpu_init\n");
  23:mpu6050.c     **** 
  24:mpu6050.c     ****     // configure clock source
  25:mpu6050.c     **** 	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
  26:mpu6050.c     **** 	// disable temperature sensor
  27:mpu6050.c     **** 	mpu_set_temperature_sensor_enabled(0);
  28:mpu6050.c     **** 	// set scale to
  29:mpu6050.c     **** 	// acc ±2g 16384 LSB/g
  30:mpu6050.c     **** 	// gyro ± 250 °/s 131 LSB/°/s
  31:mpu6050.c     ****     mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
  32:mpu6050.c     ****     mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
  33:mpu6050.c     **** 
  34:mpu6050.c     ****     // divide gyro output rate by 7+1, if DLPF>0 set back to 0 to keep output rate 1kHz
  35:mpu6050.c     ****     mpu_set_gyro_rate(7);
  36:mpu6050.c     ****     // set digital low pass filter cut off frequency (disabled)
  37:mpu6050.c     ****     mpu_set_DLPF_mode(0);
  38:mpu6050.c     **** 
  39:mpu6050.c     ****     // FIFO WAS NOT USED
  40:mpu6050.c     ****     // enable FIFO
  41:mpu6050.c     ****     mpu_set_6axis_FIFO_enabled(1);
  42:mpu6050.c     **** 
  43:mpu6050.c     ****     // DATAREADY INTERRUPT WAS NOT USED
  44:mpu6050.c     ****     // configure interruption
  45:mpu6050.c     ****     //mpu_set_interrupt_mode(0); // active high
  46:mpu6050.c     ****     //mpu_set_interrupt_drive(0); // push/pull
  47:mpu6050.c     ****     //mpu_set_interrupt_latch(0); // 50us pulse on interrupt
  48:mpu6050.c     ****     //mpu_set_FIFO_overflow_interrupt(1); // generate interrupt on FIFO overflow
  49:mpu6050.c     ****     //mpu_set_data_ready_interrupt(1); // data ready interrupt
  50:mpu6050.c     **** 
  51:mpu6050.c     ****     // clear interrupts
  52:mpu6050.c     **** 	//char source;
  53:mpu6050.c     **** 	//mpu_clear_interrupt(&source);
  54:mpu6050.c     ****     // reset FIFO
  55:mpu6050.c     ****     mpu_reset_FIFO();
  56:mpu6050.c     ****     // enable fifo
  57:mpu6050.c     ****     mpu_set_FIFO_enabled(1);
  58:mpu6050.c     **** 
  59:mpu6050.c     ****     // stop sleeping
  60:mpu6050.c     ****     mpu_set_sleep_enable(0);
  61:mpu6050.c     **** 
  62:mpu6050.c     **** 	log_string_mpu("<< mpu_init\n");
  63:mpu6050.c     **** }
  64:mpu6050.c     **** 
  65:mpu6050.c     **** /** Set clock source setting.
  66:mpu6050.c     **** * An internal 8MHz oscillator, gyroscope based clock, or external sources can
  67:mpu6050.c     **** * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator
  68:mpu6050.c     **** * or an external source is chosen as the clock source, the MPU-60X0 can operate
  69:mpu6050.c     **** * in low power modes with the gyroscopes disabled.
  70:mpu6050.c     **** *
  71:mpu6050.c     **** * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.
  72:mpu6050.c     **** * However, it is highly recommended that the device be configured to use one of
  73:mpu6050.c     **** * the gyroscopes (or an external clock source) as the clock reference for
  74:mpu6050.c     **** * improved stability. The clock source can be selected according to the following table:
  75:mpu6050.c     **** *
  76:mpu6050.c     **** * <pre>
  77:mpu6050.c     **** * CLK_SEL | Clock Source
  78:mpu6050.c     **** * --------+--------------------------------------
  79:mpu6050.c     **** * 0 | Internal oscillator
  80:mpu6050.c     **** * 1 | PLL with X Gyro reference
  81:mpu6050.c     **** * 2 | PLL with Y Gyro reference
  82:mpu6050.c     **** * 3 | PLL with Z Gyro reference
  83:mpu6050.c     **** * 4 | PLL with external 32.768kHz reference
  84:mpu6050.c     **** * 5 | PLL with external 19.2MHz reference
  85:mpu6050.c     **** * 6 | Reserved
  86:mpu6050.c     **** * 7 | Stops the clock and keeps the timing generator in reset
  87:mpu6050.c     **** * </pre>
  88:mpu6050.c     **** *
  89:mpu6050.c     **** * @param source New clock source setting
  90:mpu6050.c     **** * @see getClockSource()
  91:mpu6050.c     **** * @see MPU6050_RA_PWR_MGMT_1
  92:mpu6050.c     **** * @see MPU6050_PWR1_CLKSEL_BIT
  93:mpu6050.c     **** * @see MPU6050_PWR1_CLKSEL_LENGTH
  94:mpu6050.c     **** */
  95:mpu6050.c     **** void mpu_set_clock_source(char source) {
 1656              		.loc 4 95 0
 1657              		.cfi_startproc
 1658              		@ Function supports interworking.
 1659              		@ args = 0, pretend = 0, frame = 0
 1660              		@ frame_needed = 0, uses_anonymous_args = 0
 1661              	.LVL92:
 1662 0cb4 08402DE9 		stmfd	sp!, {r3, lr}
 1663              		.save {r3, lr}
 1664              	.LCFI18:
 1665              		.cfi_def_cfa_offset 8
 1666 0cb8 0030A0E1 		mov	r3, r0
 1667              		.cfi_offset 14, -4
 1668              		.cfi_offset 3, -8
  96:mpu6050.c     ****     i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, sour
 1669              		.loc 4 96 0
 1670 0cbc 6B00A0E3 		mov	r0, #107
 1671              	.LVL93:
 1672 0cc0 0210A0E3 		mov	r1, #2
 1673 0cc4 0320A0E3 		mov	r2, #3
 1674 0cc8 FEFFFFEB 		bl	i2c_write_bits
  97:mpu6050.c     **** }
 1675              		.loc 4 97 0
 1676 0ccc 0840BDE8 		ldmfd	sp!, {r3, lr}
 1677 0cd0 1EFF2FE1 		bx	lr
 1678              		.cfi_endproc
 1679              	.LFE23:
 1680              		.fnend
 1682              		.align	2
 1683              		.global	mpu_set_full_scale_gyro_range
 1685              	mpu_set_full_scale_gyro_range:
 1686              		.fnstart
 1687              	.LFB24:
  98:mpu6050.c     **** 
  99:mpu6050.c     **** /** Set full-scale gyroscope range.
 100:mpu6050.c     **** * @param range New full-scale gyroscope range value
 101:mpu6050.c     **** * @see getFullScaleRange()
 102:mpu6050.c     **** * @see MPU6050_GYRO_FS_250
 103:mpu6050.c     **** * @see MPU6050_RA_GYRO_CONFIG
 104:mpu6050.c     **** * @see MPU6050_GCONFIG_FS_SEL_BIT
 105:mpu6050.c     **** * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 106:mpu6050.c     **** */
 107:mpu6050.c     **** void mpu_set_full_scale_gyro_range(char range) {
 1688              		.loc 4 107 0
 1689              		.cfi_startproc
 1690              		@ Function supports interworking.
 1691              		@ args = 0, pretend = 0, frame = 0
 1692              		@ frame_needed = 0, uses_anonymous_args = 0
 1693              	.LVL94:
 1694 0cd4 08402DE9 		stmfd	sp!, {r3, lr}
 1695              		.save {r3, lr}
 1696              	.LCFI19:
 1697              		.cfi_def_cfa_offset 8
 1698 0cd8 0030A0E1 		mov	r3, r0
 1699              		.cfi_offset 14, -4
 1700              		.cfi_offset 3, -8
 108:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, 
 1701              		.loc 4 108 0
 1702 0cdc 1B00A0E3 		mov	r0, #27
 1703              	.LVL95:
 1704 0ce0 0410A0E3 		mov	r1, #4
 1705 0ce4 0220A0E3 		mov	r2, #2
 1706 0ce8 FEFFFFEB 		bl	i2c_write_bits
 109:mpu6050.c     **** }
 1707              		.loc 4 109 0
 1708 0cec 0840BDE8 		ldmfd	sp!, {r3, lr}
 1709 0cf0 1EFF2FE1 		bx	lr
 1710              		.cfi_endproc
 1711              	.LFE24:
 1712              		.fnend
 1714              		.align	2
 1715              		.global	mpu_set_full_scale_accel_range
 1717              	mpu_set_full_scale_accel_range:
 1718              		.fnstart
 1719              	.LFB25:
 110:mpu6050.c     **** 
 111:mpu6050.c     **** /** Set full-scale accelerometer range.
 112:mpu6050.c     **** * @param range New full-scale accelerometer range setting
 113:mpu6050.c     **** * @see getFullScaleAccelRange()
 114:mpu6050.c     **** */
 115:mpu6050.c     **** void mpu_set_full_scale_accel_range(char range) {
 1720              		.loc 4 115 0
 1721              		.cfi_startproc
 1722              		@ Function supports interworking.
 1723              		@ args = 0, pretend = 0, frame = 0
 1724              		@ frame_needed = 0, uses_anonymous_args = 0
 1725              	.LVL96:
 1726 0cf4 08402DE9 		stmfd	sp!, {r3, lr}
 1727              		.save {r3, lr}
 1728              	.LCFI20:
 1729              		.cfi_def_cfa_offset 8
 1730 0cf8 0030A0E1 		mov	r3, r0
 1731              		.cfi_offset 14, -4
 1732              		.cfi_offset 3, -8
 116:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGT
 1733              		.loc 4 116 0
 1734 0cfc 1C00A0E3 		mov	r0, #28
 1735              	.LVL97:
 1736 0d00 0410A0E3 		mov	r1, #4
 1737 0d04 0220A0E3 		mov	r2, #2
 1738 0d08 FEFFFFEB 		bl	i2c_write_bits
 117:mpu6050.c     **** }
 1739              		.loc 4 117 0
 1740 0d0c 0840BDE8 		ldmfd	sp!, {r3, lr}
 1741 0d10 1EFF2FE1 		bx	lr
 1742              		.cfi_endproc
 1743              	.LFE25:
 1744              		.fnend
 1746              		.align	2
 1747              		.global	mpu_set_sleep_enable
 1749              	mpu_set_sleep_enable:
 1750              		.fnstart
 1751              	.LFB26:
 118:mpu6050.c     **** 
 119:mpu6050.c     **** /** Set sleep mode status.
 120:mpu6050.c     **** * @param enabled New sleep mode enabled status
 121:mpu6050.c     **** * @see getSleepEnabled()
 122:mpu6050.c     **** * @see MPU6050_RA_PWR_MGMT_1
 123:mpu6050.c     **** * @see MPU6050_PWR1_SLEEP_BIT
 124:mpu6050.c     **** */
 125:mpu6050.c     **** void mpu_set_sleep_enable(int enable) {
 1752              		.loc 4 125 0
 1753              		.cfi_startproc
 1754              		@ Function supports interworking.
 1755              		@ args = 0, pretend = 0, frame = 0
 1756              		@ frame_needed = 0, uses_anonymous_args = 0
 1757              	.LVL98:
 1758 0d14 08402DE9 		stmfd	sp!, {r3, lr}
 1759              		.save {r3, lr}
 1760              	.LCFI21:
 1761              		.cfi_def_cfa_offset 8
 126:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, enable);
 1762              		.loc 4 126 0
 1763 0d18 FF3000E2 		and	r3, r0, #255
 1764              		.cfi_offset 14, -4
 1765              		.cfi_offset 3, -8
 1766 0d1c 6B00A0E3 		mov	r0, #107
 1767              	.LVL99:
 1768 0d20 0610A0E3 		mov	r1, #6
 1769 0d24 0120A0E3 		mov	r2, #1
 1770 0d28 FEFFFFEB 		bl	i2c_write_bits
 127:mpu6050.c     **** }
 1771              		.loc 4 127 0
 1772 0d2c 0840BDE8 		ldmfd	sp!, {r3, lr}
 1773 0d30 1EFF2FE1 		bx	lr
 1774              		.cfi_endproc
 1775              	.LFE26:
 1776              		.fnend
 1778              		.align	2
 1779              		.global	mpu_set_temperature_sensor_enabled
 1781              	mpu_set_temperature_sensor_enabled:
 1782              		.fnstart
 1783              	.LFB27:
 128:mpu6050.c     **** 
 129:mpu6050.c     **** /**
 130:mpu6050.c     ****  * Set temperature sensor enabled status.
 131:mpu6050.c     ****  * Note: this register stores the *disabled* value, but for consistency with the
 132:mpu6050.c     ****  * rest of the code, the function is named and used with standard true/false
 133:mpu6050.c     ****  * values to indicate whether the sensor is enabled or disabled, respectively.
 134:mpu6050.c     ****  * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 135:mpu6050.c     ****  * bit automatically clears to 0 after the reset has been triggered.
 136:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 137:mpu6050.c     ****  */
 138:mpu6050.c     **** void mpu_set_temperature_sensor_enabled(char enabled) {
 1784              		.loc 4 138 0
 1785              		.cfi_startproc
 1786              		@ Function supports interworking.
 1787              		@ args = 0, pretend = 0, frame = 0
 1788              		@ frame_needed = 0, uses_anonymous_args = 0
 1789              	.LVL100:
 1790 0d34 08402DE9 		stmfd	sp!, {r3, lr}
 1791              		.save {r3, lr}
 1792              	.LCFI22:
 1793              		.cfi_def_cfa_offset 8
 139:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, 1, 1-enabled);
 1794              		.loc 4 139 0
 1795 0d38 013060E2 		rsb	r3, r0, #1
 1796              		.cfi_offset 14, -4
 1797              		.cfi_offset 3, -8
 1798 0d3c FF3003E2 		and	r3, r3, #255
 1799 0d40 6B00A0E3 		mov	r0, #107
 1800              	.LVL101:
 1801 0d44 0310A0E3 		mov	r1, #3
 1802 0d48 0120A0E3 		mov	r2, #1
 1803 0d4c FEFFFFEB 		bl	i2c_write_bits
 140:mpu6050.c     **** }
 1804              		.loc 4 140 0
 1805 0d50 0840BDE8 		ldmfd	sp!, {r3, lr}
 1806 0d54 1EFF2FE1 		bx	lr
 1807              		.cfi_endproc
 1808              	.LFE27:
 1809              		.fnend
 1811              		.align	2
 1812              		.global	mpu_set_gyro_rate
 1814              	mpu_set_gyro_rate:
 1815              		.fnstart
 1816              	.LFB28:
 141:mpu6050.c     **** 
 142:mpu6050.c     **** /** Set gyroscope output rate divider.
 143:mpu6050.c     **** * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
 144:mpu6050.c     **** * Motion detection, and Free Fall detection are all based on the Sample Rate.
 145:mpu6050.c     **** * The Sample Rate is generated by dividing the gyroscope output rate by
 146:mpu6050.c     **** * SMPLRT_DIV:
 147:mpu6050.c     **** *
 148:mpu6050.c     **** * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 149:mpu6050.c     **** *
 150:mpu6050.c     **** * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
 151:mpu6050.c     **** * 7), and 1kHz when the DLPF is enabled (see Register 26).
 152:mpu6050.c     **** *
 153:mpu6050.c     **** * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 154:mpu6050.c     **** * Rate greater than 1kHz, the same accelerometer sample may be output to the
 155:mpu6050.c     **** * FIFO, DMP, and sensor registers more than once.
 156:mpu6050.c     **** *
 157:mpu6050.c     **** * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
 158:mpu6050.c     **** * of the MPU-6000/MPU-6050 Product Specification document.
 159:mpu6050.c     **** *
 160:mpu6050.c     **** * @param rate New sample rate divider
 161:mpu6050.c     **** * @see getRate()
 162:mpu6050.c     **** * @see MPU6050_RA_SMPLRT_DIV
 163:mpu6050.c     **** */
 164:mpu6050.c     **** void mpu_set_gyro_rate(char rate) {
 1817              		.loc 4 164 0
 1818              		.cfi_startproc
 1819              		@ Function supports interworking.
 1820              		@ args = 0, pretend = 0, frame = 0
 1821              		@ frame_needed = 0, uses_anonymous_args = 0
 1822              	.LVL102:
 1823 0d58 08402DE9 		stmfd	sp!, {r3, lr}
 1824              		.save {r3, lr}
 1825              	.LCFI23:
 1826              		.cfi_def_cfa_offset 8
 1827 0d5c 0010A0E1 		mov	r1, r0
 165:mpu6050.c     ****     i2c_write_byte(MPU6050_RA_SMPLRT_DIV, rate);
 1828              		.loc 4 165 0
 1829 0d60 1900A0E3 		mov	r0, #25
 1830              	.LVL103:
 1831              		.cfi_offset 14, -4
 1832              		.cfi_offset 3, -8
 1833 0d64 FEFFFFEB 		bl	i2c_write_byte
 166:mpu6050.c     **** }
 1834              		.loc 4 166 0
 1835 0d68 0840BDE8 		ldmfd	sp!, {r3, lr}
 1836 0d6c 1EFF2FE1 		bx	lr
 1837              		.cfi_endproc
 1838              	.LFE28:
 1839              		.fnend
 1841              		.align	2
 1842              		.global	mpu_set_DLPF_mode
 1844              	mpu_set_DLPF_mode:
 1845              		.fnstart
 1846              	.LFB29:
 167:mpu6050.c     **** 
 168:mpu6050.c     **** /** Get digital low-pass filter configuration.
 169:mpu6050.c     **** * The DLPF_CFG parameter sets the digital low pass filter configuration. It
 170:mpu6050.c     **** * also determines the internal sampling rate used by the device as shown in
 171:mpu6050.c     **** * the table below.
 172:mpu6050.c     **** *
 173:mpu6050.c     **** * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 174:mpu6050.c     **** * Rate greater than 1kHz, the same accelerometer sample may be output to the
 175:mpu6050.c     **** * FIFO, DMP, and sensor registers more than once.
 176:mpu6050.c     **** *
 177:mpu6050.c     **** * <pre>
 178:mpu6050.c     **** * | ACCELEROMETER | GYROSCOPE
 179:mpu6050.c     **** * DLPF_CFG | Bandwidth | Delay | Bandwidth | Delay | Sample Rate
 180:mpu6050.c     **** * ---------+-----------+--------+-----------+--------+-------------
 181:mpu6050.c     **** * 0 | 260Hz | 0ms | 256Hz | 0.98ms | 8kHz
 182:mpu6050.c     **** * 1 | 184Hz | 2.0ms | 188Hz | 1.9ms | 1kHz
 183:mpu6050.c     **** * 2 | 94Hz | 3.0ms | 98Hz | 2.8ms | 1kHz
 184:mpu6050.c     **** * 3 | 44Hz | 4.9ms | 42Hz | 4.8ms | 1kHz
 185:mpu6050.c     **** * 4 | 21Hz | 8.5ms | 20Hz | 8.3ms | 1kHz
 186:mpu6050.c     **** * 5 | 10Hz | 13.8ms | 10Hz | 13.4ms | 1kHz
 187:mpu6050.c     **** * 6 | 5Hz | 19.0ms | 5Hz | 18.6ms | 1kHz
 188:mpu6050.c     **** * 7 | -- Reserved -- | -- Reserved -- | Reserved
 189:mpu6050.c     **** * </pre>
 190:mpu6050.c     **** *
 191:mpu6050.c     **** * @return DLFP configuration
 192:mpu6050.c     **** * @see MPU6050_RA_CONFIG
 193:mpu6050.c     **** * @see MPU6050_CFG_DLPF_CFG_BIT
 194:mpu6050.c     **** * @see MPU6050_CFG_DLPF_CFG_LENGTH
 195:mpu6050.c     **** */
 196:mpu6050.c     **** void mpu_set_DLPF_mode(char mode) {
 1847              		.loc 4 196 0
 1848              		.cfi_startproc
 1849              		@ Function supports interworking.
 1850              		@ args = 0, pretend = 0, frame = 0
 1851              		@ frame_needed = 0, uses_anonymous_args = 0
 1852              	.LVL104:
 1853 0d70 08402DE9 		stmfd	sp!, {r3, lr}
 1854              		.save {r3, lr}
 1855              	.LCFI24:
 1856              		.cfi_def_cfa_offset 8
 1857 0d74 0030A0E1 		mov	r3, r0
 1858              		.cfi_offset 14, -4
 1859              		.cfi_offset 3, -8
 197:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
 1860              		.loc 4 197 0
 1861 0d78 1A00A0E3 		mov	r0, #26
 1862              	.LVL105:
 1863 0d7c 0210A0E3 		mov	r1, #2
 1864 0d80 0320A0E3 		mov	r2, #3
 1865 0d84 FEFFFFEB 		bl	i2c_write_bits
 198:mpu6050.c     **** }
 1866              		.loc 4 198 0
 1867 0d88 0840BDE8 		ldmfd	sp!, {r3, lr}
 1868 0d8c 1EFF2FE1 		bx	lr
 1869              		.cfi_endproc
 1870              	.LFE29:
 1871              		.fnend
 1873              		.align	2
 1874              		.global	mpu_set_6axis_FIFO_enabled
 1876              	mpu_set_6axis_FIFO_enabled:
 1877              		.fnstart
 1878              	.LFB30:
 199:mpu6050.c     **** 
 200:mpu6050.c     **** /**
 201:mpu6050.c     ****  * Configure FIFO to store data from accelerometer temp and gyro
 202:mpu6050.c     ****  * @param enabled 0 disabled; 1 enabled
 203:mpu6050.c     ****  */
 204:mpu6050.c     **** void mpu_set_6axis_FIFO_enabled(char enabled) {
 1879              		.loc 4 204 0
 1880              		.cfi_startproc
 1881              		@ Function supports interworking.
 1882              		@ args = 0, pretend = 0, frame = 0
 1883              		@ frame_needed = 0, uses_anonymous_args = 0
 1884              	.LVL106:
 1885 0d90 08402DE9 		stmfd	sp!, {r3, lr}
 1886              		.save {r3, lr}
 1887              	.LCFI25:
 1888              		.cfi_def_cfa_offset 8
 205:mpu6050.c     **** 	i2c_write_byte(MPU6050_RA_FIFO_EN, 0x78);
 1889              		.loc 4 205 0
 1890 0d94 2300A0E3 		mov	r0, #35
 1891              	.LVL107:
 1892 0d98 7810A0E3 		mov	r1, #120
 1893              		.cfi_offset 14, -4
 1894              		.cfi_offset 3, -8
 1895 0d9c FEFFFFEB 		bl	i2c_write_byte
 206:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, 1, enabled);
 207:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, 1, 0);
 208:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, 1, enabled);
 209:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, 1, enabled);
 210:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, 1, enabled);
 211:mpu6050.c     **** }
 1896              		.loc 4 211 0
 1897 0da0 0840BDE8 		ldmfd	sp!, {r3, lr}
 1898 0da4 1EFF2FE1 		bx	lr
 1899              		.cfi_endproc
 1900              	.LFE30:
 1901              		.fnend
 1903              		.align	2
 1904              		.global	mpu_set_interrupt_mode
 1906              	mpu_set_interrupt_mode:
 1907              		.fnstart
 1908              	.LFB31:
 212:mpu6050.c     **** 
 213:mpu6050.c     **** /**
 214:mpu6050.c     ****  * Configure interruption mode
 215:mpu6050.c     ****  * @param mode 0 active high; 1 active low
 216:mpu6050.c     ****  */
 217:mpu6050.c     **** void mpu_set_interrupt_mode(char mode) {
 1909              		.loc 4 217 0
 1910              		.cfi_startproc
 1911              		@ Function supports interworking.
 1912              		@ args = 0, pretend = 0, frame = 0
 1913              		@ frame_needed = 0, uses_anonymous_args = 0
 1914              	.LVL108:
 1915 0da8 08402DE9 		stmfd	sp!, {r3, lr}
 1916              		.save {r3, lr}
 1917              	.LCFI26:
 1918              		.cfi_def_cfa_offset 8
 1919 0dac 0030A0E1 		mov	r3, r0
 1920              		.cfi_offset 14, -4
 1921              		.cfi_offset 3, -8
 218:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, 1, mode);
 1922              		.loc 4 218 0
 1923 0db0 3700A0E3 		mov	r0, #55
 1924              	.LVL109:
 1925 0db4 0710A0E3 		mov	r1, #7
 1926 0db8 0120A0E3 		mov	r2, #1
 1927 0dbc FEFFFFEB 		bl	i2c_write_bits
 219:mpu6050.c     **** }
 1928              		.loc 4 219 0
 1929 0dc0 0840BDE8 		ldmfd	sp!, {r3, lr}
 1930 0dc4 1EFF2FE1 		bx	lr
 1931              		.cfi_endproc
 1932              	.LFE31:
 1933              		.fnend
 1935              		.align	2
 1936              		.global	mpu_set_interrupt_drive
 1938              	mpu_set_interrupt_drive:
 1939              		.fnstart
 1940              	.LFB32:
 220:mpu6050.c     **** 
 221:mpu6050.c     **** /**
 222:mpu6050.c     ****  * Set interrupt drive mode
 223:mpu6050.c     ****  * @param drive 0 push/pull; 1 open-drain
 224:mpu6050.c     ****  */
 225:mpu6050.c     **** void mpu_set_interrupt_drive(char drive) {
 1941              		.loc 4 225 0
 1942              		.cfi_startproc
 1943              		@ Function supports interworking.
 1944              		@ args = 0, pretend = 0, frame = 0
 1945              		@ frame_needed = 0, uses_anonymous_args = 0
 1946              	.LVL110:
 1947 0dc8 08402DE9 		stmfd	sp!, {r3, lr}
 1948              		.save {r3, lr}
 1949              	.LCFI27:
 1950              		.cfi_def_cfa_offset 8
 1951 0dcc 0030A0E1 		mov	r3, r0
 1952              		.cfi_offset 14, -4
 1953              		.cfi_offset 3, -8
 226:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, 1, drive);
 1954              		.loc 4 226 0
 1955 0dd0 3700A0E3 		mov	r0, #55
 1956              	.LVL111:
 1957 0dd4 0610A0E3 		mov	r1, #6
 1958 0dd8 0120A0E3 		mov	r2, #1
 1959 0ddc FEFFFFEB 		bl	i2c_write_bits
 227:mpu6050.c     **** }
 1960              		.loc 4 227 0
 1961 0de0 0840BDE8 		ldmfd	sp!, {r3, lr}
 1962 0de4 1EFF2FE1 		bx	lr
 1963              		.cfi_endproc
 1964              	.LFE32:
 1965              		.fnend
 1967              		.align	2
 1968              		.global	mpu_set_interrupt_latch
 1970              	mpu_set_interrupt_latch:
 1971              		.fnstart
 1972              	.LFB33:
 228:mpu6050.c     **** 
 229:mpu6050.c     **** /**
 230:mpu6050.c     ****  * Set interrupt latch mode
 231:mpu6050.c     ****  * @param latch 0 50us pulse; 1 high until interrupt is cleared
 232:mpu6050.c     ****  */
 233:mpu6050.c     **** void mpu_set_interrupt_latch(char latch) {
 1973              		.loc 4 233 0
 1974              		.cfi_startproc
 1975              		@ Function supports interworking.
 1976              		@ args = 0, pretend = 0, frame = 0
 1977              		@ frame_needed = 0, uses_anonymous_args = 0
 1978              	.LVL112:
 1979 0de8 08402DE9 		stmfd	sp!, {r3, lr}
 1980              		.save {r3, lr}
 1981              	.LCFI28:
 1982              		.cfi_def_cfa_offset 8
 1983 0dec 0030A0E1 		mov	r3, r0
 1984              		.cfi_offset 14, -4
 1985              		.cfi_offset 3, -8
 234:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, 1, latch);
 1986              		.loc 4 234 0
 1987 0df0 3700A0E3 		mov	r0, #55
 1988              	.LVL113:
 1989 0df4 0510A0E3 		mov	r1, #5
 1990 0df8 0120A0E3 		mov	r2, #1
 1991 0dfc FEFFFFEB 		bl	i2c_write_bits
 235:mpu6050.c     **** }
 1992              		.loc 4 235 0
 1993 0e00 0840BDE8 		ldmfd	sp!, {r3, lr}
 1994 0e04 1EFF2FE1 		bx	lr
 1995              		.cfi_endproc
 1996              	.LFE33:
 1997              		.fnend
 1999              		.align	2
 2000              		.global	mpu_set_FIFO_overflow_interrupt
 2002              	mpu_set_FIFO_overflow_interrupt:
 2003              		.fnstart
 2004              	.LFB34:
 236:mpu6050.c     **** 
 237:mpu6050.c     **** /**
 238:mpu6050.c     ****  * Set FIFO Buffer Overflow interrupt enabled status.
 239:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 240:mpu6050.c     ****  */
 241:mpu6050.c     **** void mpu_set_FIFO_overflow_interrupt(char enabled) {
 2005              		.loc 4 241 0
 2006              		.cfi_startproc
 2007              		@ Function supports interworking.
 2008              		@ args = 0, pretend = 0, frame = 0
 2009              		@ frame_needed = 0, uses_anonymous_args = 0
 2010              	.LVL114:
 2011 0e08 08402DE9 		stmfd	sp!, {r3, lr}
 2012              		.save {r3, lr}
 2013              	.LCFI29:
 2014              		.cfi_def_cfa_offset 8
 2015 0e0c 0030A0E1 		mov	r3, r0
 2016              		.cfi_offset 14, -4
 2017              		.cfi_offset 3, -8
 242:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, 1, enabled);
 2018              		.loc 4 242 0
 2019 0e10 3800A0E3 		mov	r0, #56
 2020              	.LVL115:
 2021 0e14 0410A0E3 		mov	r1, #4
 2022 0e18 0120A0E3 		mov	r2, #1
 2023 0e1c FEFFFFEB 		bl	i2c_write_bits
 243:mpu6050.c     **** }
 2024              		.loc 4 243 0
 2025 0e20 0840BDE8 		ldmfd	sp!, {r3, lr}
 2026 0e24 1EFF2FE1 		bx	lr
 2027              		.cfi_endproc
 2028              	.LFE34:
 2029              		.fnend
 2031              		.align	2
 2032              		.global	mpu_set_data_ready_interrupt
 2034              	mpu_set_data_ready_interrupt:
 2035              		.fnstart
 2036              	.LFB35:
 244:mpu6050.c     **** 
 245:mpu6050.c     **** /**
 246:mpu6050.c     ****  * Set Data Ready interrupt enabled status.
 247:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 248:mpu6050.c     ****  */
 249:mpu6050.c     **** void mpu_set_data_ready_interrupt(char enabled) {
 2037              		.loc 4 249 0
 2038              		.cfi_startproc
 2039              		@ Function supports interworking.
 2040              		@ args = 0, pretend = 0, frame = 0
 2041              		@ frame_needed = 0, uses_anonymous_args = 0
 2042              	.LVL116:
 2043 0e28 08402DE9 		stmfd	sp!, {r3, lr}
 2044              		.save {r3, lr}
 2045              	.LCFI30:
 2046              		.cfi_def_cfa_offset 8
 2047 0e2c 0030A0E1 		mov	r3, r0
 2048              		.cfi_offset 14, -4
 2049              		.cfi_offset 3, -8
 250:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, 1, enabled);
 2050              		.loc 4 250 0
 2051 0e30 3800A0E3 		mov	r0, #56
 2052              	.LVL117:
 2053 0e34 0010A0E3 		mov	r1, #0
 2054 0e38 0120A0E3 		mov	r2, #1
 2055 0e3c FEFFFFEB 		bl	i2c_write_bits
 251:mpu6050.c     **** }
 2056              		.loc 4 251 0
 2057 0e40 0840BDE8 		ldmfd	sp!, {r3, lr}
 2058 0e44 1EFF2FE1 		bx	lr
 2059              		.cfi_endproc
 2060              	.LFE35:
 2061              		.fnend
 2063              		.align	2
 2064              		.global	mpu_clear_interrupt
 2066              	mpu_clear_interrupt:
 2067              		.fnstart
 2068              	.LFB36:
 252:mpu6050.c     **** 
 253:mpu6050.c     **** /** Get full set of interrupt status bits.
 254:mpu6050.c     **** * These bits clear to 0 after the register has been read. Very useful
 255:mpu6050.c     **** * for getting multiple INT statuses, since each single bit read clears
 256:mpu6050.c     **** * all of them because it has to read the whole byte.
 257:mpu6050.c     **** * @see MPU6050_RA_INT_STATUS
 258:mpu6050.c     **** */
 259:mpu6050.c     **** int mpu_clear_interrupt(char* data) {
 2069              		.loc 4 259 0
 2070              		.cfi_startproc
 2071              		@ Function supports interworking.
 2072              		@ args = 0, pretend = 0, frame = 0
 2073              		@ frame_needed = 0, uses_anonymous_args = 0
 2074              	.LVL118:
 2075 0e48 08402DE9 		stmfd	sp!, {r3, lr}
 2076              		.save {r3, lr}
 2077              	.LCFI31:
 2078              		.cfi_def_cfa_offset 8
 2079 0e4c 0010A0E1 		mov	r1, r0
 260:mpu6050.c     **** 	return i2c_read_byte(MPU6050_RA_INT_STATUS, data);
 2080              		.loc 4 260 0
 2081 0e50 3A00A0E3 		mov	r0, #58
 2082              	.LVL119:
 2083              		.cfi_offset 14, -4
 2084              		.cfi_offset 3, -8
 2085 0e54 FEFFFFEB 		bl	i2c_read_byte
 2086              	.LVL120:
 261:mpu6050.c     **** }
 2087              		.loc 4 261 0
 2088 0e58 0840BDE8 		ldmfd	sp!, {r3, lr}
 2089 0e5c 1EFF2FE1 		bx	lr
 2090              		.cfi_endproc
 2091              	.LFE36:
 2092              		.fnend
 2094              		.align	2
 2095              		.global	mpu_set_FIFO_enabled
 2097              	mpu_set_FIFO_enabled:
 2098              		.fnstart
 2099              	.LFB37:
 262:mpu6050.c     **** 
 263:mpu6050.c     **** /** Enable FIFO usage.
 264:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 265:mpu6050.c     ****  */
 266:mpu6050.c     **** void mpu_set_FIFO_enabled(char enabled) {
 2100              		.loc 4 266 0
 2101              		.cfi_startproc
 2102              		@ Function supports interworking.
 2103              		@ args = 0, pretend = 0, frame = 0
 2104              		@ frame_needed = 0, uses_anonymous_args = 0
 2105              	.LVL121:
 2106 0e60 08402DE9 		stmfd	sp!, {r3, lr}
 2107              		.save {r3, lr}
 2108              	.LCFI32:
 2109              		.cfi_def_cfa_offset 8
 2110 0e64 0030A0E1 		mov	r3, r0
 2111              		.cfi_offset 14, -4
 2112              		.cfi_offset 3, -8
 267:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, 1, enabled);
 2113              		.loc 4 267 0
 2114 0e68 6A00A0E3 		mov	r0, #106
 2115              	.LVL122:
 2116 0e6c 0610A0E3 		mov	r1, #6
 2117 0e70 0120A0E3 		mov	r2, #1
 2118 0e74 FEFFFFEB 		bl	i2c_write_bits
 268:mpu6050.c     **** }
 2119              		.loc 4 268 0
 2120 0e78 0840BDE8 		ldmfd	sp!, {r3, lr}
 2121 0e7c 1EFF2FE1 		bx	lr
 2122              		.cfi_endproc
 2123              	.LFE37:
 2124              		.fnend
 2126              		.align	2
 2127              		.global	mpu_reset_FIFO
 2129              	mpu_reset_FIFO:
 2130              		.fnstart
 2131              	.LFB38:
 269:mpu6050.c     **** 
 270:mpu6050.c     **** /**
 271:mpu6050.c     ****  * Reset the FIFO.
 272:mpu6050.c     ****  * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 273:mpu6050.c     ****  * bit automatically clears to 0 after the reset has been triggered.
 274:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 275:mpu6050.c     ****  */
 276:mpu6050.c     **** void mpu_reset_FIFO(void) {
 2132              		.loc 4 276 0
 2133              		.cfi_startproc
 2134              		@ Function supports interworking.
 2135              		@ args = 0, pretend = 0, frame = 0
 2136              		@ frame_needed = 0, uses_anonymous_args = 0
 2137 0e80 08402DE9 		stmfd	sp!, {r3, lr}
 2138              		.save {r3, lr}
 2139              	.LCFI33:
 2140              		.cfi_def_cfa_offset 8
 277:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);
 2141              		.loc 4 277 0
 2142 0e84 6A00A0E3 		mov	r0, #106
 2143 0e88 0210A0E3 		mov	r1, #2
 2144 0e8c 0120A0E3 		mov	r2, #1
 2145 0e90 0230A0E1 		mov	r3, r2
 2146              		.cfi_offset 14, -4
 2147              		.cfi_offset 3, -8
 2148 0e94 FEFFFFEB 		bl	i2c_write_bits
 278:mpu6050.c     **** }
 2149              		.loc 4 278 0
 2150 0e98 0840BDE8 		ldmfd	sp!, {r3, lr}
 2151 0e9c 1EFF2FE1 		bx	lr
 2152              		.cfi_endproc
 2153              	.LFE38:
 2154              		.fnend
 2156              		.align	2
 2157              		.global	mpu_init
 2159              	mpu_init:
 2160              		.fnstart
 2161              	.LFB22:
  21:mpu6050.c     **** void mpu_init(void) {
 2162              		.loc 4 21 0
 2163              		.cfi_startproc
 2164              		@ Function supports interworking.
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167 0ea0 08402DE9 		stmfd	sp!, {r3, lr}
 2168              		.save {r3, lr}
 2169              	.LCFI34:
 2170              		.cfi_def_cfa_offset 8
  25:mpu6050.c     **** 	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
 2171              		.loc 4 25 0
 2172 0ea4 0100A0E3 		mov	r0, #1
 2173              		.cfi_offset 14, -4
 2174              		.cfi_offset 3, -8
 2175 0ea8 FEFFFFEB 		bl	mpu_set_clock_source
  27:mpu6050.c     **** 	mpu_set_temperature_sensor_enabled(0);
 2176              		.loc 4 27 0
 2177 0eac 0000A0E3 		mov	r0, #0
 2178 0eb0 FEFFFFEB 		bl	mpu_set_temperature_sensor_enabled
  31:mpu6050.c     ****     mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
 2179              		.loc 4 31 0
 2180 0eb4 0000A0E3 		mov	r0, #0
 2181 0eb8 FEFFFFEB 		bl	mpu_set_full_scale_gyro_range
  32:mpu6050.c     ****     mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
 2182              		.loc 4 32 0
 2183 0ebc 0000A0E3 		mov	r0, #0
 2184 0ec0 FEFFFFEB 		bl	mpu_set_full_scale_accel_range
  35:mpu6050.c     ****     mpu_set_gyro_rate(7);
 2185              		.loc 4 35 0
 2186 0ec4 0700A0E3 		mov	r0, #7
 2187 0ec8 FEFFFFEB 		bl	mpu_set_gyro_rate
  37:mpu6050.c     ****     mpu_set_DLPF_mode(0);
 2188              		.loc 4 37 0
 2189 0ecc 0000A0E3 		mov	r0, #0
 2190 0ed0 FEFFFFEB 		bl	mpu_set_DLPF_mode
  41:mpu6050.c     ****     mpu_set_6axis_FIFO_enabled(1);
 2191              		.loc 4 41 0
 2192 0ed4 0100A0E3 		mov	r0, #1
 2193 0ed8 FEFFFFEB 		bl	mpu_set_6axis_FIFO_enabled
  55:mpu6050.c     ****     mpu_reset_FIFO();
 2194              		.loc 4 55 0
 2195 0edc FEFFFFEB 		bl	mpu_reset_FIFO
  57:mpu6050.c     ****     mpu_set_FIFO_enabled(1);
 2196              		.loc 4 57 0
 2197 0ee0 0100A0E3 		mov	r0, #1
 2198 0ee4 FEFFFFEB 		bl	mpu_set_FIFO_enabled
  60:mpu6050.c     ****     mpu_set_sleep_enable(0);
 2199              		.loc 4 60 0
 2200 0ee8 0000A0E3 		mov	r0, #0
 2201 0eec FEFFFFEB 		bl	mpu_set_sleep_enable
  63:mpu6050.c     **** }
 2202              		.loc 4 63 0
 2203 0ef0 0840BDE8 		ldmfd	sp!, {r3, lr}
 2204 0ef4 1EFF2FE1 		bx	lr
 2205              		.cfi_endproc
 2206              	.LFE22:
 2207              		.fnend
 2209              		.align	2
 2210              		.global	mpu_get_FIFO_size
 2212              	mpu_get_FIFO_size:
 2213              		.fnstart
 2214              	.LFB39:
 279:mpu6050.c     **** 
 280:mpu6050.c     **** 
 281:mpu6050.c     **** /** Get current FIFO buffer size.
 282:mpu6050.c     **** * This value indicates the number of bytes stored in the FIFO buffer. This
 283:mpu6050.c     **** * number is in turn the number of bytes that can be read from the FIFO buffer
 284:mpu6050.c     **** * and it is directly proportional to the number of samples available given the
 285:mpu6050.c     **** * set of sensor data bound to be stored in the FIFO (register 35 and 36).
 286:mpu6050.c     **** */
 287:mpu6050.c     **** void mpu_get_FIFO_size(int* size) {
 2215              		.loc 4 287 0
 2216              		.cfi_startproc
 2217              		@ Function supports interworking.
 2218              		@ args = 0, pretend = 0, frame = 8
 2219              		@ frame_needed = 0, uses_anonymous_args = 0
 2220              	.LVL123:
 2221 0ef8 10402DE9 		stmfd	sp!, {r4, lr}
 2222              		.save {r4, lr}
 2223              	.LCFI35:
 2224              		.cfi_def_cfa_offset 8
 2225              		.pad #8
 2226 0efc 08D04DE2 		sub	sp, sp, #8
 2227              	.LCFI36:
 2228              		.cfi_def_cfa_offset 16
 2229 0f00 0040A0E1 		mov	r4, r0
 2230              		.cfi_offset 14, -4
 2231              		.cfi_offset 4, -8
 288:mpu6050.c     **** 	char count[2];
 289:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_FIFO_COUNTH, 2, count);
 2232              		.loc 4 289 0
 2233 0f04 7200A0E3 		mov	r0, #114
 2234              	.LVL124:
 2235 0f08 0210A0E3 		mov	r1, #2
 2236 0f0c 04208DE2 		add	r2, sp, #4
 2237 0f10 FEFFFFEB 		bl	i2c_read_bytes
 290:mpu6050.c     **** 	*size = (((int)count[0]) << 8) | count[1];
 2238              		.loc 4 290 0
 2239 0f14 0420DDE5 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 2240 0f18 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2241 0f1c 023483E1 		orr	r3, r3, r2, asl #8
 2242 0f20 003084E5 		str	r3, [r4, #0]
 291:mpu6050.c     **** }
 2243              		.loc 4 291 0
 2244 0f24 08D08DE2 		add	sp, sp, #8
 2245 0f28 1040BDE8 		ldmfd	sp!, {r4, lr}
 2246 0f2c 1EFF2FE1 		bx	lr
 2247              		.cfi_endproc
 2248              	.LFE39:
 2249              		.fnend
 2251              		.align	2
 2252              		.global	mpu_get_motion6
 2254              	mpu_get_motion6:
 2255              		.fnstart
 2256              	.LFB40:
 292:mpu6050.c     **** 
 293:mpu6050.c     **** /** Get raw 6-axis motion sensor readings (accel/gyro).
 294:mpu6050.c     **** * Retrieves all currently available motion sensor values.
 295:mpu6050.c     **** * @param ax 16-bit signed integer container for accelerometer X-axis value
 296:mpu6050.c     **** * @param ay 16-bit signed integer container for accelerometer Y-axis value
 297:mpu6050.c     **** * @param az 16-bit signed integer container for accelerometer Z-axis value
 298:mpu6050.c     **** * @param gx 16-bit signed integer container for gyroscope X-axis value
 299:mpu6050.c     **** * @param gy 16-bit signed integer container for gyroscope Y-axis value
 300:mpu6050.c     **** * @param gz 16-bit signed integer container for gyroscope Z-axis value
 301:mpu6050.c     **** *
 302:mpu6050.c     **** * buff:
 303:mpu6050.c     **** * ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l,
 304:mpu6050.c     **** *
 305:mpu6050.c     **** * @see getAcceleration()
 306:mpu6050.c     **** * @see getRotation()
 307:mpu6050.c     **** * @see MPU6050_RA_ACCEL_XOUT_H
 308:mpu6050.c     **** */
 309:mpu6050.c     **** void mpu_get_motion6(char* buff) {
 2257              		.loc 4 309 0
 2258              		.cfi_startproc
 2259              		@ Function supports interworking.
 2260              		@ args = 0, pretend = 0, frame = 16
 2261              		@ frame_needed = 0, uses_anonymous_args = 0
 2262              	.LVL125:
 2263 0f30 10402DE9 		stmfd	sp!, {r4, lr}
 2264              		.save {r4, lr}
 2265              	.LCFI37:
 2266              		.cfi_def_cfa_offset 8
 2267              		.pad #16
 2268 0f34 10D04DE2 		sub	sp, sp, #16
 2269              	.LCFI38:
 2270              		.cfi_def_cfa_offset 24
 2271 0f38 0040A0E1 		mov	r4, r0
 2272              		.cfi_offset 14, -4
 2273              		.cfi_offset 4, -8
 310:mpu6050.c     **** 
 311:mpu6050.c     **** 	log_string_mpu(">> mpu_get_motion6\n");
 312:mpu6050.c     **** 
 313:mpu6050.c     **** 	char c[14];
 314:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_ACCEL_XOUT_H, 14, c);
 2274              		.loc 4 314 0
 2275 0f3c 3B00A0E3 		mov	r0, #59
 2276              	.LVL126:
 2277 0f40 0E10A0E3 		mov	r1, #14
 2278 0f44 0D20A0E1 		mov	r2, sp
 2279 0f48 FEFFFFEB 		bl	i2c_read_bytes
 315:mpu6050.c     **** 	*buff = c[0];
 2280              		.loc 4 315 0
 2281 0f4c 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 2282 0f50 0030C4E5 		strb	r3, [r4, #0]
 316:mpu6050.c     **** 	*(buff+1) = c[1];
 2283              		.loc 4 316 0
 2284 0f54 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 2285 0f58 0130C4E5 		strb	r3, [r4, #1]
 317:mpu6050.c     **** 	*(buff+2) = c[2];
 2286              		.loc 4 317 0
 2287 0f5c 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 2288 0f60 0230C4E5 		strb	r3, [r4, #2]
 318:mpu6050.c     **** 	*(buff+3) = c[3];
 2289              		.loc 4 318 0
 2290 0f64 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 2291 0f68 0330C4E5 		strb	r3, [r4, #3]
 319:mpu6050.c     **** 	*(buff+4) = c[4];
 2292              		.loc 4 319 0
 2293 0f6c 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2294 0f70 0430C4E5 		strb	r3, [r4, #4]
 320:mpu6050.c     **** 	*(buff+5) = c[5];
 2295              		.loc 4 320 0
 2296 0f74 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2297 0f78 0530C4E5 		strb	r3, [r4, #5]
 321:mpu6050.c     **** 	*(buff+6) = c[8];
 2298              		.loc 4 321 0
 2299 0f7c 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 2300 0f80 0630C4E5 		strb	r3, [r4, #6]
 322:mpu6050.c     **** 	*(buff+7) = c[9];
 2301              		.loc 4 322 0
 2302 0f84 0930DDE5 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 2303 0f88 0730C4E5 		strb	r3, [r4, #7]
 323:mpu6050.c     **** 	*(buff+8) = c[10];
 2304              		.loc 4 323 0
 2305 0f8c 0A30DDE5 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 2306 0f90 0830C4E5 		strb	r3, [r4, #8]
 324:mpu6050.c     **** 	*(buff+9) = c[11];
 2307              		.loc 4 324 0
 2308 0f94 0B30DDE5 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 2309 0f98 0930C4E5 		strb	r3, [r4, #9]
 325:mpu6050.c     **** 	*(buff+10) = c[12];
 2310              		.loc 4 325 0
 2311 0f9c 0C30DDE5 		ldrb	r3, [sp, #12]	@ zero_extendqisi2
 2312 0fa0 0A30C4E5 		strb	r3, [r4, #10]
 326:mpu6050.c     **** 	*(buff+11) = c[13];
 2313              		.loc 4 326 0
 2314 0fa4 0D30DDE5 		ldrb	r3, [sp, #13]	@ zero_extendqisi2
 2315 0fa8 0B30C4E5 		strb	r3, [r4, #11]
 327:mpu6050.c     **** 
 328:mpu6050.c     **** 	log_string_mpu("<< mpu_get_motion6\n");
 329:mpu6050.c     **** }
 2316              		.loc 4 329 0
 2317 0fac 10D08DE2 		add	sp, sp, #16
 2318 0fb0 1040BDE8 		ldmfd	sp!, {r4, lr}
 2319 0fb4 1EFF2FE1 		bx	lr
 2320              		.cfi_endproc
 2321              	.LFE40:
 2322              		.fnend
 2324              		.align	2
 2325              		.global	mpu_get_FIFO_motion6
 2327              	mpu_get_FIFO_motion6:
 2328              		.fnstart
 2329              	.LFB41:
 330:mpu6050.c     **** 
 331:mpu6050.c     **** /** Get byte from FIFO buffer.
 332:mpu6050.c     **** * This register is used to read and write data from the FIFO buffer. Data is
 333:mpu6050.c     **** * written to the FIFO in order of register number (from lowest to highest). If
 334:mpu6050.c     **** * all the FIFO enable flags (see below) are enabled and all External Sensor
 335:mpu6050.c     **** * Data registers (Registers 73 to 96) are associated with a Slave device, the
 336:mpu6050.c     **** * contents of registers 59 through 96 will be written in order at the Sample
 337:mpu6050.c     **** * Rate.
 338:mpu6050.c     **** *
 339:mpu6050.c     **** * The contents of the sensor data registers (Registers 59 to 96) are written
 340:mpu6050.c     **** * into the FIFO buffer when their corresponding FIFO enable flags are set to 1
 341:mpu6050.c     **** * in FIFO_EN (Register 35). An additional flag for the sensor data registers
 342:mpu6050.c     **** * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).
 343:mpu6050.c     **** *
 344:mpu6050.c     **** * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is
 345:mpu6050.c     **** * automatically set to 1. This bit is located in INT_STATUS (Register 58).
 346:mpu6050.c     **** * When the FIFO buffer has overflowed, the oldest data will be lost and new
 347:mpu6050.c     **** * data will be written to the FIFO.
 348:mpu6050.c     **** *
 349:mpu6050.c     **** * If the FIFO buffer is empty, reading this register will return the last byte
 350:mpu6050.c     **** * that was previously read from the FIFO until new data is available. The user
 351:mpu6050.c     **** * should check FIFO_COUNT to ensure that the FIFO buffer is not read when
 352:mpu6050.c     **** * empty.
 353:mpu6050.c     **** *
 354:mpu6050.c     **** * buff:
 355:mpu6050.c     **** * ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l,
 356:mpu6050.c     **** *
 357:mpu6050.c     **** */
 358:mpu6050.c     **** void mpu_get_FIFO_motion6(char* buff) {
 2330              		.loc 4 358 0
 2331              		.cfi_startproc
 2332              		@ Function supports interworking.
 2333              		@ args = 0, pretend = 0, frame = 16
 2334              		@ frame_needed = 0, uses_anonymous_args = 0
 2335              	.LVL127:
 2336 0fb8 10402DE9 		stmfd	sp!, {r4, lr}
 2337              		.save {r4, lr}
 2338              	.LCFI39:
 2339              		.cfi_def_cfa_offset 8
 2340              		.pad #16
 2341 0fbc 10D04DE2 		sub	sp, sp, #16
 2342              	.LCFI40:
 2343              		.cfi_def_cfa_offset 24
 2344 0fc0 0040A0E1 		mov	r4, r0
 2345              		.cfi_offset 14, -4
 2346              		.cfi_offset 4, -8
 359:mpu6050.c     **** 
 360:mpu6050.c     **** 	char c[12];
 361:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_FIFO_R_W, 12, c);
 2347              		.loc 4 361 0
 2348 0fc4 7400A0E3 		mov	r0, #116
 2349              	.LVL128:
 2350 0fc8 0C10A0E3 		mov	r1, #12
 2351 0fcc 04208DE2 		add	r2, sp, #4
 2352 0fd0 FEFFFFEB 		bl	i2c_read_bytes
 362:mpu6050.c     **** 
 363:mpu6050.c     **** 	*buff = c[0];
 2353              		.loc 4 363 0
 2354 0fd4 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2355 0fd8 0030C4E5 		strb	r3, [r4, #0]
 364:mpu6050.c     **** 	*(buff+1) = c[1];
 2356              		.loc 4 364 0
 2357 0fdc 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2358 0fe0 0130C4E5 		strb	r3, [r4, #1]
 365:mpu6050.c     **** 	*(buff+2) = c[2];
 2359              		.loc 4 365 0
 2360 0fe4 0630DDE5 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 2361 0fe8 0230C4E5 		strb	r3, [r4, #2]
 366:mpu6050.c     **** 	*(buff+3) = c[3];
 2362              		.loc 4 366 0
 2363 0fec 0730DDE5 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2364 0ff0 0330C4E5 		strb	r3, [r4, #3]
 367:mpu6050.c     **** 	*(buff+4) = c[4];
 2365              		.loc 4 367 0
 2366 0ff4 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 2367 0ff8 0430C4E5 		strb	r3, [r4, #4]
 368:mpu6050.c     **** 	*(buff+5) = c[5];
 2368              		.loc 4 368 0
 2369 0ffc 0930DDE5 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 2370 1000 0530C4E5 		strb	r3, [r4, #5]
 369:mpu6050.c     **** 	*(buff+6) = c[6];
 2371              		.loc 4 369 0
 2372 1004 0A30DDE5 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 2373 1008 0630C4E5 		strb	r3, [r4, #6]
 370:mpu6050.c     **** 	*(buff+7) = c[7];
 2374              		.loc 4 370 0
 2375 100c 0B30DDE5 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 2376 1010 0730C4E5 		strb	r3, [r4, #7]
 371:mpu6050.c     **** 	*(buff+8) = c[8];
 2377              		.loc 4 371 0
 2378 1014 0C30DDE5 		ldrb	r3, [sp, #12]	@ zero_extendqisi2
 2379 1018 0830C4E5 		strb	r3, [r4, #8]
 372:mpu6050.c     **** 	*(buff+9) = c[9];
 2380              		.loc 4 372 0
 2381 101c 0D30DDE5 		ldrb	r3, [sp, #13]	@ zero_extendqisi2
 2382 1020 0930C4E5 		strb	r3, [r4, #9]
 373:mpu6050.c     **** 	*(buff+10) = c[10];
 2383              		.loc 4 373 0
 2384 1024 0E30DDE5 		ldrb	r3, [sp, #14]	@ zero_extendqisi2
 2385 1028 0A30C4E5 		strb	r3, [r4, #10]
 374:mpu6050.c     **** 	*(buff+11) = c[11];
 2386              		.loc 4 374 0
 2387 102c 0F30DDE5 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 2388 1030 0B30C4E5 		strb	r3, [r4, #11]
 375:mpu6050.c     **** 
 376:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ax_h);
 377:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ax_l);
 378:mpu6050.c     **** //
 379:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ay_h);
 380:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ay_l);
 381:mpu6050.c     **** //
 382:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, az_h);
 383:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, az_l);
 384:mpu6050.c     **** //
 385:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gx_h);
 386:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gx_l);
 387:mpu6050.c     **** //
 388:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_h);
 389:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_l);
 390:mpu6050.c     **** //
 391:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_h);
 392:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_l);
 393:mpu6050.c     **** }
 2389              		.loc 4 393 0
 2390 1034 10D08DE2 		add	sp, sp, #16
 2391 1038 1040BDE8 		ldmfd	sp!, {r4, lr}
 2392 103c 1EFF2FE1 		bx	lr
 2393              		.cfi_endproc
 2394              	.LFE41:
 2395              		.fnend
 2397              		.align	2
 2398              		.global	main
 2400              	main:
 2401              		.fnstart
 2402              	.LFB42:
 107:bellator_low_level.c **** int main(void){
 2403              		.loc 3 107 0
 2404              		.cfi_startproc
 2405              		@ Function supports interworking.
 2406              		@ args = 0, pretend = 0, frame = 8
 2407              		@ frame_needed = 0, uses_anonymous_args = 0
 2408 1040 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 2409              		.save {r4, r5, r6, r7, lr}
 2410              	.LCFI41:
 2411              		.cfi_def_cfa_offset 20
 2412              		.pad #12
 2413 1044 0CD04DE2 		sub	sp, sp, #12
 2414              	.LCFI42:
 2415              		.cfi_def_cfa_offset 32
 2416              	.LBB47:
 2417              	.LBB48:
 201:bellator_low_level.c **** 	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 2418              		.loc 3 201 0
 2419 1048 C0349FE5 		ldr	r3, .L149
 2420 104c 2420A0E3 		mov	r2, #36
 2421 1050 8420C3E5 		strb	r2, [r3, #132]
 207:bellator_low_level.c **** 	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 2422              		.loc 3 207 0
 2423 1054 0120A0E3 		mov	r2, #1
 2424 1058 8020C3E5 		strb	r2, [r3, #128]
 208:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 2425              		.loc 3 208 0
 2426 105c 5520E0E3 		mvn	r2, #85
 2427 1060 8C20C3E5 		strb	r2, [r3, #140]
 209:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 2428              		.loc 3 209 0
 2429 1064 AB2082E2 		add	r2, r2, #171
 2430 1068 8C20C3E5 		strb	r2, [r3, #140]
 2431              	.L136:
 210:bellator_low_level.c **** 	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 2432              		.loc 3 210 0
 2433 106c B828D3E1 		ldrh	r2, [r3, #136]
 2434 1070 010B12E3 		tst	r2, #1024
 2435 1074 FCFFFF0A 		beq	.L136
 2436              		.cfi_offset 14, -4
 2437              		.cfi_offset 7, -8
 2438              		.cfi_offset 6, -12
 2439              		.cfi_offset 5, -16
 2440              		.cfi_offset 4, -20
 211:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 2441              		.loc 3 211 0
 2442 1078 90349FE5 		ldr	r3, .L149
 2443 107c 0320A0E3 		mov	r2, #3
 2444 1080 8020C3E5 		strb	r2, [r3, #128]
 212:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 2445              		.loc 3 212 0
 2446 1084 5520E0E3 		mvn	r2, #85
 2447 1088 8C20C3E5 		strb	r2, [r3, #140]
 213:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 2448              		.loc 3 213 0
 2449 108c AB2082E2 		add	r2, r2, #171
 2450 1090 8C20C3E5 		strb	r2, [r3, #140]
 2451              	.LBE48:
 2452              	.LBE47:
 2453              	.LBB49:
 2454              	.LBB50:
 227:bellator_low_level.c **** 	MAMTIM = 4; // 4 clock fetches
 2455              		.loc 3 227 0
 2456 1094 0420A0E3 		mov	r2, #4
 2457 1098 0420C3E5 		strb	r2, [r3, #4]
 232:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 2458              		.loc 3 232 0
 2459 109c 0220A0E3 		mov	r2, #2
 2460 10a0 0020C3E5 		strb	r2, [r3, #0]
 2461              	.LBE50:
 2462              	.LBE49:
 2463              	.LBB51:
 2464              	.LBB52:
 242:bellator_low_level.c **** 	APBDIV &= ~0x03;
 2465              		.loc 3 242 0
 2466 10a4 013C83E2 		add	r3, r3, #256
 2467 10a8 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2468 10ac FC2002E2 		and	r2, r2, #252
 2469 10b0 0020C3E5 		strb	r2, [r3, #0]
 2470              	.LBE52:
 2471              	.LBE51:
 113:bellator_low_level.c **** 	logger_init(); // uart0
 2472              		.loc 3 113 0
 2473 10b4 FEFFFFEB 		bl	logger_init
 2474              	.LBB53:
 2475              	.LBB54:
 2476              	.LBB55:
 2477              	.LBB56:
 2478              		.file 5 "irq.c"
   1:irq.c         **** /*
   2:irq.c         ****  * irq.c
   3:irq.c         ****  *
   4:irq.c         ****  *  Created on: Jul 15, 2009
   5:irq.c         ****  *      Author: telmo
   6:irq.c         ****  */
   7:irq.c         **** 
   8:irq.c         **** #include "irq.h"
   9:irq.c         **** 
  10:irq.c         **** static inline unsigned asm_get_cpsr(void)
  11:irq.c         **** {
  12:irq.c         ****   unsigned long retval;
  13:irq.c         ****   asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
 2479              		.loc 5 13 0
 2480              	#APP
 2481              	@ 13 "irq.c" 1
 2482 10b8 00300FE1 		 mrs  r3, cpsr
 2483              	@ 0 "" 2
 2484              	.LVL129:
 2485              	.LBE56:
 2486              	.LBE55:
  14:irq.c         ****   return retval;
  15:irq.c         **** }
  16:irq.c         **** 
  17:irq.c         **** static inline void asm_set_cpsr(unsigned val)
  18:irq.c         **** {
  19:irq.c         ****   asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
  20:irq.c         **** }
  21:irq.c         **** 
  22:irq.c         **** static inline unsigned enableIRQ(void)
  23:irq.c         **** {
  24:irq.c         ****   unsigned _cpsr;
  25:irq.c         **** 
  26:irq.c         ****   _cpsr = asm_get_cpsr();
  27:irq.c         ****   asm_set_cpsr(_cpsr & ~IRQ_MASK);
 2487              		.loc 5 27 0
 2488 10bc 8030C3E3 		bic	r3, r3, #128
 2489              	.LVL130:
 2490              	.LBB57:
 2491              	.LBB58:
  19:irq.c         ****   asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
 2492              		.loc 5 19 0
 2493              	#APP
 2494              	@ 19 "irq.c" 1
 2495 10c0 03F029E1 		 msr  cpsr, r3
 2496              	@ 0 "" 2
 2497              	.LBE58:
 2498              	.LBE57:
 2499              	.LBE54:
 2500              	.LBE53:
 2501              	.LBB59:
 2502              	.LBB60:
 259:bellator_low_level.c **** 	PINSEL1 |= 0x1 << 0;  // EINT0
 2503              		.loc 3 259 0
 2504 10c4 48449FE5 		ldr	r4, .L149+4
 2505 10c8 043094E5 		ldr	r3, [r4, #4]
 2506 10cc 013083E3 		orr	r3, r3, #1
 2507 10d0 043084E5 		str	r3, [r4, #4]
 260:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 2508              		.loc 3 260 0
 2509 10d4 043094E5 		ldr	r3, [r4, #4]
 2510 10d8 023583E3 		orr	r3, r3, #8388608
 2511 10dc 043084E5 		str	r3, [r4, #4]
 261:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 24; // CAP2.1
 2512              		.loc 3 261 0
 2513 10e0 043094E5 		ldr	r3, [r4, #4]
 2514 10e4 023483E3 		orr	r3, r3, #33554432
 2515 10e8 043084E5 		str	r3, [r4, #4]
 262:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 26; // CAP2.2
 2516              		.loc 3 262 0
 2517 10ec 043094E5 		ldr	r3, [r4, #4]
 2518 10f0 023383E3 		orr	r3, r3, #134217728
 2519 10f4 043084E5 		str	r3, [r4, #4]
 265:bellator_low_level.c **** 	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
 2520              		.loc 3 265 0
 2521 10f8 18349FE5 		ldr	r3, .L149+8
 2522 10fc 4820D3E5 		ldrb	r2, [r3, #72]	@ zero_extendqisi2
 2523 1100 FF2002E2 		and	r2, r2, #255
 2524 1104 012082E3 		orr	r2, r2, #1
 2525 1108 4820C3E5 		strb	r2, [r3, #72]
 266:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
 2526              		.loc 3 266 0
 2527 110c 4C20D3E5 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 2528 1110 FF2002E2 		and	r2, r2, #255
 2529 1114 012082E3 		orr	r2, r2, #1
 2530 1118 4C20C3E5 		strb	r2, [r3, #76]
 267:bellator_low_level.c **** 	EXTINT |= 0x1 << 0; // reset EINT0
 2531              		.loc 3 267 0
 2532 111c 4020D3E5 		ldrb	r2, [r3, #64]	@ zero_extendqisi2
 2533 1120 FF2002E2 		and	r2, r2, #255
 2534 1124 012082E3 		orr	r2, r2, #1
 2535 1128 4020C3E5 		strb	r2, [r3, #64]
 270:bellator_low_level.c **** 	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
 2536              		.loc 3 270 0
 2537 112c E8339FE5 		ldr	r3, .L149+12
 2538 1130 B822D3E1 		ldrh	r2, [r3, #40]
 2539 1134 052082E3 		orr	r2, r2, #5
 2540 1138 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 271:bellator_low_level.c **** 	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
 2541              		.loc 3 271 0
 2542 113c B822D3E1 		ldrh	r2, [r3, #40]
 2543 1140 282082E3 		orr	r2, r2, #40
 2544 1144 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 272:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 2545              		.loc 3 272 0
 2546 1148 B822D3E1 		ldrh	r2, [r3, #40]
 2547 114c 052D82E3 		orr	r2, r2, #320
 2548 1150 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 273:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 2549              		.loc 3 273 0
 2550 1154 0160A0E3 		mov	r6, #1
 2551 1158 0460C3E5 		strb	r6, [r3, #4]
 277:bellator_low_level.c **** 	VICVectAddr6 = (unsigned int) &pulse_in;
 2552              		.loc 3 277 0
 2553 115c BC339FE5 		ldr	r3, .L149+16
 2554 1160 0050E0E3 		mvn	r5, #0
 2555 1164 E73E05E5 		str	r3, [r5, #-3815]
 278:bellator_low_level.c **** 	VICVectCntl6 = 0x2E; // source 14 and enabled
 2556              		.loc 3 278 0
 2557 1168 2E20A0E3 		mov	r2, #46
 2558 116c E72D05E5 		str	r2, [r5, #-3559]
 279:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
 2559              		.loc 3 279 0
 2560 1170 EF2F15E5 		ldr	r2, [r5, #-4079]
 2561 1174 012982E3 		orr	r2, r2, #16384
 2562 1178 EF2F05E5 		str	r2, [r5, #-4079]
 282:bellator_low_level.c **** 	VICVectAddr7 = (unsigned int) &pulse_in;
 2563              		.loc 3 282 0
 2564 117c E33E05E5 		str	r3, [r5, #-3811]
 283:bellator_low_level.c **** 	VICVectCntl7 = 0x3A; // source 26 and enabled
 2565              		.loc 3 283 0
 2566 1180 3A30A0E3 		mov	r3, #58
 2567 1184 E33D05E5 		str	r3, [r5, #-3555]
 284:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
 2568              		.loc 3 284 0
 2569 1188 EF3F15E5 		ldr	r3, [r5, #-4079]
 2570 118c 013383E3 		orr	r3, r3, #67108864
 2571 1190 EF3F05E5 		str	r3, [r5, #-4079]
 2572              	.LBE60:
 2573              	.LBE59:
 2574              	.LBB61:
 2575              	.LBB62:
 299:bellator_low_level.c **** 	i2c_init();
 2576              		.loc 3 299 0
 2577 1194 FEFFFFEB 		bl	i2c_init
 302:bellator_low_level.c **** 	mpu_init();
 2578              		.loc 3 302 0
 2579 1198 FEFFFFEB 		bl	mpu_init
 2580              	.LBE62:
 2581              	.LBE61:
 2582              	.LBB63:
 2583              	.LBB64:
 329:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 12; // AD0.0
 2584              		.loc 3 329 0
 2585 119c 043094E5 		ldr	r3, [r4, #4]
 2586 11a0 033A83E3 		orr	r3, r3, #12288
 2587 11a4 043084E5 		str	r3, [r4, #4]
 330:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 14; // AD0.1
 2588              		.loc 3 330 0
 2589 11a8 043094E5 		ldr	r3, [r4, #4]
 2590 11ac 033983E3 		orr	r3, r3, #49152
 2591 11b0 043084E5 		str	r3, [r4, #4]
 331:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 16; // AD0.2
 2592              		.loc 3 331 0
 2593 11b4 043094E5 		ldr	r3, [r4, #4]
 2594 11b8 033883E3 		orr	r3, r3, #196608
 2595 11bc 043084E5 		str	r3, [r4, #4]
 332:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 20; // AD0.3
 2596              		.loc 3 332 0
 2597 11c0 003094E5 		ldr	r3, [r4, #0]
 2598 11c4 033683E3 		orr	r3, r3, #3145728
 2599 11c8 003084E5 		str	r3, [r4, #0]
 333:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 22; // AD0.4
 2600              		.loc 3 333 0
 2601 11cc 003094E5 		ldr	r3, [r4, #0]
 2602 11d0 033583E3 		orr	r3, r3, #12582912
 2603 11d4 003084E5 		str	r3, [r4, #0]
 336:bellator_low_level.c **** 	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
 2604              		.loc 3 336 0
 2605 11d8 44339FE5 		ldr	r3, .L149+20
 2606 11dc 002093E5 		ldr	r2, [r3, #0]
 2607 11e0 012882E3 		orr	r2, r2, #65536
 2608 11e4 002083E5 		str	r2, [r3, #0]
 337:bellator_low_level.c **** 	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
 2609              		.loc 3 337 0
 2610 11e8 002093E5 		ldr	r2, [r3, #0]
 2611 11ec 032C82E3 		orr	r2, r2, #768
 2612 11f0 002083E5 		str	r2, [r3, #0]
 338:bellator_low_level.c **** 	ADCR |= 0x1F; // Read AD0.0 - AD0.4
 2613              		.loc 3 338 0
 2614 11f4 002093E5 		ldr	r2, [r3, #0]
 2615 11f8 1F2082E3 		orr	r2, r2, #31
 2616 11fc 002083E5 		str	r2, [r3, #0]
 339:bellator_low_level.c **** 	ADCR |= 0x01 << 21; // The ADC is operational
 2617              		.loc 3 339 0
 2618 1200 002093E5 		ldr	r2, [r3, #0]
 2619 1204 022682E3 		orr	r2, r2, #2097152
 2620 1208 002083E5 		str	r2, [r3, #0]
 2621              	.LBE64:
 2622              	.LBE63:
 2623              	.LBB65:
 2624              	.LBB66:
 355:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 6;  // MAT0.0
 2625              		.loc 3 355 0
 2626 120c 003094E5 		ldr	r3, [r4, #0]
 2627 1210 803083E3 		orr	r3, r3, #128
 2628 1214 003084E5 		str	r3, [r4, #0]
 356:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 10; // MAT0.1
 2629              		.loc 3 356 0
 2630 1218 003094E5 		ldr	r3, [r4, #0]
 2631 121c 023B83E3 		orr	r3, r3, #2048
 2632 1220 003084E5 		str	r3, [r4, #0]
 357:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 24; // MAT1.0
 2633              		.loc 3 357 0
 2634 1224 003094E5 		ldr	r3, [r4, #0]
 2635 1228 023483E3 		orr	r3, r3, #33554432
 2636 122c 003084E5 		str	r3, [r4, #0]
 358:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 26; // MAT1.1
 2637              		.loc 3 358 0
 2638 1230 003094E5 		ldr	r3, [r4, #0]
 2639 1234 023383E3 		orr	r3, r3, #134217728
 2640 1238 003084E5 		str	r3, [r4, #0]
 361:bellator_low_level.c **** 	T0PR = 293; // 255 levels for T2TC in 5ms
 2641              		.loc 3 361 0
 2642 123c E4229FE5 		ldr	r2, .L149+24
 2643 1240 E4129FE5 		ldr	r1, .L149+28
 2644 1244 0C1082E5 		str	r1, [r2, #12]
 362:bellator_low_level.c **** 	T1PR = 293; // TC increments every PR + 1 PCLKs
 2645              		.loc 3 362 0
 2646 1248 E0329FE5 		ldr	r3, .L149+32
 2647 124c 0C1083E5 		str	r1, [r3, #12]
 369:bellator_low_level.c **** 	T0PC = 0; // Prescale = 0
 2648              		.loc 3 369 0
 2649 1250 0010A0E3 		mov	r1, #0
 2650 1254 101082E5 		str	r1, [r2, #16]
 370:bellator_low_level.c **** 	T1PC = 0;
 2651              		.loc 3 370 0
 2652 1258 101083E5 		str	r1, [r3, #16]
 371:bellator_low_level.c **** 	T0TC = 0; // Counter = 0
 2653              		.loc 3 371 0
 2654 125c 081082E5 		str	r1, [r2, #8]
 372:bellator_low_level.c **** 	T1TC = 0;
 2655              		.loc 3 372 0
 2656 1260 081083E5 		str	r1, [r3, #8]
 374:bellator_low_level.c **** 	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
 2657              		.loc 3 374 0
 2658 1264 B401D2E1 		ldrh	r0, [r2, #20]
 2659 1268 010B80E3 		orr	r0, r0, #1024
 2660 126c B401C2E1 		strh	r0, [r2, #20]	@ movhi
 375:bellator_low_level.c **** 	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
 2661              		.loc 3 375 0
 2662 1270 B401D3E1 		ldrh	r0, [r3, #20]
 2663 1274 010B80E3 		orr	r0, r0, #1024
 2664 1278 B401C3E1 		strh	r0, [r3, #20]	@ movhi
 376:bellator_low_level.c **** 	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
 2665              		.loc 3 376 0
 2666 127c FF00A0E3 		mov	r0, #255
 2667 1280 240082E5 		str	r0, [r2, #36]
 377:bellator_low_level.c **** 	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
 2668              		.loc 3 377 0
 2669 1284 240083E5 		str	r0, [r3, #36]
 379:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
 2670              		.loc 3 379 0
 2671 1288 740092E5 		ldr	r0, [r2, #116]
 2672 128c 060080E1 		orr	r0, r0, r6
 2673 1290 740082E5 		str	r0, [r2, #116]
 380:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
 2674              		.loc 3 380 0
 2675 1294 740092E5 		ldr	r0, [r2, #116]
 2676 1298 020080E3 		orr	r0, r0, #2
 2677 129c 740082E5 		str	r0, [r2, #116]
 381:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
 2678              		.loc 3 381 0
 2679 12a0 740093E5 		ldr	r0, [r3, #116]
 2680 12a4 060080E1 		orr	r0, r0, r6
 2681 12a8 740083E5 		str	r0, [r3, #116]
 382:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
 2682              		.loc 3 382 0
 2683 12ac 740093E5 		ldr	r0, [r3, #116]
 2684 12b0 020080E3 		orr	r0, r0, #2
 2685 12b4 740083E5 		str	r0, [r3, #116]
 384:bellator_low_level.c **** 	T0MR0 = 256; // initially LOW
 2686              		.loc 3 384 0
 2687 12b8 010CA0E3 		mov	r0, #256
 2688 12bc 180082E5 		str	r0, [r2, #24]
 385:bellator_low_level.c **** 	T0MR1 = 256; // initially LOW
 2689              		.loc 3 385 0
 2690 12c0 1C0082E5 		str	r0, [r2, #28]
 386:bellator_low_level.c **** 	T1MR0 = 256; // initially LOW
 2691              		.loc 3 386 0
 2692 12c4 180083E5 		str	r0, [r3, #24]
 387:bellator_low_level.c **** 	T1MR1 = 256; // initially LOW
 2693              		.loc 3 387 0
 2694 12c8 1C0083E5 		str	r0, [r3, #28]
 389:bellator_low_level.c **** 	T0TCR = 1; // enable T0
 2695              		.loc 3 389 0
 2696 12cc 0460C2E5 		strb	r6, [r2, #4]
 390:bellator_low_level.c **** 	T1TCR = 1; // enable T1
 2697              		.loc 3 390 0
 2698 12d0 0460C3E5 		strb	r6, [r3, #4]
 2699              	.LBE66:
 2700              	.LBE65:
 2701              	.LBB67:
 2702              	.LBB68:
 414:bellator_low_level.c **** 	PINSEL0 |= 0x05 << 16; // Set the pins function
 2703              		.loc 3 414 0
 2704 12d4 003094E5 		ldr	r3, [r4, #0]
 2705 12d8 053883E3 		orr	r3, r3, #327680
 2706 12dc 003084E5 		str	r3, [r4, #0]
 415:bellator_low_level.c **** 	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 2707              		.loc 3 415 0
 2708 12e0 4C329FE5 		ldr	r3, .L149+36
 2709 12e4 0720A0E3 		mov	r2, #7
 2710 12e8 0820C3E5 		strb	r2, [r3, #8]
 416:bellator_low_level.c **** 	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 2711              		.loc 3 416 0
 2712 12ec 7C20E0E3 		mvn	r2, #124
 2713 12f0 0C20C3E5 		strb	r2, [r3, #12]
 419:bellator_low_level.c **** 	U1DLL	 = 0x06; // DivisorLatchLow bit
 2714              		.loc 3 419 0
 2715 12f4 832082E2 		add	r2, r2, #131
 2716 12f8 0020C3E5 		strb	r2, [r3, #0]
 420:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 2717              		.loc 3 420 0
 2718 12fc 0410C3E5 		strb	r1, [r3, #4]
 421:bellator_low_level.c **** 	U1FDR	|= 0x05; // DivAddVal
 2719              		.loc 3 421 0
 2720 1300 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2721 1304 FF2002E2 		and	r2, r2, #255
 2722 1308 052082E3 		orr	r2, r2, #5
 2723 130c 2820C3E5 		strb	r2, [r3, #40]
 422:bellator_low_level.c **** 	U1FDR	|= 0x0E << 4; // MulVal = 14
 2724              		.loc 3 422 0
 2725 1310 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2726 1314 E02082E3 		orr	r2, r2, #224
 2727 1318 2820C3E5 		strb	r2, [r3, #40]
 429:bellator_low_level.c **** 	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 2728              		.loc 3 429 0
 2729 131c 0320A0E3 		mov	r2, #3
 2730 1320 0C20C3E5 		strb	r2, [r3, #12]
 431:bellator_low_level.c **** 	VICVectAddr4 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 2731              		.loc 3 431 0
 2732 1324 0C229FE5 		ldr	r2, .L149+40
 2733 1328 EF2E05E5 		str	r2, [r5, #-3823]
 432:bellator_low_level.c **** 	VICVectCntl4 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 2734              		.loc 3 432 0
 2735 132c 2720A0E3 		mov	r2, #39
 2736 1330 EF2D05E5 		str	r2, [r5, #-3567]
 433:bellator_low_level.c **** 	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 2737              		.loc 3 433 0
 2738 1334 EF2F15E5 		ldr	r2, [r5, #-4079]
 2739 1338 802082E3 		orr	r2, r2, #128
 2740 133c EF2F05E5 		str	r2, [r5, #-4079]
 435:bellator_low_level.c **** 	cmd_out.i = 0;
 2741              		.loc 3 435 0
 2742 1340 F4219FE5 		ldr	r2, .L149+44
 2743 1344 4C1082E5 		str	r1, [r2, #76]
 436:bellator_low_level.c **** 	cmd_in.i = 0;
 2744              		.loc 3 436 0
 2745 1348 141082E5 		str	r1, [r2, #20]
 438:bellator_low_level.c **** 	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 2746              		.loc 3 438 0
 2747 134c 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 2748 1350 FF2002E2 		and	r2, r2, #255
 2749 1354 0720CDE5 		strb	r2, [sp, #7]
 2750              	.LVL131:
 439:bellator_low_level.c **** 	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
 2751              		.loc 3 439 0
 2752 1358 0460C3E5 		strb	r6, [r3, #4]
 2753              	.LBE68:
 2754              	.LBE67:
 2755              	.LBB69:
 2756              	.LBB70:
 451:bellator_low_level.c **** 	T3PR = SAMPLE_RATE; // Increment the timer every PCLK
 2757              		.loc 3 451 0
 2758 135c 193983E2 		add	r3, r3, #409600
 2759 1360 0420A0E3 		mov	r2, #4	@ movhi
 2760 1364 BC20C3E1 		strh	r2, [r3, #12]	@ movhi
 453:bellator_low_level.c **** 	T3PC = 0;
 2761              		.loc 3 453 0
 2762 1368 B011C3E1 		strh	r1, [r3, #16]	@ movhi
 454:bellator_low_level.c **** 	T3TC = 0; // Counter = 0
 2763              		.loc 3 454 0
 2764 136c B810C3E1 		strh	r1, [r3, #8]	@ movhi
 456:bellator_low_level.c **** 	T3MCR |= (0x1 << 0); // Interrupt on MAT3.0
 2765              		.loc 3 456 0
 2766 1370 B421D3E1 		ldrh	r2, [r3, #20]
 2767 1374 062082E1 		orr	r2, r2, r6
 2768 1378 B421C3E1 		strh	r2, [r3, #20]	@ movhi
 457:bellator_low_level.c **** 	T3MCR |= (0x1 << 1); // Reset the counter on MAT3.0
 2769              		.loc 3 457 0
 2770 137c B421D3E1 		ldrh	r2, [r3, #20]
 2771 1380 022082E3 		orr	r2, r2, #2
 2772 1384 B421C3E1 		strh	r2, [r3, #20]	@ movhi
 460:bellator_low_level.c **** 	T3MR0 = 15000; // MAT3.0 every 15000/(SAMPLE_RATE + 1) counts (1ms/(SAMPLE_RATE + 1))
 2773              		.loc 3 460 0
 2774 1388 B0219FE5 		ldr	r2, .L149+48
 2775 138c B821C3E1 		strh	r2, [r3, #24]	@ movhi
 466:bellator_low_level.c **** 	VICVectAddr3 = (unsigned int) &sample; //Setting the interrupt handler location
 2776              		.loc 3 466 0
 2777 1390 AC219FE5 		ldr	r2, .L149+52
 2778 1394 F32E05E5 		str	r2, [r5, #-3827]
 467:bellator_low_level.c **** 	VICVectCntl3 = 0x3B; //Vectored Interrupt slot enabled and with source #27 (TIMER3)
 2779              		.loc 3 467 0
 2780 1398 3B20A0E3 		mov	r2, #59
 2781 139c F32D05E5 		str	r2, [r5, #-3571]
 468:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 27; //source #27 enabled as FIQ or IRQ
 2782              		.loc 3 468 0
 2783 13a0 EF2F15E5 		ldr	r2, [r5, #-4079]
 2784 13a4 022382E3 		orr	r2, r2, #134217728
 2785 13a8 EF2F05E5 		str	r2, [r5, #-4079]
 470:bellator_low_level.c **** 	T3TCR = 1; // enable T3
 2786              		.loc 3 470 0
 2787 13ac 0460C3E5 		strb	r6, [r3, #4]
 2788              	.LBE70:
 2789              	.LBE69:
 126:bellator_low_level.c **** 	VICDefVectAddr = (unsigned int) &error;
 2790              		.loc 3 126 0
 2791 13b0 90319FE5 		ldr	r3, .L149+56
 2792 13b4 CB3F05E5 		str	r3, [r5, #-4043]
 132:bellator_low_level.c **** 		if (send_data) {
 2793              		.loc 3 132 0
 2794 13b8 7C319FE5 		ldr	r3, .L149+44
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 2795              		.loc 3 134 0
 2796 13bc 7D5FA0E3 		mov	r5, #500
 2797              	.LBB71:
 107:bellator_low_level.c **** int main(void){
 2798              		.loc 3 107 0
 2799 13c0 686083E2 		add	r6, r3, #104
 2800              	.LBB72:
 2801              	.LBB73:
 2802              	.LBB74:
 2803              	.LBB75:
 747:bellator_low_level.c **** 	}
 748:bellator_low_level.c **** }
 749:bellator_low_level.c **** 
 750:bellator_low_level.c **** /**
 751:bellator_low_level.c ****  *
 752:bellator_low_level.c ****  */
 753:bellator_low_level.c **** static inline void protocol_out_cmd(){
 754:bellator_low_level.c **** 	for (unsigned short i = 0; i < cmd_out.i; i++)
 755:bellator_low_level.c **** 		protocol_out_char(cmd_out.buff[i]);
 756:bellator_low_level.c **** }
 757:bellator_low_level.c **** 
 758:bellator_low_level.c **** /**
 759:bellator_low_level.c ****  *
 760:bellator_low_level.c ****  */
 761:bellator_low_level.c **** static inline void protocol_out_char(char c){
 762:bellator_low_level.c **** 	U1THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
 2804              		.loc 3 762 0
 2805 13c4 074944E2 		sub	r4, r4, #114688
 2806              	.L146:
 2807              	.LBE75:
 2808              	.LBE74:
 2809              	.LBE73:
 2810              	.LBE72:
 2811              	.LBE71:
 132:bellator_low_level.c **** 		if (send_data) {
 2812              		.loc 3 132 0
 2813 13c8 3820D3E5 		ldrb	r2, [r3, #56]	@ zero_extendqisi2
 2814 13cc 000052E3 		cmp	r2, #0
 2815 13d0 FCFFFF0A 		beq	.L146
 2816 13d4 440000EA 		b	.L148
 2817              	.L141:
 2818              	.LBB80:
 138:bellator_low_level.c **** 				data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 2819              		.loc 3 138 0
 2820 13d8 B027D3E1 		ldrh	r2, [r3, #112]
 2821 13dc 012082E2 		add	r2, r2, #1
 2822 13e0 0228A0E1 		mov	r2, r2, asl #16
 2823 13e4 2228A0E1 		mov	r2, r2, lsr #16
 2824 13e8 B027C3E1 		strh	r2, [r3, #112]	@ movhi
 2825 13ec B027D3E1 		ldrh	r2, [r3, #112]
 2826 13f0 0F2002E2 		and	r2, r2, #15
 2827 13f4 B027C3E1 		strh	r2, [r3, #112]	@ movhi
 141:bellator_low_level.c **** 				data = &(sensors_data_buff[data_out_pos]);
 2828              		.loc 3 141 0
 2829 13f8 B017D3E1 		ldrh	r1, [r3, #112]
 2830              	.LVL132:
 144:bellator_low_level.c **** 				cmd_out.buff[0] = (data->encoder_left >> 0x8) & 0xFF;
 2831              		.loc 3 144 0
 2832 13fc 811081E0 		add	r1, r1, r1, asl #1
 2833              	.LVL133:
 2834 1400 811183E0 		add	r1, r3, r1, asl #3
 2835 1404 B427D1E1 		ldrh	r2, [r1, #116]
 2836 1408 2274A0E1 		mov	r7, r2, lsr #8
 2837 140c 5070C3E5 		strb	r7, [r3, #80]
 145:bellator_low_level.c **** 				cmd_out.buff[1] = data->encoder_left & 0xFF;
 2838              		.loc 3 145 0
 2839 1410 5120C3E5 		strb	r2, [r3, #81]
 146:bellator_low_level.c **** 				cmd_out.buff[2] = (data->encoder_right >> 0x8) & 0xFF;
 2840              		.loc 3 146 0
 2841 1414 B627D1E1 		ldrh	r2, [r1, #118]
 2842 1418 2274A0E1 		mov	r7, r2, lsr #8
 2843 141c 5270C3E5 		strb	r7, [r3, #82]
 147:bellator_low_level.c **** 				cmd_out.buff[3] = data->encoder_right & 0xFF;
 2844              		.loc 3 147 0
 2845 1420 5320C3E5 		strb	r2, [r3, #83]
 150:bellator_low_level.c **** 				cmd_out.buff[4] = data->ir_l;
 2846              		.loc 3 150 0
 2847 1424 7C70D1E5 		ldrb	r7, [r1, #124]	@ zero_extendqisi2
 2848 1428 5470C3E5 		strb	r7, [r3, #84]
 151:bellator_low_level.c **** 				cmd_out.buff[5] = data->ir_ml;
 2849              		.loc 3 151 0
 2850 142c 7B70D1E5 		ldrb	r7, [r1, #123]	@ zero_extendqisi2
 2851 1430 5570C3E5 		strb	r7, [r3, #85]
 152:bellator_low_level.c **** 				cmd_out.buff[6] = data->ir_m;
 2852              		.loc 3 152 0
 2853 1434 7A70D1E5 		ldrb	r7, [r1, #122]	@ zero_extendqisi2
 2854 1438 5670C3E5 		strb	r7, [r3, #86]
 153:bellator_low_level.c **** 				cmd_out.buff[7] = data->ir_mr;
 2855              		.loc 3 153 0
 2856 143c 7970D1E5 		ldrb	r7, [r1, #121]	@ zero_extendqisi2
 2857 1440 5770C3E5 		strb	r7, [r3, #87]
 154:bellator_low_level.c **** 				cmd_out.buff[8] = data->ir_r;
 2858              		.loc 3 154 0
 2859 1444 7800D1E5 		ldrb	r0, [r1, #120]	@ zero_extendqisi2
 2860 1448 5800C3E5 		strb	r0, [r3, #88]
 157:bellator_low_level.c **** 				cmd_out.buff[9] = data->ax_h;
 2861              		.loc 3 157 0
 2862 144c 7D00D1E5 		ldrb	r0, [r1, #125]	@ zero_extendqisi2
 2863 1450 5900C3E5 		strb	r0, [r3, #89]
 158:bellator_low_level.c **** 				cmd_out.buff[10] = data->ax_l;
 2864              		.loc 3 158 0
 2865 1454 7E00D1E5 		ldrb	r0, [r1, #126]	@ zero_extendqisi2
 2866 1458 5A00C3E5 		strb	r0, [r3, #90]
 159:bellator_low_level.c **** 				cmd_out.buff[11] = data->ay_h;
 2867              		.loc 3 159 0
 2868 145c 7F00D1E5 		ldrb	r0, [r1, #127]	@ zero_extendqisi2
 2869 1460 5B00C3E5 		strb	r0, [r3, #91]
 160:bellator_low_level.c **** 				cmd_out.buff[12] = data->ay_l;
 2870              		.loc 3 160 0
 2871 1464 8000D1E5 		ldrb	r0, [r1, #128]	@ zero_extendqisi2
 2872 1468 5C00C3E5 		strb	r0, [r3, #92]
 161:bellator_low_level.c **** 				cmd_out.buff[13] = data->az_h;
 2873              		.loc 3 161 0
 2874 146c 8100D1E5 		ldrb	r0, [r1, #129]	@ zero_extendqisi2
 2875 1470 5D00C3E5 		strb	r0, [r3, #93]
 162:bellator_low_level.c **** 				cmd_out.buff[14] = data->az_l;
 2876              		.loc 3 162 0
 2877 1474 8200D1E5 		ldrb	r0, [r1, #130]	@ zero_extendqisi2
 2878 1478 5E00C3E5 		strb	r0, [r3, #94]
 163:bellator_low_level.c **** 				cmd_out.buff[15] = data->gx_h;
 2879              		.loc 3 163 0
 2880 147c 8320D1E5 		ldrb	r2, [r1, #131]	@ zero_extendqisi2
 2881 1480 5F20C3E5 		strb	r2, [r3, #95]
 164:bellator_low_level.c **** 				cmd_out.buff[16] = data->gx_l;
 2882              		.loc 3 164 0
 2883 1484 842081E2 		add	r2, r1, #132
 2884 1488 8410D1E5 		ldrb	r1, [r1, #132]	@ zero_extendqisi2
 2885 148c 6010C3E5 		strb	r1, [r3, #96]
 165:bellator_low_level.c **** 				cmd_out.buff[17] = data->gy_h;
 2886              		.loc 3 165 0
 2887 1490 0110D2E5 		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 2888 1494 6110C3E5 		strb	r1, [r3, #97]
 166:bellator_low_level.c **** 				cmd_out.buff[18] = data->gy_l;
 2889              		.loc 3 166 0
 2890 1498 0210D2E5 		ldrb	r1, [r2, #2]	@ zero_extendqisi2
 2891 149c 6210C3E5 		strb	r1, [r3, #98]
 167:bellator_low_level.c **** 				cmd_out.buff[19] = data->gz_h;
 2892              		.loc 3 167 0
 2893 14a0 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
 2894 14a4 6310C3E5 		strb	r1, [r3, #99]
 168:bellator_low_level.c **** 				cmd_out.buff[20] = data->gz_l;
 2895              		.loc 3 168 0
 2896 14a8 0410D2E5 		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 2897 14ac 6410C3E5 		strb	r1, [r3, #100]
 171:bellator_low_level.c **** 				cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 2898              		.loc 3 171 0
 2899 14b0 B620D2E1 		ldrh	r2, [r2, #6]
 2900 14b4 2214A0E1 		mov	r1, r2, lsr #8
 2901 14b8 6510C3E5 		strb	r1, [r3, #101]
 172:bellator_low_level.c **** 				cmd_out.buff[22] = data->timestamp & 0xFF;
 2902              		.loc 3 172 0
 2903 14bc 6620C3E5 		strb	r2, [r3, #102]
 175:bellator_low_level.c **** 				cmd_out.buff[23] = END_CMD;
 2904              		.loc 3 175 0
 2905 14c0 67E0C3E5 		strb	lr, [r3, #103]
 176:bellator_low_level.c **** 				cmd_out.buff[24] = '\n';
 2906              		.loc 3 176 0
 2907 14c4 68C0C3E5 		strb	ip, [r3, #104]
 2908              	.LVL134:
 2909 14c8 4F1083E2 		add	r1, r3, #79
 2910              	.LVL135:
 2911              	.L140:
 2912              	.LBB79:
 2913              	.LBB78:
 755:bellator_low_level.c **** 		protocol_out_char(cmd_out.buff[i]);
 2914              		.loc 3 755 0
 2915 14cc 0120F1E5 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 2916              	.LVL136:
 2917              	.LBB77:
 2918              	.LBB76:
 2919              		.loc 3 762 0
 2920 14d0 0020C4E5 		strb	r2, [r4, #0]
 2921              	.LVL137:
 2922              	.L139:
 763:bellator_low_level.c **** 	while(!(U1LSR & 0x40));
 2923              		.loc 3 763 0
 2924 14d4 1420D4E5 		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 2925 14d8 400012E3 		tst	r2, #64
 2926 14dc FCFFFF0A 		beq	.L139
 2927              	.LBE76:
 2928              	.LBE77:
 754:bellator_low_level.c **** 	for (unsigned short i = 0; i < cmd_out.i; i++)
 2929              		.loc 3 754 0
 2930 14e0 060051E1 		cmp	r1, r6
 2931 14e4 0200000A 		beq	.L147
 2932 14e8 F7FFFFEA 		b	.L140
 2933              	.L148:
 2934              	.LBE78:
 2935              	.LBE79:
 175:bellator_low_level.c **** 				cmd_out.buff[23] = END_CMD;
 2936              		.loc 3 175 0 discriminator 1
 2937 14ec 01E0E0E3 		mvn	lr, #1
 176:bellator_low_level.c **** 				cmd_out.buff[24] = '\n';
 2938              		.loc 3 176 0 discriminator 1
 2939 14f0 0AC0A0E3 		mov	ip, #10
 2940              	.L147:
 2941              	.LBE80:
 134:bellator_low_level.c **** 			while(data_out_pos != data_in_pos) {
 2942              		.loc 3 134 0 discriminator 1
 2943 14f4 B017D3E1 		ldrh	r1, [r3, #112]
 2944 14f8 B52093E1 		ldrh	r2, [r3, r5]
 2945 14fc 020051E1 		cmp	r1, r2
 2946 1500 B4FFFF1A 		bne	.L141
 182:bellator_low_level.c **** 			send_data = 0;
 2947              		.loc 3 182 0
 2948 1504 0020A0E3 		mov	r2, #0
 2949 1508 3820C3E5 		strb	r2, [r3, #56]
 2950 150c ADFFFFEA 		b	.L146
 2951              	.L150:
 2952              		.align	2
 2953              	.L149:
 2954 1510 00C01FE0 		.word	-534790144
 2955 1514 00C002E0 		.word	-536690688
 2956 1518 00C11FE0 		.word	-534789888
 2957 151c 000007E0 		.word	-536412160
 2958 1520 00000000 		.word	pulse_in
 2959 1524 004003E0 		.word	-536657920
 2960 1528 004000E0 		.word	-536854528
 2961 152c 25010000 		.word	293
 2962 1530 008000E0 		.word	-536838144
 2963 1534 000001E0 		.word	-536805376
 2964 1538 00000000 		.word	protocol_in
 2965 153c 00000000 		.word	.LANCHOR0
 2966 1540 983A0000 		.word	15000
 2967 1544 00000000 		.word	sample
 2968 1548 00000000 		.word	error
 2969              		.cfi_endproc
 2970              	.LFE42:
 2971              		.fnend
 2973              		.align	2
 2974              		.global	get_ir_sensor_data
 2976              	get_ir_sensor_data:
 2977              		.fnstart
 2978              	.LFB56:
 671:bellator_low_level.c **** void get_ir_sensor_data(char * buff) {
 2979              		.loc 3 671 0
 2980              		.cfi_startproc
 2981              		@ Function supports interworking.
 2982              		@ args = 0, pretend = 0, frame = 0
 2983              		@ frame_needed = 0, uses_anonymous_args = 0
 2984              		@ link register save eliminated.
 2985              	.LVL138:
 675:bellator_low_level.c **** 	while(ADDR0 & ((0x1 << 31) == 0));
 2986              		.loc 3 675 0
 2987 154c A0309FE5 		ldr	r3, .L152
 2988 1550 102093E5 		ldr	r2, [r3, #16]
 676:bellator_low_level.c **** 	val = (ADDR0 >> 6) & 0x3FF;
 2989              		.loc 3 676 0
 2990 1554 102093E5 		ldr	r2, [r3, #16]
 677:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 2991              		.loc 3 677 0
 2992 1558 2224A0E1 		mov	r2, r2, lsr #8
 2993              	.LVL139:
 678:bellator_low_level.c **** 	val += (val == 0);
 2994              		.loc 3 678 0
 2995 155c FF2012E2 		ands	r2, r2, #255
 2996              	.LVL140:
 2997 1560 0010A013 		movne	r1, #0
 2998 1564 0110A003 		moveq	r1, #1
 2999              	.LVL141:
 3000 1568 022081E0 		add	r2, r1, r2
 3001              	.LVL142:
 679:bellator_low_level.c **** 	*buff = (char) val;
 3002              		.loc 3 679 0
 3003 156c 0020C0E5 		strb	r2, [r0, #0]
 681:bellator_low_level.c **** 	while(ADDR1 & ((0x1 << 31) == 0));
 3004              		.loc 3 681 0
 3005 1570 142093E5 		ldr	r2, [r3, #20]
 682:bellator_low_level.c **** 	val = (ADDR1 >> 6) & 0x3FF;
 3006              		.loc 3 682 0
 3007 1574 142093E5 		ldr	r2, [r3, #20]
 683:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3008              		.loc 3 683 0
 3009 1578 2224A0E1 		mov	r2, r2, lsr #8
 3010              	.LVL143:
 684:bellator_low_level.c **** 	val += (val == 0);
 3011              		.loc 3 684 0
 3012 157c FF2012E2 		ands	r2, r2, #255
 3013              	.LVL144:
 3014 1580 0010A013 		movne	r1, #0
 3015 1584 0110A003 		moveq	r1, #1
 3016              	.LVL145:
 3017 1588 022081E0 		add	r2, r1, r2
 3018              	.LVL146:
 685:bellator_low_level.c **** 	*(buff+1) = (char) val;
 3019              		.loc 3 685 0
 3020 158c 0120C0E5 		strb	r2, [r0, #1]
 687:bellator_low_level.c **** 	while(ADDR2 & ((0x1 << 31) == 0));
 3021              		.loc 3 687 0
 3022 1590 182093E5 		ldr	r2, [r3, #24]
 688:bellator_low_level.c **** 	val = (ADDR2 >> 6) & 0x3FF;
 3023              		.loc 3 688 0
 3024 1594 182093E5 		ldr	r2, [r3, #24]
 689:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3025              		.loc 3 689 0
 3026 1598 2224A0E1 		mov	r2, r2, lsr #8
 3027              	.LVL147:
 690:bellator_low_level.c **** 	val += (val == 0);
 3028              		.loc 3 690 0
 3029 159c FF2012E2 		ands	r2, r2, #255
 3030              	.LVL148:
 3031 15a0 0010A013 		movne	r1, #0
 3032 15a4 0110A003 		moveq	r1, #1
 3033              	.LVL149:
 3034 15a8 022081E0 		add	r2, r1, r2
 3035              	.LVL150:
 691:bellator_low_level.c **** 	*(buff+2) = (char) val;
 3036              		.loc 3 691 0
 3037 15ac 0220C0E5 		strb	r2, [r0, #2]
 693:bellator_low_level.c **** 	while(ADDR3 & ((0x1 << 31) == 0));
 3038              		.loc 3 693 0
 3039 15b0 1C2093E5 		ldr	r2, [r3, #28]
 694:bellator_low_level.c **** 	val = (ADDR3 >> 6) & 0x3FF;
 3040              		.loc 3 694 0
 3041 15b4 1C2093E5 		ldr	r2, [r3, #28]
 695:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3042              		.loc 3 695 0
 3043 15b8 2224A0E1 		mov	r2, r2, lsr #8
 3044              	.LVL151:
 696:bellator_low_level.c **** 	val += (val == 0);
 3045              		.loc 3 696 0
 3046 15bc FF2012E2 		ands	r2, r2, #255
 3047              	.LVL152:
 3048 15c0 0010A013 		movne	r1, #0
 3049 15c4 0110A003 		moveq	r1, #1
 3050              	.LVL153:
 3051 15c8 022081E0 		add	r2, r1, r2
 3052              	.LVL154:
 697:bellator_low_level.c **** 	*(buff+3) = (char) val;
 3053              		.loc 3 697 0
 3054 15cc 0320C0E5 		strb	r2, [r0, #3]
 699:bellator_low_level.c **** 	while(ADDR4 & ((0x1 << 31) == 0));
 3055              		.loc 3 699 0
 3056 15d0 202093E5 		ldr	r2, [r3, #32]
 700:bellator_low_level.c **** 	val = (ADDR4 >> 6) & 0x3FF;
 3057              		.loc 3 700 0
 3058 15d4 203093E5 		ldr	r3, [r3, #32]
 701:bellator_low_level.c **** 	val >>= 0x2; // they want a value from 1 to 255
 3059              		.loc 3 701 0
 3060 15d8 2334A0E1 		mov	r3, r3, lsr #8
 3061              	.LVL155:
 702:bellator_low_level.c **** 	val += (val == 0);
 3062              		.loc 3 702 0
 3063 15dc FF3013E2 		ands	r3, r3, #255
 3064              	.LVL156:
 3065 15e0 0020A013 		movne	r2, #0
 3066 15e4 0120A003 		moveq	r2, #1
 3067              	.LVL157:
 3068 15e8 033082E0 		add	r3, r2, r3
 3069              	.LVL158:
 703:bellator_low_level.c **** 	*(buff+4) = (char) val;
 3070              		.loc 3 703 0
 3071 15ec 0430C0E5 		strb	r3, [r0, #4]
 704:bellator_low_level.c **** }
 3072              		.loc 3 704 0
 3073 15f0 1EFF2FE1 		bx	lr
 3074              	.L153:
 3075              		.align	2
 3076              	.L152:
 3077 15f4 004003E0 		.word	-536657920
 3078              		.cfi_endproc
 3079              	.LFE56:
 3080              		.fnend
 3082              		.align	2
 3083              		.global	get_encoders_count
 3085              	get_encoders_count:
 3086              		.fnstart
 3087              	.LFB57:
 711:bellator_low_level.c **** void get_encoders_count(short * left_encoder, short * right_encoder) {
 3088              		.loc 3 711 0
 3089              		.cfi_startproc
 3090              		@ Function supports interworking.
 3091              		@ args = 0, pretend = 0, frame = 0
 3092              		@ frame_needed = 0, uses_anonymous_args = 0
 3093              		@ link register save eliminated.
 3094              	.LVL159:
 714:bellator_low_level.c **** 	val = encoder_count[ENCODER_L - ENCODER_L];
 3095              		.loc 3 714 0
 3096 15f8 28309FE5 		ldr	r3, .L155
 3097 15fc 442093E5 		ldr	r2, [r3, #68]
 3098              	.LVL160:
 715:bellator_low_level.c **** 	*left_encoder = val - sent_encoder_count[ENCODER_L - ENCODER_L];
 3099              		.loc 3 715 0
 3100 1600 F8C193E5 		ldr	ip, [r3, #504]
 3101 1604 02C06CE0 		rsb	ip, ip, r2
 3102 1608 B0C0C0E1 		strh	ip, [r0, #0]	@ movhi
 716:bellator_low_level.c **** 	sent_encoder_count[ENCODER_L - ENCODER_L] = val;
 3103              		.loc 3 716 0
 3104 160c F82183E5 		str	r2, [r3, #504]
 718:bellator_low_level.c **** 	val = encoder_count[ENCODER_R - ENCODER_L];
 3105              		.loc 3 718 0
 3106 1610 482093E5 		ldr	r2, [r3, #72]
 3107              	.LVL161:
 719:bellator_low_level.c **** 	*right_encoder = val - sent_encoder_count[ENCODER_R - ENCODER_L];
 3108              		.loc 3 719 0
 3109 1614 FC0193E5 		ldr	r0, [r3, #508]
 3110              	.LVL162:
 3111 1618 020060E0 		rsb	r0, r0, r2
 3112 161c B000C1E1 		strh	r0, [r1, #0]	@ movhi
 720:bellator_low_level.c **** 	sent_encoder_count[ENCODER_R - ENCODER_L] = val;
 3113              		.loc 3 720 0
 3114 1620 FC2183E5 		str	r2, [r3, #508]
 721:bellator_low_level.c **** }
 3115              		.loc 3 721 0
 3116 1624 1EFF2FE1 		bx	lr
 3117              	.L156:
 3118              		.align	2
 3119              	.L155:
 3120 1628 00000000 		.word	.LANCHOR0
 3121              		.cfi_endproc
 3122              	.LFE57:
 3123              		.fnend
 3125              		.align	2
 3126              		.global	sample
 3128              	sample:
 3129              		.fnstart
 3130              	.LFB54:
 614:bellator_low_level.c **** void sample(void) {
 3131              		.loc 3 614 0
 3132              		.cfi_startproc
 3133              		@ Interrupt Service Routine.
 3134              		@ args = 0, pretend = 0, frame = 8
 3135              		@ frame_needed = 0, uses_anonymous_args = 0
 3136 162c 04E04EE2 		sub	lr, lr, #4
 3137 1630 FF502DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, ip, lr}
 3138              		.save {r0, r1, r2, r3, r4, r5, r6, r7, ip, lr}
 3139              	.LCFI43:
 3140              		.cfi_def_cfa_offset 40
 3141              		.pad #8
 3142 1634 08D04DE2 		sub	sp, sp, #8
 3143              	.LCFI44:
 3144              		.cfi_def_cfa_offset 48
 615:bellator_low_level.c **** 	volatile unsigned short ir = T3IR;
 3145              		.loc 3 615 0
 3146 1638 18319FE5 		ldr	r3, .L160
 3147              		.cfi_offset 14, -4
 3148              		.cfi_offset 12, -8
 3149              		.cfi_offset 7, -12
 3150              		.cfi_offset 6, -16
 3151              		.cfi_offset 5, -20
 3152              		.cfi_offset 4, -24
 3153              		.cfi_offset 3, -28
 3154              		.cfi_offset 2, -32
 3155              		.cfi_offset 1, -36
 3156              		.cfi_offset 0, -40
 3157 163c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3158 1640 FF3003E2 		and	r3, r3, #255
 3159 1644 B630CDE1 		strh	r3, [sp, #6]	@ movhi
 3160              	.LVL163:
 616:bellator_low_level.c **** 	if(ir & 0x1) { // MAT3.0
 3161              		.loc 3 616 0
 3162 1648 B630DDE1 		ldrh	r3, [sp, #6]
 3163              	.LVL164:
 3164 164c 010013E3 		tst	r3, #1
 3165 1650 3B00000A 		beq	.L158
 3166              	.LBB81:
 621:bellator_low_level.c **** 		T3IR |= 0x1 << 0; // clear MAT3.0 interrupt
 3167              		.loc 3 621 0
 3168 1654 FC309FE5 		ldr	r3, .L160
 3169              	.LVL165:
 3170 1658 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 3171 165c FF2002E2 		and	r2, r2, #255
 3172 1660 012082E3 		orr	r2, r2, #1
 3173 1664 0020C3E5 		strb	r2, [r3, #0]
 622:bellator_low_level.c **** 		IENABLE
 3174              		.loc 3 622 0
 3175              	#APP
 3176              	@ 622 "bellator_low_level.c" 1
 3177 1668 00E04FE1 		MRS		LR, SPSR
 3178              	@ 0 "" 2
 3179              	@ 622 "bellator_low_level.c" 1
 3180 166c 04E02DE5 		STMFD	SP!, {LR}
 3181              	@ 0 "" 2
 3182              	@ 622 "bellator_low_level.c" 1
 3183 1670 1FF021E3 		MSR		CPSR_c, #0x1F
 3184              	@ 0 "" 2
 3185              	@ 622 "bellator_low_level.c" 1
 3186 1674 04E02DE5 		STMFD	SP!, {LR}
 3187              	@ 0 "" 2
 625:bellator_low_level.c **** 		data_in_pos = ++data_in_pos % DATA_BUFF_SIZE;
 3188              		.loc 3 625 0
 3189 1678 DC309FE5 		ldr	r3, .L160+4
 3190 167c 7D2FA0E3 		mov	r2, #500
 3191 1680 B21093E1 		ldrh	r1, [r3, r2]
 3192 1684 011081E2 		add	r1, r1, #1
 3193 1688 0118A0E1 		mov	r1, r1, asl #16
 3194 168c 2118A0E1 		mov	r1, r1, lsr #16
 3195 1690 B21083E1 		strh	r1, [r3, r2]	@ movhi
 3196 1694 B21093E1 		ldrh	r1, [r3, r2]
 3197 1698 0F1001E2 		and	r1, r1, #15
 3198 169c B21083E1 		strh	r1, [r3, r2]	@ movhi
 628:bellator_low_level.c **** 		if (data_in_pos == data_out_pos) {
 3199              		.loc 3 628 0
 3200 16a0 B22093E1 		ldrh	r2, [r3, r2]
 3201 16a4 B037D3E1 		ldrh	r3, [r3, #112]
 3202 16a8 030052E1 		cmp	r2, r3
 3203 16ac 0800001A 		bne	.L159
 631:bellator_low_level.c **** 			data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
 3204              		.loc 3 631 0
 3205 16b0 A4309FE5 		ldr	r3, .L160+4
 3206 16b4 B027D3E1 		ldrh	r2, [r3, #112]
 3207 16b8 012082E2 		add	r2, r2, #1
 3208 16bc 0228A0E1 		mov	r2, r2, asl #16
 3209 16c0 2228A0E1 		mov	r2, r2, lsr #16
 3210 16c4 B027C3E1 		strh	r2, [r3, #112]	@ movhi
 3211 16c8 B027D3E1 		ldrh	r2, [r3, #112]
 3212 16cc 0F2002E2 		and	r2, r2, #15
 3213 16d0 B027C3E1 		strh	r2, [r3, #112]	@ movhi
 3214              	.L159:
 636:bellator_low_level.c **** 		data = &(sensors_data_buff[data_in_pos]);
 3215              		.loc 3 636 0
 3216 16d4 80409FE5 		ldr	r4, .L160+4
 3217 16d8 7D3FA0E3 		mov	r3, #500
 3218 16dc B36094E1 		ldrh	r6, [r4, r3]
 3219              	.LVL166:
 639:bellator_low_level.c **** 		get_encoders_count(&(data->encoder_left), &(data->encoder_right));
 3220              		.loc 3 639 0
 3221 16e0 745084E2 		add	r5, r4, #116
 3222 16e4 8670A0E1 		mov	r7, r6, asl #1
 3223 16e8 061087E0 		add	r1, r7, r6
 3224 16ec 811185E0 		add	r1, r5, r1, asl #3
 3225 16f0 0100A0E1 		mov	r0, r1
 3226 16f4 021081E2 		add	r1, r1, #2
 3227 16f8 FEFFFFEB 		bl	get_encoders_count
 642:bellator_low_level.c **** 		mpu_get_motion6(&(data->ax_h));
 3228              		.loc 3 642 0
 3229 16fc 063087E0 		add	r3, r7, r6
 3230 1700 835185E0 		add	r5, r5, r3, asl #3
 3231 1704 090085E2 		add	r0, r5, #9
 3232 1708 085085E2 		add	r5, r5, #8
 3233 170c FEFFFFEB 		bl	mpu_get_motion6
 645:bellator_low_level.c **** 		get_ir_sensor_data(&(data->ir_l));
 3234              		.loc 3 645 0
 3235 1710 0500A0E1 		mov	r0, r5
 3236 1714 FEFFFFEB 		bl	get_ir_sensor_data
 647:bellator_low_level.c **** 		data->timestamp = timestamp++;
 3237              		.loc 3 647 0
 3238 1718 023CA0E3 		mov	r3, #512
 3239 171c B32094E1 		ldrh	r2, [r4, r3]
 3240 1720 066087E0 		add	r6, r7, r6
 3241              	.LVL167:
 3242 1724 866184E0 		add	r6, r4, r6, asl #3
 3243 1728 BA28C6E1 		strh	r2, [r6, #138]	@ movhi
 3244 172c 012082E2 		add	r2, r2, #1
 3245 1730 B32084E1 		strh	r2, [r4, r3]	@ movhi
 650:bellator_low_level.c **** 		IDISABLE
 3246              		.loc 3 650 0
 3247              	#APP
 3248              	@ 650 "bellator_low_level.c" 1
 3249 1734 04E09DE4 		LDMFD	SP!, {LR}
 3250              	@ 0 "" 2
 3251              	@ 650 "bellator_low_level.c" 1
 3252 1738 92F021E3 		MSR		CPSR_c, #0x92
 3253              	@ 0 "" 2
 3254              	@ 650 "bellator_low_level.c" 1
 3255 173c 04E09DE4 		LDMFD	SP!, {LR}
 3256              	@ 0 "" 2
 3257              	@ 650 "bellator_low_level.c" 1
 3258 1740 0EF06FE1 		MSR		SPSR_cxsf, LR
 3259              	@ 0 "" 2
 3260              	.LVL168:
 3261              	.L158:
 3262              	.LBE81:
 655:bellator_low_level.c **** 	VICVectAddr = 0;
 3263              		.loc 3 655 0
 3264 1744 0020A0E3 		mov	r2, #0
 3265 1748 0030E0E3 		mvn	r3, #0
 3266              	.LVL169:
 3267 174c CF2F03E5 		str	r2, [r3, #-4047]
 656:bellator_low_level.c **** }
 3268              		.loc 3 656 0
 3269 1750 08D08DE2 		add	sp, sp, #8
 3270 1754 FF90FDE8 		ldmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, ip, pc}^
 3271              	.L161:
 3272              		.align	2
 3273              	.L160:
 3274 1758 004007E0 		.word	-536395776
 3275 175c 00000000 		.word	.LANCHOR0
 3276              		.cfi_endproc
 3277              	.LFE54:
 3278              		.fnend
 3280              		.global	ascii
 3281              		.section	.rodata
 3282              		.align	2
 3283              	.LANCHOR1 = . + 0
 3286              	ascii:
 3287 0000 30313233 		.ascii	"0123456789ABCDEF\000"
 3287      34353637 
 3287      38394142 
 3287      43444546 
 3287      00
 3288 0011 000000   		.bss
 3289              		.align	2
 3290              	.LANCHOR0 = . + 0
 3293              	ra_buff:
 3294 0000 00       		.space	1
 3295 0001 000000   		.space	3
 3298              	buff_size:
 3299 0004 00000000 		.space	4
 3302              	buff_pos:
 3303 0008 00000000 		.space	4
 3306              	c_buff:
 3307 000c 00000000 		.space	4
 3310              	busy:
 3311 0010 00000000 		.space	4
 3314              	cmd_in:
 3315 0014 00000000 		.space	36
 3315      00000000 
 3315      00000000 
 3315      00000000 
 3315      00000000 
 3318              	send_data:
 3319 0038 00       		.space	1
 3320 0039 000000   		.space	3
 3323              	forward_l:
 3324 003c 00000000 		.space	4
 3327              	forward_r:
 3328 0040 00000000 		.space	4
 3331              	encoder_count:
 3332 0044 00000000 		.space	8
 3332      00000000 
 3335              	cmd_out:
 3336 004c 00000000 		.space	36
 3336      00000000 
 3336      00000000 
 3336      00000000 
 3336      00000000 
 3339              	data_out_pos:
 3340 0070 0000     		.space	2
 3341 0072 0000     		.space	2
 3344              	sensors_data_buff:
 3345 0074 00000000 		.space	384
 3345      00000000 
 3345      00000000 
 3345      00000000 
 3345      00000000 
 3348              	data_in_pos:
 3349 01f4 0000     		.space	2
 3350 01f6 0000     		.space	2
 3353              	sent_encoder_count:
 3354 01f8 00000000 		.space	8
 3354      00000000 
 3357              	timestamp:
 3358 0200 0000     		.space	2
 3359 0202 0000     		.text
 3360              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 bellator_low_level.c
     /tmp/ccBFGmff.s:21     .text:00000000 $a
     /tmp/ccBFGmff.s:23     .text:00000000 log_char
     /tmp/ccBFGmff.s:49     .text:0000001c $d
                       .ARM.exidx:00000000 $d
     /tmp/ccBFGmff.s:54     .text:00000020 $a
     /tmp/ccBFGmff.s:57     .text:00000020 i2c_read_bytes_isr
     /tmp/ccBFGmff.s:96     .text:00000054 $d
     /tmp/ccBFGmff.s:179    .text:00000198 $a
     /tmp/ccBFGmff.s:299    .text:000002d8 $d
                       .ARM.extab:00000000 $d
     /tmp/ccBFGmff.s:305    .text:000002e0 $a
     /tmp/ccBFGmff.s:308    .text:000002e0 i2c_write_byte_isr
     /tmp/ccBFGmff.s:345    .text:00000314 $d
     /tmp/ccBFGmff.s:388    .text:000003b8 $a
     /tmp/ccBFGmff.s:466    .text:00000490 $d
     /tmp/ccBFGmff.s:472    .text:00000498 $a
     /tmp/ccBFGmff.s:475    .text:00000498 protocol_in
     /tmp/ccBFGmff.s:543    .text:000004dc $d
     /tmp/ccBFGmff.s:558    .text:00000510 $a
     /tmp/ccBFGmff.s:717    .text:0000068c $d
     /tmp/ccBFGmff.s:725    .text:0000069c $a
     /tmp/ccBFGmff.s:728    .text:0000069c pulse_in
     /tmp/ccBFGmff.s:862    .text:000007dc $d
     /tmp/ccBFGmff.s:869    .text:000007e8 $a
     /tmp/ccBFGmff.s:872    .text:000007e8 error
     /tmp/ccBFGmff.s:890    .text:000007ec logger_init
     /tmp/ccBFGmff.s:934    .text:00000848 $d
     /tmp/ccBFGmff.s:940    .text:00000850 $a
     /tmp/ccBFGmff.s:943    .text:00000850 log_int
     /tmp/ccBFGmff.s:1024   .text:000008f4 $d
     /tmp/ccBFGmff.s:1029   .text:000008f8 $a
     /tmp/ccBFGmff.s:1032   .text:000008f8 log_short
     /tmp/ccBFGmff.s:1098   .text:00000964 $d
     /tmp/ccBFGmff.s:1103   .text:00000968 $a
     /tmp/ccBFGmff.s:1106   .text:00000968 log_string
     /tmp/ccBFGmff.s:1156   .text:000009a8 log_byte
     /tmp/ccBFGmff.s:1211   .text:000009f4 $d
     /tmp/ccBFGmff.s:1216   .text:000009f8 $a
     /tmp/ccBFGmff.s:1219   .text:000009f8 log2bytes
     /tmp/ccBFGmff.s:1285   .text:00000a64 $d
     /tmp/ccBFGmff.s:1290   .text:00000a68 $a
     /tmp/ccBFGmff.s:1293   .text:00000a68 log4bytes
     /tmp/ccBFGmff.s:1374   .text:00000b0c $d
     /tmp/ccBFGmff.s:1379   .text:00000b10 $a
     /tmp/ccBFGmff.s:1382   .text:00000b10 i2c_init
     /tmp/ccBFGmff.s:1427   .text:00000b70 $d
     /tmp/ccBFGmff.s:1432   .text:00000b74 $a
     /tmp/ccBFGmff.s:1435   .text:00000b74 i2c_read_bytes
     /tmp/ccBFGmff.s:1482   .text:00000bc4 $d
     /tmp/ccBFGmff.s:1489   .text:00000bd0 $a
     /tmp/ccBFGmff.s:1492   .text:00000bd0 i2c_read_byte
     /tmp/ccBFGmff.s:1523   .text:00000be8 i2c_write_byte
     /tmp/ccBFGmff.s:1576   .text:00000c48 $d
     /tmp/ccBFGmff.s:1583   .text:00000c54 $a
     /tmp/ccBFGmff.s:1586   .text:00000c54 i2c_write_bits
     /tmp/ccBFGmff.s:1652   .text:00000cb4 mpu_set_clock_source
     /tmp/ccBFGmff.s:1685   .text:00000cd4 mpu_set_full_scale_gyro_range
     /tmp/ccBFGmff.s:1717   .text:00000cf4 mpu_set_full_scale_accel_range
     /tmp/ccBFGmff.s:1749   .text:00000d14 mpu_set_sleep_enable
     /tmp/ccBFGmff.s:1781   .text:00000d34 mpu_set_temperature_sensor_enabled
     /tmp/ccBFGmff.s:1814   .text:00000d58 mpu_set_gyro_rate
     /tmp/ccBFGmff.s:1844   .text:00000d70 mpu_set_DLPF_mode
     /tmp/ccBFGmff.s:1876   .text:00000d90 mpu_set_6axis_FIFO_enabled
     /tmp/ccBFGmff.s:1906   .text:00000da8 mpu_set_interrupt_mode
     /tmp/ccBFGmff.s:1938   .text:00000dc8 mpu_set_interrupt_drive
     /tmp/ccBFGmff.s:1970   .text:00000de8 mpu_set_interrupt_latch
     /tmp/ccBFGmff.s:2002   .text:00000e08 mpu_set_FIFO_overflow_interrupt
     /tmp/ccBFGmff.s:2034   .text:00000e28 mpu_set_data_ready_interrupt
     /tmp/ccBFGmff.s:2066   .text:00000e48 mpu_clear_interrupt
     /tmp/ccBFGmff.s:2097   .text:00000e60 mpu_set_FIFO_enabled
     /tmp/ccBFGmff.s:2129   .text:00000e80 mpu_reset_FIFO
     /tmp/ccBFGmff.s:2159   .text:00000ea0 mpu_init
     /tmp/ccBFGmff.s:2212   .text:00000ef8 mpu_get_FIFO_size
     /tmp/ccBFGmff.s:2254   .text:00000f30 mpu_get_motion6
     /tmp/ccBFGmff.s:2327   .text:00000fb8 mpu_get_FIFO_motion6
     /tmp/ccBFGmff.s:2400   .text:00001040 main
     /tmp/ccBFGmff.s:2954   .text:00001510 $d
     /tmp/ccBFGmff.s:3128   .text:0000162c sample
     /tmp/ccBFGmff.s:2973   .text:0000154c $a
     /tmp/ccBFGmff.s:2976   .text:0000154c get_ir_sensor_data
     /tmp/ccBFGmff.s:3077   .text:000015f4 $d
     /tmp/ccBFGmff.s:3082   .text:000015f8 $a
     /tmp/ccBFGmff.s:3085   .text:000015f8 get_encoders_count
     /tmp/ccBFGmff.s:3120   .text:00001628 $d
     /tmp/ccBFGmff.s:3125   .text:0000162c $a
     /tmp/ccBFGmff.s:3274   .text:00001758 $d
     /tmp/ccBFGmff.s:3286   .rodata:00000000 ascii
     /tmp/ccBFGmff.s:3282   .rodata:00000000 $d
     /tmp/ccBFGmff.s:3289   .bss:00000000 $d
     /tmp/ccBFGmff.s:3293   .bss:00000000 ra_buff
     /tmp/ccBFGmff.s:3298   .bss:00000004 buff_size
     /tmp/ccBFGmff.s:3302   .bss:00000008 buff_pos
     /tmp/ccBFGmff.s:3306   .bss:0000000c c_buff
     /tmp/ccBFGmff.s:3310   .bss:00000010 busy
     /tmp/ccBFGmff.s:3314   .bss:00000014 cmd_in
     /tmp/ccBFGmff.s:3318   .bss:00000038 send_data
     /tmp/ccBFGmff.s:3323   .bss:0000003c forward_l
     /tmp/ccBFGmff.s:3327   .bss:00000040 forward_r
     /tmp/ccBFGmff.s:3331   .bss:00000044 encoder_count
     /tmp/ccBFGmff.s:3335   .bss:0000004c cmd_out
     /tmp/ccBFGmff.s:3339   .bss:00000070 data_out_pos
     /tmp/ccBFGmff.s:3344   .bss:00000074 sensors_data_buff
     /tmp/ccBFGmff.s:3348   .bss:000001f4 data_in_pos
     /tmp/ccBFGmff.s:3353   .bss:000001f8 sent_encoder_count
     /tmp/ccBFGmff.s:3357   .bss:00000200 timestamp
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_unwind_cpp_pr0
__aeabi_unwind_cpp_pr1
