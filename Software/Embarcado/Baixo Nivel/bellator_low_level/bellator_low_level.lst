   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 2
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 18, 4
  11              		.file	"bellator_low_level.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  23              	log_char:
  24              		.fnstart
  25              	.LFB1:
  26              		.file 1 "logger.c"
   1:logger.c      **** /*
   2:logger.c      ****  * logger.c
   3:logger.c      ****  *
   4:logger.c      ****  *  Created on: Jul 14, 2009
   5:logger.c      ****  *      Author: telmo
   6:logger.c      ****  */
   7:logger.c      **** #include "lpc2103.h"
   8:logger.c      **** #include "logger.h"
   9:logger.c      **** 
  10:logger.c      **** /**
  11:logger.c      ****  * Start logger using UART0
  12:logger.c      ****  * 8N1 (8 data, Non parity, 1 stop)
  13:logger.c      ****  * 115200 bps
  14:logger.c      ****  *
  15:logger.c      ****  * UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL) * ( 1 + DivAddVal/MulVal))
  16:logger.c      ****  * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
  17:logger.c      ****  * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
  18:logger.c      ****  * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
  19:logger.c      ****  */
  20:logger.c      **** void logger_init(void){ // using UART0
  21:logger.c      **** 	PINSEL0 |= 0x05; // Set the pins function
  22:logger.c      **** 	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
  23:logger.c      **** 	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
  24:logger.c      **** 
  25:logger.c      **** #ifdef CRYSTAL12MHz
  26:logger.c      **** 	U0DLL	 = 0x06; // DivisorLatchLow bit
  27:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
  28:logger.c      **** 	U0FDR	|= 0x05; // DivAddVal
  29:logger.c      **** 	U0FDR	|= 0x0E << 4; // MulVal = 14
  30:logger.c      **** #endif
  31:logger.c      **** #ifdef CRYSTAL14745600Hz
  32:logger.c      **** 	U0DLL	 = 0x08; // DivisorLatchLow bit
  33:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
  34:logger.c      **** #endif
  35:logger.c      **** 
  36:logger.c      **** 	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
  37:logger.c      **** }
  38:logger.c      **** 
  39:logger.c      **** static void log_char(char c){
  27              		.loc 1 39 0
  28              		.cfi_startproc
  29              		@ Function supports interworking.
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  40:logger.c      **** 	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
  34              		.loc 1 40 0
  35 0000 10309FE5 		ldr	r3, .L3
  36 0004 0000C3E5 		strb	r0, [r3, #0]
  37              	.L2:
  41:logger.c      **** 	while(!(U0LSR & 0x40));
  38              		.loc 1 41 0 discriminator 1
  39 0008 1420D3E5 		ldrb	r2, [r3, #20]	@ zero_extendqisi2
  40 000c 400012E3 		tst	r2, #64
  41 0010 FCFFFF0A 		beq	.L2
  42:logger.c      **** }
  42              		.loc 1 42 0
  43 0014 1EFF2FE1 		bx	lr
  44              	.L4:
  45              		.align	2
  46              	.L3:
  47 0018 00C000E0 		.word	-536821760
  48              		.cfi_endproc
  49              	.LFE1:
  50              		.fnend
  52              		.align	2
  54              	asm_get_cpsr:
  55              		.fnstart
  56              	.LFB8:
  57              		.file 2 "irq.c"
   1:irq.c         **** /*
   2:irq.c         ****  * irq.c
   3:irq.c         ****  *
   4:irq.c         ****  *  Created on: Jul 15, 2009
   5:irq.c         ****  *      Author: telmo
   6:irq.c         ****  */
   7:irq.c         **** 
   8:irq.c         **** #include "irq.h"
   9:irq.c         **** 
  10:irq.c         **** static inline unsigned asm_get_cpsr(void)
  11:irq.c         **** {
  58              		.loc 2 11 0
  59              		.cfi_startproc
  60              		@ Function supports interworking.
  61              		@ args = 0, pretend = 0, frame = 0
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		@ link register save eliminated.
  12:irq.c         ****   unsigned long retval;
  13:irq.c         ****   asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
  64              		.loc 2 13 0
  65              	#APP
  66              	@ 13 "irq.c" 1
  67 001c 00000FE1 		 mrs  r0, cpsr
  68              	@ 0 "" 2
  69              	.LVL1:
  14:irq.c         ****   return retval;
  15:irq.c         **** }
  70              		.loc 2 15 0
  71 0020 1EFF2FE1 		bx	lr
  72              		.cfi_endproc
  73              	.LFE8:
  74              		.fnend
  76              		.align	2
  78              	asm_set_cpsr:
  79              		.fnstart
  80              	.LFB9:
  16:irq.c         **** 
  17:irq.c         **** static inline void asm_set_cpsr(unsigned val)
  18:irq.c         **** {
  81              		.loc 2 18 0
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 0
  85              		@ frame_needed = 0, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87              	.LVL2:
  19:irq.c         ****   asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
  88              		.loc 2 19 0
  89              	#APP
  90              	@ 19 "irq.c" 1
  91 0024 00F029E1 		 msr  cpsr, r0
  92              	@ 0 "" 2
  20:irq.c         **** }
  93              		.loc 2 20 0
  94 0028 1EFF2FE1 		bx	lr
  95              		.cfi_endproc
  96              	.LFE9:
  97              		.fnend
  99              		.align	2
 100              		.global	i2c_read_bytes_isr
 102              	i2c_read_bytes_isr:
 103              		.fnstart
 104              	.LFB18:
 105              		.file 3 "i2c.c"
   1:i2c.c         **** /*
   2:i2c.c         ****  * i2c.c
   3:i2c.c         ****  *
   4:i2c.c         ****  *  Created on: Mar 21, 2013
   5:i2c.c         ****  *      Author: telmo
   6:i2c.c         ****  */
   7:i2c.c         **** #include "lpc2103.h"
   8:i2c.c         **** #include "i2c.h"
   9:i2c.c         **** #include "logger.h"
  10:i2c.c         **** #include "mpu6050.h"
  11:i2c.c         **** 
  12:i2c.c         **** 
  13:i2c.c         **** /**
  14:i2c.c         ****  * I2C 1
  15:i2c.c         ****  *
  16:i2c.c         ****  * I2Cbitfrequency = PCLK / ( I2C1SCLH + I2C1SCLL )
  17:i2c.c         ****  * 0 < I2Cbitfrequency < 400kHz
  18:i2c.c         ****  * I2C1SCLL >= 4, I2C1SCLH >=4
  19:i2c.c         ****  * pclk=15MHz or pclk=14.7456MHz, depending on previous configuration
  20:i2c.c         ****  *
  21:i2c.c         ****  * MPU Address: b1101000W
  22:i2c.c         ****  * W bit 0 => write on the mpu registers
  23:i2c.c         ****  * I2C Addr + Reg Addr + Data
  24:i2c.c         ****  * I2C Addr + Reg Addr + Data + Data for Addr+1, etc
  25:i2c.c         ****  * W bit 1 => read
  26:i2c.c         ****  */
  27:i2c.c         **** void i2c_init(void){
  28:i2c.c         **** 
  29:i2c.c         **** 	log_string_i2c(">> i2c_init\n");
  30:i2c.c         **** 
  31:i2c.c         **** 	// Set the pin function
  32:i2c.c         **** 	PINSEL1 |= 0x1 << 2; // SCL1
  33:i2c.c         **** 	PINSEL1 |= 0x1 << 4; // SDA1
  34:i2c.c         **** 
  35:i2c.c         **** 	I2C1CONCLR = 0x6C; // clear all flags
  36:i2c.c         **** 	I2C1CONSET |= 0x1 << 6; // enable i2c1
  37:i2c.c         **** 	I2C1SCLH = 19; // Set the bit rate:
  38:i2c.c         **** 	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
  39:i2c.c         **** 
  40:i2c.c         **** 	// Enable the interrupts
  41:i2c.c         **** 	VICVectCntl0 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
  42:i2c.c         **** 	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
  43:i2c.c         **** 
  44:i2c.c         **** 	log_string_i2c("<< i2c_init\n");
  45:i2c.c         **** }
  46:i2c.c         **** 
  47:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
  48:i2c.c         **** 	log_string_i2c("read_byte\n");
  49:i2c.c         **** 
  50:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
  51:i2c.c         **** 
  52:i2c.c         **** 	log_string_i2c("read_byte..returning\n");
  53:i2c.c         **** 	return i;
  54:i2c.c         **** }
  55:i2c.c         **** 
  56:i2c.c         **** int i2c_read_bytes(char reg_addr, char length, char* data) {
  57:i2c.c         **** 	log_string_i2c(">> read_bytes\n");
  58:i2c.c         **** 
  59:i2c.c         **** 	buff_size = length;
  60:i2c.c         **** 	buff_pos = 0;
  61:i2c.c         **** 	ra_buff = reg_addr;
  62:i2c.c         **** 	c_buff = data;
  63:i2c.c         **** 
  64:i2c.c         **** 	busy = 1;
  65:i2c.c         **** 
  66:i2c.c         **** 	//Setting the interrupt handler location for write byte
  67:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_read_bytes_isr;
  68:i2c.c         **** 	// Send Start bit
  69:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
  70:i2c.c         **** 
  71:i2c.c         **** 	log_string_i2c("waiting\n");
  72:i2c.c         **** 
  73:i2c.c         **** 	while (busy); // busy wait for read process
  74:i2c.c         **** 
  75:i2c.c         **** 	log_string_i2c("<< read_bytes\n");
  76:i2c.c         **** 	return 1;
  77:i2c.c         **** }
  78:i2c.c         **** 
  79:i2c.c         **** /**
  80:i2c.c         ****  * i2c interrupt handler
  81:i2c.c         ****  */
  82:i2c.c         **** void i2c_read_bytes_isr(void) {
 106              		.loc 3 82 0
 107              		.cfi_startproc
 108              		@ Interrupt Service Routine.
 109              		@ args = 0, pretend = 0, frame = 0
 110              		@ frame_needed = 0, uses_anonymous_args = 0
 111              		@ link register save eliminated.
 112              	.LVL3:
 113 002c 0F102DE9 		stmfd	sp!, {r0, r1, r2, r3, ip}
 114              		.save {r0, r1, r2, r3, ip}
 115              	.LCFI0:
 116              		.cfi_def_cfa_offset 20
  83:i2c.c         **** 	log_string_i2c(">> read_bytes_isr\n");
  84:i2c.c         **** 	int temp = 0;
  85:i2c.c         **** 	temp = I2C1STAT;
 117              		.loc 3 85 0
 118 0030 40319FE5 		ldr	r3, .L23
 119              		.cfi_offset 12, -4
 120              		.cfi_offset 3, -8
 121              		.cfi_offset 2, -12
 122              		.cfi_offset 1, -16
 123              		.cfi_offset 0, -20
 124 0034 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 125 0038 FF2002E2 		and	r2, r2, #255
 126              	.LVL4:
  86:i2c.c         **** 
  87:i2c.c         **** 	switch (temp) {
 127              		.loc 3 87 0
 128 003c 280052E3 		cmp	r2, #40
 129 0040 1B00000A 		beq	.L12
 130 0044 0600008A 		bhi	.L16
 131 0048 100052E3 		cmp	r2, #16
 132 004c 0F00000A 		beq	.L10
 133 0050 180052E3 		cmp	r2, #24
 134 0054 1200000A 		beq	.L11
 135 0058 080052E3 		cmp	r2, #8
 136 005c 4000001A 		bne	.L8
 137 0060 060000EA 		b	.L21
 138              	.L16:
 139 0064 500052E3 		cmp	r2, #80
 140 0068 1800000A 		beq	.L14
 141 006c 580052E3 		cmp	r2, #88
 142 0070 2A00000A 		beq	.L15
 143 0074 400052E3 		cmp	r2, #64
 144 0078 3900001A 		bne	.L8
 145 007c 0F0000EA 		b	.L22
 146              	.L21:
  88:i2c.c         **** 	case TW_START: // A START condition has been transmitted.
  89:i2c.c         **** 		log_string_i2c("TW_START\n");
  90:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
 147              		.loc 3 90 0
 148 0080 2F20E0E3 		mvn	r2, #47
 149              	.LVL5:
 150 0084 0820C3E5 		strb	r2, [r3, #8]
  91:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 151              		.loc 3 91 0
 152 0088 582082E2 		add	r2, r2, #88
 153 008c 020000EA 		b	.L19
 154              	.LVL6:
 155              	.L10:
  92:i2c.c         **** 		break;
  93:i2c.c         **** 	case TW_REP_START: // A repeated START	condition has been transmitted.
  94:i2c.c         **** 		log_string_i2c("TW_REP_START\n");
  95:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_READ; // Slave address + Read
 156              		.loc 3 95 0
 157 0090 2E20E0E3 		mvn	r2, #46
 158              	.LVL7:
 159 0094 0820C3E5 		strb	r2, [r3, #8]
  96:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 160              		.loc 3 96 0
 161 0098 572082E2 		add	r2, r2, #87
 162              	.L19:
 163 009c 1820C3E5 		strb	r2, [r3, #24]
  97:i2c.c         **** 		break;
 164              		.loc 3 97 0
 165 00a0 2F0000EA 		b	.L8
 166              	.LVL8:
 167              	.L11:
  98:i2c.c         **** 	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
  99:i2c.c         **** 		log_string_i2c("TW_MT_SLA_ACK\n");
 100:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 168              		.loc 3 100 0
 169 00a4 D0209FE5 		ldr	r2, .L23+4
 170              	.LVL9:
 171 00a8 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 172 00ac 0820C3E5 		strb	r2, [r3, #8]
 173 00b0 110000EA 		b	.L20
 174              	.LVL10:
 175              	.L12:
 101:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 102:i2c.c         **** 		break;
 103:i2c.c         **** 	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
 104:i2c.c         **** 		log_string_i2c("TW_MT_SLA_NACK\n");
 105:i2c.c         **** 		break;
 106:i2c.c         **** 	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
 107:i2c.c         **** 		log_string_i2c("TW_MT_DATA_ACK\n");
 108:i2c.c         **** 		I2C1CONSET = 0x20; // Transmit start condition
 176              		.loc 3 108 0
 177 00b4 2020A0E3 		mov	r2, #32
 178              	.LVL11:
 179 00b8 0020C3E5 		strb	r2, [r3, #0]
 180 00bc 0E0000EA 		b	.L20
 181              	.LVL12:
 182              	.L22:
 109:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 110:i2c.c         **** 		break;
 111:i2c.c         **** 	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
 112:i2c.c         **** 		log_string_i2c("TW_MT_DATA_NACK\n");
 113:i2c.c         **** 		break;
 114:i2c.c         **** 	case TW_MT_ARB_LOST: // Arbitration lost in SLA+R/W or Data bytes.
 115:i2c.c         **** 		log_string_i2c("TW_MT_ARB_LOST\n");
 116:i2c.c         **** 		break;
 117:i2c.c         **** 
 118:i2c.c         **** 	case TW_MR_SLA_ACK: // SLA+R has been transmitted; ACK has been received.
 119:i2c.c         **** 		log_string_i2c("TW_MR_SLA_ACK\n");
 120:i2c.c         **** 		I2C1CONSET = 0x04; // Transmit ACK on data receives
 183              		.loc 3 120 0
 184 00c0 0420A0E3 		mov	r2, #4
 185              	.LVL13:
 186 00c4 0020C3E5 		strb	r2, [r3, #0]
 121:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 187              		.loc 3 121 0
 188 00c8 022082E0 		add	r2, r2, r2
 189 00cc F2FFFFEA 		b	.L19
 190              	.LVL14:
 191              	.L14:
 122:i2c.c         **** 		break;
 123:i2c.c         **** 	case TW_MR_SLA_NACK: // SLA+R has been transmitted; NOT ACK or has been received.
 124:i2c.c         **** 		log_string_i2c("TW_MR_SLA_NACK\n");
 125:i2c.c         **** 		break;
 126:i2c.c         **** 	case TW_MR_DATA_ACK: // Data byte has been received; ACK has been returned.
 127:i2c.c         **** 		log_string_i2c("TW_MR_DATA_ACK\n");
 128:i2c.c         **** 		log_string_i2c("pos: ");
 129:i2c.c         **** 		log_int_i2c(buff_pos);
 130:i2c.c         **** 		log_string_i2c("\n");
 131:i2c.c         **** 		if ((buff_pos + 2) < buff_size) {
 192              		.loc 3 131 0
 193 00d0 A4209FE5 		ldr	r2, .L23+4
 194              	.LVL15:
 195 00d4 041092E5 		ldr	r1, [r2, #4]
 196 00d8 080092E5 		ldr	r0, [r2, #8]
 197 00dc 02C081E2 		add	ip, r1, #2
 198 00e0 00005CE1 		cmp	ip, r0
 199 00e4 060000AA 		bge	.L17
 132:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 200              		.loc 3 132 0
 201 00e8 08C0D3E5 		ldrb	ip, [r3, #8]	@ zero_extendqisi2
 202 00ec 0C0092E5 		ldr	r0, [r2, #12]
 203 00f0 01C0C0E7 		strb	ip, [r0, r1]
 204 00f4 011081E2 		add	r1, r1, #1
 205 00f8 041082E5 		str	r1, [r2, #4]
 206              	.L20:
 133:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 207              		.loc 3 133 0
 208 00fc 0820A0E3 		mov	r2, #8
 209 0100 E5FFFFEA 		b	.L19
 210              	.L17:
 134:i2c.c         **** 		}
 135:i2c.c         **** 		else {
 136:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 211              		.loc 3 136 0
 212 0104 08C0D3E5 		ldrb	ip, [r3, #8]	@ zero_extendqisi2
 213 0108 0C0092E5 		ldr	r0, [r2, #12]
 214 010c 01C0C0E7 		strb	ip, [r0, r1]
 215 0110 011081E2 		add	r1, r1, #1
 216 0114 041082E5 		str	r1, [r2, #4]
 137:i2c.c         **** 			I2C1CONCLR = 0x0C; // Transmit NACK on next data receive, Clear SI
 217              		.loc 3 137 0
 218 0118 0C20A0E3 		mov	r2, #12
 219 011c DEFFFFEA 		b	.L19
 220              	.LVL16:
 221              	.L15:
 138:i2c.c         **** 		}
 139:i2c.c         **** 		break;
 140:i2c.c         **** 	case TW_MR_DATA_NACK: // Data byte has been received; NOT ACK has been returned.
 141:i2c.c         **** 		log_string_i2c("TW_MR_DATA_NACK\n");
 142:i2c.c         **** 		log_string_i2c("pos: ");
 143:i2c.c         **** 		log_int_i2c(buff_pos);
 144:i2c.c         **** 		log_string_i2c("\n");
 145:i2c.c         **** 		if (buff_pos < buff_size) {
 222              		.loc 3 145 0
 223 0120 54209FE5 		ldr	r2, .L23+4
 224              	.LVL17:
 225 0124 041092E5 		ldr	r1, [r2, #4]
 226 0128 080092E5 		ldr	r0, [r2, #8]
 227 012c 000051E1 		cmp	r1, r0
 146:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 228              		.loc 3 146 0
 229 0130 0800D3B5 		ldrltb	r0, [r3, #8]	@ zero_extendqisi2
 230 0134 0C3092B5 		ldrlt	r3, [r2, #12]
 231 0138 0100C3B7 		strltb	r0, [r3, r1]
 147:i2c.c         **** 		}
 148:i2c.c         **** 		I2C1CONSET = 0x10; // Transmit stop condition
 232              		.loc 3 148 0
 233 013c 34309FE5 		ldr	r3, .L23
 146:i2c.c         **** 			c_buff[buff_pos++] = I2C1DAT;
 234              		.loc 3 146 0
 235 0140 011081B2 		addlt	r1, r1, #1
 236 0144 041082B5 		strlt	r1, [r2, #4]
 237              		.loc 3 148 0
 238 0148 1020A0E3 		mov	r2, #16
 239 014c 0020C3E5 		strb	r2, [r3, #0]
 149:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 240              		.loc 3 149 0
 241 0150 0820A0E3 		mov	r2, #8
 242 0154 1820C3E5 		strb	r2, [r3, #24]
 150:i2c.c         **** 		busy = 0; // data ready to be returned
 243              		.loc 3 150 0
 244 0158 1C309FE5 		ldr	r3, .L23+4
 245 015c 0020A0E3 		mov	r2, #0
 246 0160 102083E5 		str	r2, [r3, #16]
 247              	.L8:
 151:i2c.c         **** 		break;
 152:i2c.c         **** 
 153:i2c.c         **** 	default:
 154:i2c.c         **** 		log_string_i2c("[i2c] default\n");
 155:i2c.c         **** 		break;
 156:i2c.c         **** 	}
 157:i2c.c         **** 
 158:i2c.c         **** 	VICVectAddr = 0;
 248              		.loc 3 158 0
 249 0164 0020A0E3 		mov	r2, #0
 250 0168 0030E0E3 		mvn	r3, #0
 251 016c CF2F03E5 		str	r2, [r3, #-4047]
 159:i2c.c         **** }
 252              		.loc 3 159 0
 253 0170 0F10BDE8 		ldmfd	sp!, {r0, r1, r2, r3, ip}
 254 0174 04F05EE2 		subs	pc, lr, #4
 255              	.L24:
 256              		.align	2
 257              	.L23:
 258 0178 00C005E0 		.word	-536494080
 259 017c 00000000 		.word	.LANCHOR0
 260              		.cfi_endproc
 261              	.LFE18:
 262              		.fnend
 264              		.align	2
 265              		.global	i2c_write_byte_isr
 267              	i2c_write_byte_isr:
 268              		.fnstart
 269              	.LFB21:
 160:i2c.c         **** 
 161:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 162:i2c.c         **** 	//      010 value to write
 163:i2c.c         **** 	// 76543210 bit numbers
 164:i2c.c         **** 	//    xxx   args: bitStart=4, length=3
 165:i2c.c         **** 	// 00011100 mask byte
 166:i2c.c         **** 	// 10101111 original value (sample)
 167:i2c.c         **** 	// 10100011 original & ~mask
 168:i2c.c         **** 	// 10101011 masked | value
 169:i2c.c         **** 
 170:i2c.c         **** 	char c;
 171:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 172:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 173:i2c.c         **** 	data <<= (bit - length + 1); // shift data into correct position
 174:i2c.c         **** 	data &= mask; // zero all non-important bits in data
 175:i2c.c         **** 	c &= ~(mask); // zero all important bits in existing byte
 176:i2c.c         **** 	c |= data; // combine data with existing byte
 177:i2c.c         **** 
 178:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 179:i2c.c         **** }
 180:i2c.c         **** 
 181:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 182:i2c.c         **** 	log_string_i2c("write_byte\n");
 183:i2c.c         **** 
 184:i2c.c         **** 	buff_size = 1;
 185:i2c.c         **** 	buff_pos = 0;
 186:i2c.c         **** 	ra_buff = reg_addr;
 187:i2c.c         **** 	c_buff = &data;
 188:i2c.c         **** 
 189:i2c.c         **** 	busy = 1;
 190:i2c.c         **** 
 191:i2c.c         **** 	//Setting the interrupt handler location for write byte
 192:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_write_byte_isr;
 193:i2c.c         **** 	// Send Start bit
 194:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 195:i2c.c         **** 
 196:i2c.c         **** 	while (busy); // busy wait for read process
 197:i2c.c         **** 
 198:i2c.c         **** 	log_string_i2c("write_byte..returning\n");
 199:i2c.c         **** 	return 1;
 200:i2c.c         **** }
 201:i2c.c         **** 
 202:i2c.c         **** /**
 203:i2c.c         ****  * i2c interrupt handler
 204:i2c.c         ****  */
 205:i2c.c         **** void i2c_write_byte_isr(void) {
 270              		.loc 3 205 0
 271              		.cfi_startproc
 272              		@ Interrupt Service Routine.
 273              		@ args = 0, pretend = 0, frame = 0
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              		@ link register save eliminated.
 276              	.LVL18:
 277 0180 0F002DE9 		stmfd	sp!, {r0, r1, r2, r3}
 278              		.save {r0, r1, r2, r3}
 279              	.LCFI1:
 280              		.cfi_def_cfa_offset 16
 206:i2c.c         **** 	log_string_i2c(">> i2c_write_byte_isr\n");
 207:i2c.c         **** 	int temp = 0;
 208:i2c.c         **** 	temp = I2C1STAT;
 281              		.loc 3 208 0
 282 0184 D8309FE5 		ldr	r3, .L37
 283              		.cfi_offset 3, -4
 284              		.cfi_offset 2, -8
 285              		.cfi_offset 1, -12
 286              		.cfi_offset 0, -16
 287 0188 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 288 018c FF2002E2 		and	r2, r2, #255
 289              	.LVL19:
 209:i2c.c         **** 
 210:i2c.c         **** 	switch (temp) {
 290              		.loc 3 210 0
 291 0190 180052E3 		cmp	r2, #24
 292 0194 0C00000A 		beq	.L28
 293 0198 0200008A 		bhi	.L31
 294 019c 080052E3 		cmp	r2, #8
 295 01a0 2A00001A 		bne	.L26
 296 01a4 040000EA 		b	.L35
 297              	.L31:
 298 01a8 280052E3 		cmp	r2, #40
 299 01ac 0C00000A 		beq	.L29
 300 01b0 300052E3 		cmp	r2, #48
 301 01b4 2500001A 		bne	.L26
 302 01b8 1C0000EA 		b	.L36
 303              	.L35:
 211:i2c.c         **** 	case TW_START: // A START condition has been transmitted.
 212:i2c.c         **** 		log_string_i2c("TW_START\n");
 213:i2c.c         **** 		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
 304              		.loc 3 213 0
 305 01bc 2F20E0E3 		mvn	r2, #47
 306              	.LVL20:
 307 01c0 0820C3E5 		strb	r2, [r3, #8]
 214:i2c.c         **** 		I2C1CONCLR = 0x28; // Clear SI and STA flag
 308              		.loc 3 214 0
 309 01c4 582082E2 		add	r2, r2, #88
 310 01c8 030000EA 		b	.L33
 311              	.LVL21:
 312              	.L28:
 215:i2c.c         **** 		break;
 216:i2c.c         **** 	case TW_REP_START: // A repeated START	condition has been transmitted.
 217:i2c.c         **** 		log_string_i2c("TW_REP_START\n");
 218:i2c.c         **** 		break;
 219:i2c.c         **** 	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
 220:i2c.c         **** 		log_string_i2c("TW_MT_SLA_ACK\n");
 221:i2c.c         **** 		I2C1DAT = ra_buff; // Register address to be written
 313              		.loc 3 221 0
 314 01cc 94209FE5 		ldr	r2, .L37+4
 315              	.LVL22:
 316 01d0 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 317 01d4 0820C3E5 		strb	r2, [r3, #8]
 318              	.L34:
 222:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 319              		.loc 3 222 0
 320 01d8 0820A0E3 		mov	r2, #8
 321              	.L33:
 322 01dc 1820C3E5 		strb	r2, [r3, #24]
 223:i2c.c         **** 		break;
 323              		.loc 3 223 0
 324 01e0 1A0000EA 		b	.L26
 325              	.LVL23:
 326              	.L29:
 224:i2c.c         **** 	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
 225:i2c.c         **** 		log_string_i2c("TW_MT_SLA_NACK\n");
 226:i2c.c         **** 		break;
 227:i2c.c         **** 	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
 228:i2c.c         **** 		log_string_i2c("TW_MT_DATA_ACK\n");
 229:i2c.c         **** 		if (buff_pos < buff_size) {
 327              		.loc 3 229 0
 328 01e4 7C209FE5 		ldr	r2, .L37+4
 329              	.LVL24:
 330 01e8 041092E5 		ldr	r1, [r2, #4]
 331 01ec 080092E5 		ldr	r0, [r2, #8]
 332 01f0 000051E1 		cmp	r1, r0
 333 01f4 050000AA 		bge	.L32
 230:i2c.c         **** 			I2C1DAT = c_buff[buff_pos++]; // Send data
 334              		.loc 3 230 0
 335 01f8 0C0092E5 		ldr	r0, [r2, #12]
 336 01fc 0100D0E7 		ldrb	r0, [r0, r1]	@ zero_extendqisi2
 337 0200 011081E2 		add	r1, r1, #1
 338 0204 0800C3E5 		strb	r0, [r3, #8]
 339 0208 041082E5 		str	r1, [r2, #4]
 340 020c F1FFFFEA 		b	.L34
 341              	.L32:
 231:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 232:i2c.c         **** 		} else {
 233:i2c.c         **** 			I2C1CONSET |= 0x01 << 4; // Transmit stop condition
 342              		.loc 3 233 0
 343 0210 0010D3E5 		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 344 0214 101081E3 		orr	r1, r1, #16
 345 0218 0010C3E5 		strb	r1, [r3, #0]
 234:i2c.c         **** 			I2C1CONCLR = 0x08; // Clear SI
 346              		.loc 3 234 0
 347 021c 0810A0E3 		mov	r1, #8
 348 0220 1810C3E5 		strb	r1, [r3, #24]
 235:i2c.c         **** 			busy = 0; // done
 349              		.loc 3 235 0
 350 0224 0030A0E3 		mov	r3, #0
 351 0228 103082E5 		str	r3, [r2, #16]
 352 022c 070000EA 		b	.L26
 353              	.LVL25:
 354              	.L36:
 236:i2c.c         **** 		}
 237:i2c.c         **** 		break;
 238:i2c.c         **** 	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
 239:i2c.c         **** 		log_string_i2c("TW_MT_DATA_NACK\n");
 240:i2c.c         **** 		I2C1CONSET |= 0x01 << 4; // Transmit stop condition
 355              		.loc 3 240 0
 356 0230 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 357              	.LVL26:
 358 0234 102082E3 		orr	r2, r2, #16
 359 0238 0020C3E5 		strb	r2, [r3, #0]
 241:i2c.c         **** 		I2C1CONCLR = 0x08; // Clear SI
 360              		.loc 3 241 0
 361 023c 0820A0E3 		mov	r2, #8
 362 0240 1820C3E5 		strb	r2, [r3, #24]
 242:i2c.c         **** 		busy = 0; // done
 363              		.loc 3 242 0
 364 0244 1C309FE5 		ldr	r3, .L37+4
 365 0248 0020A0E3 		mov	r2, #0
 366 024c 102083E5 		str	r2, [r3, #16]
 367              	.L26:
 243:i2c.c         **** 		break;
 244:i2c.c         **** 	case TW_MT_ARB_LOST: // Arbitration lost in SLA+R/W or Data bytes.
 245:i2c.c         **** 		log_string_i2c("TW_MT_ARB_LOST\n");
 246:i2c.c         **** 		break;
 247:i2c.c         **** 
 248:i2c.c         **** 	default:
 249:i2c.c         **** 		log_string_i2c("default\n");
 250:i2c.c         **** 		break;
 251:i2c.c         **** 	}
 252:i2c.c         **** 
 253:i2c.c         **** 	VICVectAddr = 0;
 368              		.loc 3 253 0
 369 0250 0020A0E3 		mov	r2, #0
 370 0254 0030E0E3 		mvn	r3, #0
 371 0258 CF2F03E5 		str	r2, [r3, #-4047]
 254:i2c.c         **** }
 372              		.loc 3 254 0
 373 025c 0F00BDE8 		ldmfd	sp!, {r0, r1, r2, r3}
 374 0260 04F05EE2 		subs	pc, lr, #4
 375              	.L38:
 376              		.align	2
 377              	.L37:
 378 0264 00C005E0 		.word	-536494080
 379 0268 00000000 		.word	.LANCHOR0
 380              		.cfi_endproc
 381              	.LFE21:
 382              		.fnend
 384              		.align	2
 385              		.global	imu_data_ready
 387              	imu_data_ready:
 388              		.fnstart
 389              	.LFB53:
 390              		.file 4 "bellator_low_level.c"
   1:bellator_low_level.c **** /**
   2:bellator_low_level.c ****  *
   3:bellator_low_level.c ****  *
   4:bellator_low_level.c ****  *
   5:bellator_low_level.c ****  */
   6:bellator_low_level.c **** /* global defines */
   7:bellator_low_level.c **** #define CRYSTAL12MHz
   8:bellator_low_level.c **** //#define CRYSTAL14745600Hz
   9:bellator_low_level.c **** #define CMD_BUFF_SIZE 32 // has to be a power of two
  10:bellator_low_level.c **** #define IMU_BUFF_SIZE 256 // has to be a power of two
  11:bellator_low_level.c **** 
  12:bellator_low_level.c **** //#define ERROR
  13:bellator_low_level.c **** //#define WARNING
  14:bellator_low_level.c **** //#define DEBUG
  15:bellator_low_level.c **** //#define DEBUG_I2C
  16:bellator_low_level.c **** //#define DEBUG_MPU
  17:bellator_low_level.c **** 
  18:bellator_low_level.c **** /* includes */
  19:bellator_low_level.c **** #include "lpc2103.h"
  20:bellator_low_level.c **** #include "logger.h"
  21:bellator_low_level.c **** #include "logger.c"
  22:bellator_low_level.c **** #include "irq.h"
  23:bellator_low_level.c **** #include "irq.c"
  24:bellator_low_level.c **** #include "i2c.h"
  25:bellator_low_level.c **** #include "i2c.c"
  26:bellator_low_level.c **** #include "protocol.h"
  27:bellator_low_level.c **** #include "mpu6050.h"
  28:bellator_low_level.c **** #include "mpu6050.c"
  29:bellator_low_level.c **** 
  30:bellator_low_level.c **** /* interruptions */
  31:bellator_low_level.c **** void __attribute__ ((interrupt("FIQ"))) encoder_pulse_in_isr(void);
  32:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) protocol_in(void);
  33:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) imu_data_ready(void);
  34:bellator_low_level.c **** void __attribute__ ((interrupt("IRQ"))) error(void);
  35:bellator_low_level.c **** 
  36:bellator_low_level.c **** /* init functions */
  37:bellator_low_level.c **** inline void PLL_Init(void);
  38:bellator_low_level.c **** inline void MAM_Init(void);
  39:bellator_low_level.c **** inline void APB_Init(void);
  40:bellator_low_level.c **** 
  41:bellator_low_level.c **** inline void pulses_in_init(void);
  42:bellator_low_level.c **** inline void imu_init(void);
  43:bellator_low_level.c **** inline void adc_init(void);
  44:bellator_low_level.c **** inline void pwm_out_init(void);
  45:bellator_low_level.c **** static inline void protocol_init(void);
  46:bellator_low_level.c **** 
  47:bellator_low_level.c **** /* getters and setters */
  48:bellator_low_level.c **** int get_ir_sensor_data(unsigned short i);
  49:bellator_low_level.c **** int get_encoder_count(unsigned short i);
  50:bellator_low_level.c **** void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel);
  51:bellator_low_level.c **** 
  52:bellator_low_level.c **** /* auxiliary functions */
  53:bellator_low_level.c **** static void protocol_out_cmd(void);
  54:bellator_low_level.c **** static void protocol_out_char(char c);
  55:bellator_low_level.c **** 
  56:bellator_low_level.c **** /* data structs defenitions */
  57:bellator_low_level.c **** struct cmd_buff {
  58:bellator_low_level.c ****   unsigned int i;
  59:bellator_low_level.c ****   char buff [CMD_BUFF_SIZE];      // Circular Buffer
  60:bellator_low_level.c **** };
  61:bellator_low_level.c **** 
  62:bellator_low_level.c **** struct imu_data {
  63:bellator_low_level.c **** 	char ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l;
  64:bellator_low_level.c **** 	unsigned short timestamp;
  65:bellator_low_level.c **** };
  66:bellator_low_level.c **** 
  67:bellator_low_level.c **** /* global variables */
  68:bellator_low_level.c **** static struct cmd_buff cmd_out = { 0, };
  69:bellator_low_level.c **** static struct cmd_buff cmd_in = { 0, };
  70:bellator_low_level.c **** static unsigned int encoder_count[2] = { 0, 0};
  71:bellator_low_level.c **** static unsigned int sent_encoder_count[2] = { 0, 0};
  72:bellator_low_level.c **** static unsigned volatile char imu_data_available = 0;
  73:bellator_low_level.c **** static struct imu_data imu_data_buff[IMU_BUFF_SIZE]; // Circular Buffer
  74:bellator_low_level.c **** static unsigned short imu_data_in_pos = 0;
  75:bellator_low_level.c **** static unsigned short imu_data_out_pos = 0;
  76:bellator_low_level.c **** static unsigned short timestamp = 0;
  77:bellator_low_level.c **** 
  78:bellator_low_level.c **** /**
  79:bellator_low_level.c ****  * Entry point
  80:bellator_low_level.c ****  */
  81:bellator_low_level.c **** int main(void){
  82:bellator_low_level.c **** 
  83:bellator_low_level.c **** 	PLL_Init(); // Turn on PLL clock
  84:bellator_low_level.c **** 	MAM_Init(); // Turn on MAM pre-fetcher
  85:bellator_low_level.c **** 	APB_Init(); // Turn on the peripheral devices clock divider
  86:bellator_low_level.c **** 
  87:bellator_low_level.c **** 	logger_init(); // uart0
  88:bellator_low_level.c **** 	log_string_debug("iniciando\n");
  89:bellator_low_level.c **** 
  90:bellator_low_level.c **** 	enableIRQ(); // Enable interruptions
  91:bellator_low_level.c **** 
  92:bellator_low_level.c **** 	pulses_in_init(); // start counting pulses from the encoder	| Timer 2, FIQ, eint0, FIQ
  93:bellator_low_level.c **** 	imu_init(); // start the IMU									| i2c1 Priority 0, eint2 Priority 1
  94:bellator_low_level.c **** 	adc_init(); // start reading the IR sensor signals			| Burst mode, no interruption
  95:bellator_low_level.c **** 	pwm_out_init(); // start pwm for the H bridges				| Timer 0 and Timer 1 operating in PWM mode, no 
  96:bellator_low_level.c **** 	protocol_init(); // start the communication protocol			| uart1, Priority 2
  97:bellator_low_level.c **** 
  98:bellator_low_level.c **** 	enableFIQ();
  99:bellator_low_level.c **** 
 100:bellator_low_level.c **** 	VICDefVectAddr = (unsigned int) &error;
 101:bellator_low_level.c **** 
 102:bellator_low_level.c **** 	//set_wheel_pwm(RIGHT_WHEEL,0x7F);
 103:bellator_low_level.c **** 	//set_wheel_pwm(LEFT_WHEEL,0x7F);
 104:bellator_low_level.c **** 
 105:bellator_low_level.c **** 	// imu_data_in_pos -> aponta para o ultimo dado valido
 106:bellator_low_level.c **** 	// imu_data_out_pos -> aponta para o ultimo dado enviado
 107:bellator_low_level.c **** 	while(1){
 108:bellator_low_level.c **** 		if(imu_data_available) {
 109:bellator_low_level.c **** 			char source;
 110:bellator_low_level.c **** 			// find out where the interruption came from
 111:bellator_low_level.c **** 			mpu_clear_interrupt(&source);
 112:bellator_low_level.c **** 
 113:bellator_low_level.c **** 			log_string_debug("src:");
 114:bellator_low_level.c **** 			log_byte_debug(source);
 115:bellator_low_level.c **** 			log_string_debug("\n");
 116:bellator_low_level.c **** 
 117:bellator_low_level.c **** 			if (source & (0x1 << MPU6050_INTERRUPT_DATA_RDY_BIT)) {
 118:bellator_low_level.c **** 				log_string_debug("dataready: ");
 119:bellator_low_level.c **** 
 120:bellator_low_level.c **** 				// find out how many entries are in the fifo
 121:bellator_low_level.c **** 				int size;
 122:bellator_low_level.c **** 				mpu_get_FIFO_size(&size);
 123:bellator_low_level.c **** 
 124:bellator_low_level.c **** 				log_int_debug(size);
 125:bellator_low_level.c **** 				log_string_debug(" bytes\n");
 126:bellator_low_level.c **** 
 127:bellator_low_level.c **** 				// try to clear the fifo before an overflow occurs
 128:bellator_low_level.c **** 				if (size > 840 || source & (0x1 << MPU6050_INTERRUPT_FIFO_OFLOW_BIT)) {
 129:bellator_low_level.c **** 					log_string_warning("MPU overflow\n");
 130:bellator_low_level.c **** 					mpu_set_FIFO_enabled(0);
 131:bellator_low_level.c **** 					mpu_reset_FIFO();
 132:bellator_low_level.c **** 					mpu_set_FIFO_enabled(1);
 133:bellator_low_level.c **** 					mpu_get_FIFO_size(&size);
 134:bellator_low_level.c **** 				}
 135:bellator_low_level.c **** 
 136:bellator_low_level.c **** 				while (size >= 12) {
 137:bellator_low_level.c **** 					size -= 12;
 138:bellator_low_level.c **** 
 139:bellator_low_level.c **** 					// next position in buffer
 140:bellator_low_level.c **** 					short imu_data_in_pos_tmp = (imu_data_in_pos + 1) % IMU_BUFF_SIZE;
 141:bellator_low_level.c **** 
 142:bellator_low_level.c **** 					// check for overflow
 143:bellator_low_level.c **** 					if (imu_data_in_pos_tmp == imu_data_out_pos) {
 144:bellator_low_level.c **** 						log_string_warning("LPC overflow\n");
 145:bellator_low_level.c **** 						// the oldest data will be overwritten
 146:bellator_low_level.c **** 						imu_data_out_pos = ++imu_data_out_pos % IMU_BUFF_SIZE;
 147:bellator_low_level.c **** 					}
 148:bellator_low_level.c **** 
 149:bellator_low_level.c **** 					// read data and put on local circular buffer
 150:bellator_low_level.c **** 					struct imu_data* data;
 151:bellator_low_level.c **** 					data = &(imu_data_buff[imu_data_in_pos_tmp]);
 152:bellator_low_level.c **** 
 153:bellator_low_level.c **** 					mpu_get_FIFO_motion6(&(data->ax_h), &(data->ax_l), &(data->ay_h), &(data->ay_l), &(data->az_h)
 154:bellator_low_level.c **** 							&(data->gx_h), &(data->gx_l), &(data->gy_h), &(data->gy_l), &(data->gz_h), &(data->gz_l));
 155:bellator_low_level.c **** 					data->timestamp = timestamp++;
 156:bellator_low_level.c **** 
 157:bellator_low_level.c **** //					protocol_out_char(0xFF);
 158:bellator_low_level.c **** //					protocol_out_char(0xFF);
 159:bellator_low_level.c **** //					protocol_out_char(data->ax_h);
 160:bellator_low_level.c **** //					protocol_out_char(data->ax_l);
 161:bellator_low_level.c **** //					protocol_out_char(data->ay_h);
 162:bellator_low_level.c **** //					protocol_out_char(data->ay_l);
 163:bellator_low_level.c **** //					protocol_out_char(data->az_h);
 164:bellator_low_level.c **** //					protocol_out_char(data->az_l);
 165:bellator_low_level.c **** //					protocol_out_char(data->gx_h);
 166:bellator_low_level.c **** //					protocol_out_char(data->gx_l);
 167:bellator_low_level.c **** //					protocol_out_char(data->gy_h);
 168:bellator_low_level.c **** //					protocol_out_char(data->gy_l);
 169:bellator_low_level.c **** //					protocol_out_char(data->gz_h);
 170:bellator_low_level.c **** //					protocol_out_char(data->gz_l);
 171:bellator_low_level.c **** //					protocol_out_char(0xFF);
 172:bellator_low_level.c **** //					protocol_out_char(0xFF);
 173:bellator_low_level.c **** 
 174:bellator_low_level.c **** 					imu_data_in_pos = imu_data_in_pos_tmp;
 175:bellator_low_level.c **** 				}
 176:bellator_low_level.c **** 			}
 177:bellator_low_level.c **** 
 178:bellator_low_level.c **** 			imu_data_available = 0;
 179:bellator_low_level.c **** 		}
 180:bellator_low_level.c **** 	}
 181:bellator_low_level.c **** 	return 0;
 182:bellator_low_level.c **** }
 183:bellator_low_level.c **** 
 184:bellator_low_level.c **** /**
 185:bellator_low_level.c ****  * Sets the processor clock
 186:bellator_low_level.c ****  *
 187:bellator_low_level.c ****  * Fosc = External oscilator =	12MHz | 14.7456MHz
 188:bellator_low_level.c ****  * CCLK = PLL Clock output =	60MHz | 58.9824MHz  (desired system clock)
 189:bellator_low_level.c ****  * MSEL = Clock multiplier =	4	  | 3			(MSEL = CCLK/Fosc -1)
 190:bellator_low_level.c ****  * PSEL = Clock divider = 		1	  | 1			(P | 156MHz < Fcco < 320MHz, Fcco = CCLK * 2 * P)
 191:bellator_low_level.c ****  * 													(P=1 -> PSEL=00, P=2 -> PSEL=01, P=4 -> PSEL=10, P=8 -> PSEL=11)
 192:bellator_low_level.c ****  */
 193:bellator_low_level.c **** inline void PLL_Init(void){
 194:bellator_low_level.c **** 
 195:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 196:bellator_low_level.c **** 	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 197:bellator_low_level.c **** #endif
 198:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 199:bellator_low_level.c **** 	PLLCFG=0x23;                // 14.7456MHz crystal -> 58.9824MHz
 200:bellator_low_level.c **** #endif
 201:bellator_low_level.c **** 
 202:bellator_low_level.c **** 	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 203:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 204:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 205:bellator_low_level.c **** 	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 206:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 207:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 208:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 209:bellator_low_level.c **** }
 210:bellator_low_level.c **** 
 211:bellator_low_level.c **** /**
 212:bellator_low_level.c ****  * Starts the Memory Acceleration Module
 213:bellator_low_level.c ****  * System clock
 214:bellator_low_level.c ****  * < 20MHz         -> MAMTIM = 1 CCLK
 215:bellator_low_level.c ****  * 20MHz to 40MHz  -> MAMTIM = 2 CCLK
 216:bellator_low_level.c ****  * 40MHz to 60MHz  -> MAMTIM = 3 CCLK
 217:bellator_low_level.c ****  * > 60MHz         -> MAMTIM = 4 CCLK
 218:bellator_low_level.c ****  */
 219:bellator_low_level.c **** inline void MAM_Init(void){
 220:bellator_low_level.c **** 
 221:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 222:bellator_low_level.c **** 	MAMTIM = 4; // 4 clock fetches
 223:bellator_low_level.c **** #endif
 224:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 225:bellator_low_level.c **** 	MAMTIM = 3; // 3 clock fetches
 226:bellator_low_level.c **** #endif
 227:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 228:bellator_low_level.c **** }
 229:bellator_low_level.c **** 
 230:bellator_low_level.c **** /**
 231:bellator_low_level.c ****  * Configure the peripheral devices clock divider
 232:bellator_low_level.c ****  */
 233:bellator_low_level.c **** inline void APB_Init(void){
 234:bellator_low_level.c **** 	// peripheral clock = PCLK = CCLK/4
 235:bellator_low_level.c **** 	//APBDIV |= 0x02;
 236:bellator_low_level.c **** 	APBDIV &= ~0x03;
 237:bellator_low_level.c **** }
 238:bellator_low_level.c **** 
 239:bellator_low_level.c **** /**
 240:bellator_low_level.c ****  * Timer 2, capture pins generating FIQs for event counter
 241:bellator_low_level.c ****  * The timer has no function, except for the interrupt generation.
 242:bellator_low_level.c ****  * and EINT0 also generating FIQs for event counter
 243:bellator_low_level.c ****  * CAP20 - Left encoder
 244:bellator_low_level.c ****  * CAP21 - Left encoder
 245:bellator_low_level.c ****  * CAP22 - Right encoder
 246:bellator_low_level.c ****  * EINT0 - Right encoder
 247:bellator_low_level.c ****  */
 248:bellator_low_level.c **** inline void pulses_in_init(void){
 249:bellator_low_level.c **** 
 250:bellator_low_level.c **** 	log_string_debug(">> pulses_in_init\n");
 251:bellator_low_level.c **** 
 252:bellator_low_level.c **** 	// Set the pin function
 253:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 254:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 24; // CAP2.1
 255:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 26; // CAP2.2
 256:bellator_low_level.c **** 	PINSEL1 |= 0x1 << 0;  // EINT0
 257:bellator_low_level.c **** 
 258:bellator_low_level.c **** 	// Timer Setup
 259:bellator_low_level.c **** 	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
 260:bellator_low_level.c **** 	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
 261:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 262:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 263:bellator_low_level.c **** 
 264:bellator_low_level.c **** 	// EINT setup
 265:bellator_low_level.c **** 	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
 266:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
 267:bellator_low_level.c **** 	EXTINT |= 0x1 << 0; // reset EINT0
 268:bellator_low_level.c **** 
 269:bellator_low_level.c **** 	// Enable the interrupts
 270:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 26;// Timer 2 as FIQ
 271:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
 272:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 14;// EINT2 as FIQ
 273:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
 274:bellator_low_level.c **** 
 275:bellator_low_level.c **** 	log_string_debug("<< pulses_in_init\n");
 276:bellator_low_level.c **** }
 277:bellator_low_level.c **** 
 278:bellator_low_level.c **** /**
 279:bellator_low_level.c ****  * Start i2c communication
 280:bellator_low_level.c ****  * Configure MPU
 281:bellator_low_level.c ****  * Setup eint2 with priority 1 for data ready interrupt
 282:bellator_low_level.c ****  */
 283:bellator_low_level.c **** inline void imu_init(void){
 284:bellator_low_level.c **** 
 285:bellator_low_level.c **** 	log_string_debug(">> imu_init\n");
 286:bellator_low_level.c **** 
 287:bellator_low_level.c **** 	// start the communication with the IMU
 288:bellator_low_level.c **** 	i2c_init();
 289:bellator_low_level.c **** 	// configure mpu and start taking samples
 290:bellator_low_level.c **** 	mpu_init();
 291:bellator_low_level.c **** 
 292:bellator_low_level.c **** 	// Configure data ready interrupt
 293:bellator_low_level.c **** 	// Set the pin function
 294:bellator_low_level.c **** 	PINSEL0 |= 0x1 << 30;  // EINT2
 295:bellator_low_level.c **** 
 296:bellator_low_level.c **** 	// EINT setup
 297:bellator_low_level.c **** 	EXTMODE |= 0x1 << 2; // EINT2 is edge sensitive
 298:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 2; // EINT2 is rising edge sensitive
 299:bellator_low_level.c **** 	EXTINT |= 0x1 << 2; // reset EINT2
 300:bellator_low_level.c **** 
 301:bellator_low_level.c **** 	VICVectAddr1 = (unsigned int) &imu_data_ready; //Setting the interrupt handler location
 302:bellator_low_level.c **** 	VICVectCntl1 = 0x30; //Vectored Interrupt slot enabled with source #16 (EINT2)
 303:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 16; //source #16 enabled as FIQ or IRQ
 304:bellator_low_level.c **** 
 305:bellator_low_level.c **** 	log_string_debug("<< imu_init\n");
 306:bellator_low_level.c **** }
 307:bellator_low_level.c **** 
 308:bellator_low_level.c **** /**
 309:bellator_low_level.c ****  * ADC0 Configured in BURST mode
 310:bellator_low_level.c ****  */
 311:bellator_low_level.c **** inline void adc_init(void){
 312:bellator_low_level.c **** 
 313:bellator_low_level.c **** 	log_string_debug(">> adc_init\n");
 314:bellator_low_level.c **** 
 315:bellator_low_level.c **** 	// Set the pin function
 316:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 12; // AD0.0
 317:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 14; // AD0.1
 318:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 16; // AD0.2
 319:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 20; // AD0.3
 320:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 22; // AD0.4
 321:bellator_low_level.c **** 
 322:bellator_low_level.c **** 	// ADC setup
 323:bellator_low_level.c **** 	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
 324:bellator_low_level.c **** 	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
 325:bellator_low_level.c **** 	ADCR |= 0x1F; // Read AD0.0 - AD0.4
 326:bellator_low_level.c **** 	ADCR |= 0x01 << 21; // The ADC is operational
 327:bellator_low_level.c **** 
 328:bellator_low_level.c **** 	log_string_debug("<< adc_init\n");
 329:bellator_low_level.c **** }
 330:bellator_low_level.c **** 
 331:bellator_low_level.c **** /**
 332:bellator_low_level.c ****  * Timer 0,1, 200Hz, at least 76 levels to comply with the old version
 333:bellator_low_level.c ****  * Timer 0 -> left wheel
 334:bellator_low_level.c ****  * Timer 1 -> right wheel
 335:bellator_low_level.c ****  */
 336:bellator_low_level.c **** inline void pwm_out_init(void){
 337:bellator_low_level.c **** 
 338:bellator_low_level.c **** 	log_string_debug(">> pwm_out_init\n");
 339:bellator_low_level.c **** 
 340:bellator_low_level.c **** 	// Set the pin function
 341:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 6;  // MAT0.0
 342:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 10; // MAT0.1
 343:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 24; // MAT1.0
 344:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 26; // MAT1.1
 345:bellator_low_level.c **** 
 346:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 347:bellator_low_level.c **** 	T0PR = 294; // 255 levels for T2TC in 5ms
 348:bellator_low_level.c **** 	T1PR = 294;
 349:bellator_low_level.c **** #endif
 350:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 351:bellator_low_level.c **** 	T0PR = 289; // 255 levels for T2TC in 5ms
 352:bellator_low_level.c **** 	T1PR = 289;
 353:bellator_low_level.c **** #endif
 354:bellator_low_level.c **** 
 355:bellator_low_level.c **** 	T0PC = 0; // Prescale = 0
 356:bellator_low_level.c **** 	T1PC = 0;
 357:bellator_low_level.c **** 	T0TC = 0; // Counter = 0
 358:bellator_low_level.c **** 	T1TC = 0;
 359:bellator_low_level.c **** 
 360:bellator_low_level.c **** 	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
 361:bellator_low_level.c **** 	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
 362:bellator_low_level.c **** 	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
 363:bellator_low_level.c **** 	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
 364:bellator_low_level.c **** 
 365:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
 366:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
 367:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
 368:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
 369:bellator_low_level.c **** 
 370:bellator_low_level.c **** 	T0MR0 = 256; // initially LOW
 371:bellator_low_level.c **** 	T0MR1 = 256; // initially LOW
 372:bellator_low_level.c **** 	T1MR0 = 256; // initially LOW
 373:bellator_low_level.c **** 	T1MR1 = 256; // initially LOW
 374:bellator_low_level.c **** 
 375:bellator_low_level.c **** 	T0TCR = 1; // enable T0
 376:bellator_low_level.c **** 	T1TCR = 1; // enable T1
 377:bellator_low_level.c **** 
 378:bellator_low_level.c **** 	log_string_debug("<< pwm_out_init\n");
 379:bellator_low_level.c **** }
 380:bellator_low_level.c **** 
 381:bellator_low_level.c **** /**
 382:bellator_low_level.c ****  * Set up the protocol using UART1 to communicate with TS-7260
 383:bellator_low_level.c ****  *
 384:bellator_low_level.c ****  * 8N1 (8 data, Non parity, 1 stop)
 385:bellator_low_level.c ****  * 115200 bps
 386:bellator_low_level.c ****  *
 387:bellator_low_level.c ****  * UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL) * ( 1 + DivAddVal/MulVal))
 388:bellator_low_level.c ****  * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
 389:bellator_low_level.c ****  * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
 390:bellator_low_level.c ****  * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
 391:bellator_low_level.c ****  *
 392:bellator_low_level.c ****  * Set UART1 interrupt to the second slot in the vectored interrupts.
 393:bellator_low_level.c ****  */
 394:bellator_low_level.c **** static inline void protocol_init(void){
 395:bellator_low_level.c **** 
 396:bellator_low_level.c **** 	log_string_debug(">> protocol_init\n");
 397:bellator_low_level.c **** 
 398:bellator_low_level.c **** 	volatile char dummy;
 399:bellator_low_level.c **** 
 400:bellator_low_level.c **** 	PINSEL0 |= 0x05 << 16; // Set the pins function
 401:bellator_low_level.c **** 	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 402:bellator_low_level.c **** 	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 403:bellator_low_level.c **** 
 404:bellator_low_level.c **** #ifdef CRYSTAL12MHz
 405:bellator_low_level.c **** 	U1DLL	 = 0x06; // DivisorLatchLow bit
 406:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 407:bellator_low_level.c **** 	U1FDR	|= 0x05; // DivAddVal
 408:bellator_low_level.c **** 	U1FDR	|= 0x0E << 4; // MulVal = 14
 409:bellator_low_level.c **** #endif
 410:bellator_low_level.c **** #ifdef CRYSTAL14745600Hz
 411:bellator_low_level.c **** 	U1DLL	 = 0x08; // DivisorLatchLow bit
 412:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 413:bellator_low_level.c **** #endif
 414:bellator_low_level.c **** 
 415:bellator_low_level.c **** 	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 416:bellator_low_level.c **** 
 417:bellator_low_level.c **** 	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 418:bellator_low_level.c **** 	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 419:bellator_low_level.c **** 	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 420:bellator_low_level.c **** 
 421:bellator_low_level.c **** 	cmd_out.i = 0;
 422:bellator_low_level.c **** 	cmd_in.i = 0;
 423:bellator_low_level.c **** 
 424:bellator_low_level.c **** 	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 425:bellator_low_level.c **** 	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
 426:bellator_low_level.c **** 
 427:bellator_low_level.c **** 	log_string_debug("<< protocol_init\n");
 428:bellator_low_level.c **** }
 429:bellator_low_level.c **** 
 430:bellator_low_level.c **** /**
 431:bellator_low_level.c ****  * Communication Protocol state machine implementation;
 432:bellator_low_level.c ****  * This is triggered on uart1 interruption
 433:bellator_low_level.c ****  * This handles the following commands
 434:bellator_low_level.c ****  *
 435:bellator_low_level.c ****  */
 436:bellator_low_level.c **** void protocol_in(void){
 437:bellator_low_level.c **** 
 438:bellator_low_level.c **** 	log_string_debug(">> protocol_in\n");
 439:bellator_low_level.c **** 
 440:bellator_low_level.c **** 	volatile char dummy;
 441:bellator_low_level.c **** 	volatile char iir;
 442:bellator_low_level.c **** 
 443:bellator_low_level.c **** 	// Repeat while there is at least one interrupt source.
 444:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 445:bellator_low_level.c **** 		switch (iir & 0x0E) {
 446:bellator_low_level.c **** 		case 0x06: // Receive Line Status
 447:bellator_low_level.c **** 			dummy = U1LSR; // Just clear the interrupt source
 448:bellator_low_level.c **** 			break;
 449:bellator_low_level.c **** 
 450:bellator_low_level.c **** 		case 0x04: // Receive Data Available
 451:bellator_low_level.c **** 		case 0x0C: // Character Time-Out
 452:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 453:bellator_low_level.c **** 
 454:bellator_low_level.c **** 			// State machine
 455:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 456:bellator_low_level.c **** 				// ENGINES
 457:bellator_low_level.c **** 				if (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] == ENGINES) {
 458:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]),
 459:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)]));
 460:bellator_low_level.c **** 				}
 461:bellator_low_level.c **** 				// SYNC
 462:bellator_low_level.c **** 				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
 463:bellator_low_level.c **** 
 464:bellator_low_level.c **** 					// Encoders
 465:bellator_low_level.c **** 					int count = get_encoder_count(ENCODER_L);
 466:bellator_low_level.c **** 					cmd_out.buff[0] = (count >> 0x8) & 0xFF;
 467:bellator_low_level.c **** 					cmd_out.buff[1] = count & 0xFF;
 468:bellator_low_level.c **** 					count = get_encoder_count(ENCODER_R);
 469:bellator_low_level.c **** 					cmd_out.buff[2] = (count >> 0x8) & 0xFF;
 470:bellator_low_level.c **** 					cmd_out.buff[3] = count & 0xFF;
 471:bellator_low_level.c **** 					// Infra Red
 472:bellator_low_level.c **** 					char val = get_ir_sensor_data(IR_L);
 473:bellator_low_level.c **** 					cmd_out.buff[4] = val;
 474:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_ML);
 475:bellator_low_level.c **** 					cmd_out.buff[5] = val;
 476:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_M);
 477:bellator_low_level.c **** 					cmd_out.buff[6] = val;
 478:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_MR);
 479:bellator_low_level.c **** 					cmd_out.buff[7] = val;
 480:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_R);
 481:bellator_low_level.c **** 					cmd_out.buff[8] = val;
 482:bellator_low_level.c **** 					// IMU
 483:bellator_low_level.c **** 					// check if data ready, if yes send new data, if not send again last data sent
 484:bellator_low_level.c **** 					if (imu_data_out_pos != imu_data_in_pos) {
 485:bellator_low_level.c **** 						imu_data_out_pos = ++imu_data_out_pos % IMU_BUFF_SIZE;
 486:bellator_low_level.c **** 					}
 487:bellator_low_level.c **** 					struct imu_data* data;
 488:bellator_low_level.c **** 					data = &(imu_data_buff[imu_data_out_pos]);
 489:bellator_low_level.c **** 
 490:bellator_low_level.c **** 					cmd_out.buff[9] = data->ax_h;
 491:bellator_low_level.c **** 					cmd_out.buff[10] = data->ax_l;
 492:bellator_low_level.c **** 					cmd_out.buff[11] = data->ay_h;
 493:bellator_low_level.c **** 					cmd_out.buff[12] = data->ay_l;
 494:bellator_low_level.c **** 					cmd_out.buff[13] = data->az_h;
 495:bellator_low_level.c **** 					cmd_out.buff[14] = data->az_l;
 496:bellator_low_level.c **** 					cmd_out.buff[15] = data->gx_h;
 497:bellator_low_level.c **** 					cmd_out.buff[16] = data->gx_l;
 498:bellator_low_level.c **** 					cmd_out.buff[17] = data->gy_h;
 499:bellator_low_level.c **** 					cmd_out.buff[18] = data->gy_l;
 500:bellator_low_level.c **** 					cmd_out.buff[19] = data->gz_h;
 501:bellator_low_level.c **** 					cmd_out.buff[20] = data->gz_l;
 502:bellator_low_level.c **** 					cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 503:bellator_low_level.c **** 					cmd_out.buff[22] = data->timestamp & 0xFF;
 504:bellator_low_level.c **** 
 505:bellator_low_level.c **** 					// Done
 506:bellator_low_level.c **** 					cmd_out.buff[23] = END_CMD;
 507:bellator_low_level.c **** 					cmd_out.buff[24] = '\n';
 508:bellator_low_level.c **** 					cmd_out.i = 25;
 509:bellator_low_level.c **** 					protocol_out_cmd();
 510:bellator_low_level.c **** 				}
 511:bellator_low_level.c **** 			}
 512:bellator_low_level.c **** 			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
 513:bellator_low_level.c **** 			break;
 514:bellator_low_level.c **** 
 515:bellator_low_level.c **** 		case 0x02: // THRE Interrupt, transmit interrupt
 516:bellator_low_level.c **** 			U1THR = dummy; // Just clear the interrupt source
 517:bellator_low_level.c **** 			break;
 518:bellator_low_level.c **** 
 519:bellator_low_level.c **** 		case 0x00: // Modem Interrupt
 520:bellator_low_level.c **** 			dummy = U1MSR; // Just clear the interrupt source
 521:bellator_low_level.c **** 			break;
 522:bellator_low_level.c **** 
 523:bellator_low_level.c **** 		default:
 524:bellator_low_level.c **** 			break;
 525:bellator_low_level.c **** 		}
 526:bellator_low_level.c **** 	}
 527:bellator_low_level.c **** 
 528:bellator_low_level.c **** 	log_string_debug("<< protocol_in\n");
 529:bellator_low_level.c **** 
 530:bellator_low_level.c **** 	VICVectAddr = 0;
 531:bellator_low_level.c **** }
 532:bellator_low_level.c **** 
 533:bellator_low_level.c **** /**
 534:bellator_low_level.c ****  * Count the encoder pulses using CAP2.0-2 as interrupt sources
 535:bellator_low_level.c ****  */
 536:bellator_low_level.c **** void encoder_pulse_in_isr(void) {
 537:bellator_low_level.c **** 
 538:bellator_low_level.c **** 	log_string_debug(">> encoder_pulse_in_isr\n");
 539:bellator_low_level.c **** 
 540:bellator_low_level.c **** 	const unsigned short ir = T2IR;
 541:bellator_low_level.c **** 
 542:bellator_low_level.c **** 	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
 543:bellator_low_level.c **** 		log_string_debug("FIQ1\n");
 544:bellator_low_level.c **** 		encoder_count[0]++;
 545:bellator_low_level.c **** 		T2IR |= 0x1 << 4; // reset CAP2.0
 546:bellator_low_level.c **** 	}
 547:bellator_low_level.c **** 	else if (ir & (0x1 << 5)) { //CAP2.1 left encoder
 548:bellator_low_level.c **** 		log_string_debug("FIQ2\n");
 549:bellator_low_level.c **** 		//detectar sentido
 550:bellator_low_level.c **** 		T2IR |= 0x1 << 5; // reset CAP2.1
 551:bellator_low_level.c **** 	}
 552:bellator_low_level.c **** 	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
 553:bellator_low_level.c **** 		log_string_debug("FIQ3\n");
 554:bellator_low_level.c **** 		encoder_count[1]++;
 555:bellator_low_level.c **** 		T2IR |= 0x1 << 6; // reset CAP2.1
 556:bellator_low_level.c **** 	}
 557:bellator_low_level.c **** 	else {
 558:bellator_low_level.c **** 		log_string_debug("FIQ4\n");
 559:bellator_low_level.c **** 		//detectar sentido
 560:bellator_low_level.c **** 		EXTINT |= 0x1 << 0; // reset EINT0
 561:bellator_low_level.c **** 	}
 562:bellator_low_level.c **** 
 563:bellator_low_level.c **** 	log_string_debug("<< encoder_pulse_in_isr\n");
 564:bellator_low_level.c **** 
 565:bellator_low_level.c **** 	VICVectAddr = 0;
 566:bellator_low_level.c **** }
 567:bellator_low_level.c **** 
 568:bellator_low_level.c **** /**
 569:bellator_low_level.c ****  * Read IMU data when triggered by EINT2
 570:bellator_low_level.c ****  */
 571:bellator_low_level.c **** void imu_data_ready(void) {
 391              		.loc 4 571 0
 392              		.cfi_startproc
 393              		@ Interrupt Service Routine.
 394              		@ args = 0, pretend = 0, frame = 0
 395              		@ frame_needed = 0, uses_anonymous_args = 0
 396              		@ link register save eliminated.
 397 026c 0C002DE9 		stmfd	sp!, {r2, r3}
 398              		.save {r2, r3}
 399              	.LCFI2:
 400              		.cfi_def_cfa_offset 8
 572:bellator_low_level.c **** 
 573:bellator_low_level.c **** 	//log_string_debug(">> imu_data_ready\n");
 574:bellator_low_level.c **** 
 575:bellator_low_level.c **** 	imu_data_available = 1;
 401              		.loc 4 575 0
 402 0270 28309FE5 		ldr	r3, .L40
 403              		.cfi_offset 3, -4
 404              		.cfi_offset 2, -8
 405 0274 0120A0E3 		mov	r2, #1
 406 0278 1420C3E5 		strb	r2, [r3, #20]
 576:bellator_low_level.c **** 
 577:bellator_low_level.c **** 	EXTINT |= 0x1 << 2; // reset EINT2
 407              		.loc 4 577 0
 408 027c 20309FE5 		ldr	r3, .L40+4
 409 0280 4020D3E5 		ldrb	r2, [r3, #64]	@ zero_extendqisi2
 410 0284 042082E3 		orr	r2, r2, #4
 411 0288 4020C3E5 		strb	r2, [r3, #64]
 578:bellator_low_level.c **** 
 579:bellator_low_level.c **** 	//log_string_debug("<< imu_data_ready\n");
 580:bellator_low_level.c **** 
 581:bellator_low_level.c **** 	VICVectAddr = 0;
 412              		.loc 4 581 0
 413 028c 0020A0E3 		mov	r2, #0
 414 0290 0030E0E3 		mvn	r3, #0
 415 0294 CF2F03E5 		str	r2, [r3, #-4047]
 582:bellator_low_level.c **** }
 416              		.loc 4 582 0
 417 0298 0C00BDE8 		ldmfd	sp!, {r2, r3}
 418 029c 04F05EE2 		subs	pc, lr, #4
 419              	.L41:
 420              		.align	2
 421              	.L40:
 422 02a0 00000000 		.word	.LANCHOR0
 423 02a4 00C11FE0 		.word	-534789888
 424              		.cfi_endproc
 425              	.LFE53:
 426              		.fnend
 428              		.align	2
 429              		.global	error
 431              	error:
 432              		.fnstart
 433              	.LFB54:
 583:bellator_low_level.c **** 
 584:bellator_low_level.c **** /**
 585:bellator_low_level.c ****  *
 586:bellator_low_level.c ****  */
 587:bellator_low_level.c **** void error(void){
 434              		.loc 4 587 0
 435              		.cfi_startproc
 436              		@ Interrupt Service Routine.
 437              		@ args = 0, pretend = 0, frame = 0
 438              		@ frame_needed = 0, uses_anonymous_args = 0
 439              		@ link register save eliminated.
 588:bellator_low_level.c **** 	log_string_error("irq error");
 589:bellator_low_level.c **** }
 440              		.loc 4 589 0
 441 02a8 04F05EE2 		subs	pc, lr, #4
 442              		.cfi_endproc
 443              	.LFE54:
 444              		.fnend
 446              		.align	2
 447              		.global	logger_init
 449              	logger_init:
 450              		.fnstart
 451              	.LFB0:
  20:logger.c      **** void logger_init(void){ // using UART0
 452              		.loc 1 20 0
 453              		.cfi_startproc
 454              		@ Function supports interworking.
 455              		@ args = 0, pretend = 0, frame = 0
 456              		@ frame_needed = 0, uses_anonymous_args = 0
 457              		@ link register save eliminated.
  21:logger.c      **** 	PINSEL0 |= 0x05; // Set the pins function
 458              		.loc 1 21 0
 459 02ac 50309FE5 		ldr	r3, .L44
 460 02b0 002093E5 		ldr	r2, [r3, #0]
 461 02b4 052082E3 		orr	r2, r2, #5
 462 02b8 002083E5 		str	r2, [r3, #0]
  22:logger.c      **** 	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
 463              		.loc 1 22 0
 464 02bc 023843E2 		sub	r3, r3, #131072
 465 02c0 0720A0E3 		mov	r2, #7
 466 02c4 0820C3E5 		strb	r2, [r3, #8]
  23:logger.c      **** 	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 467              		.loc 1 23 0
 468 02c8 7C20E0E3 		mvn	r2, #124
 469 02cc 0C20C3E5 		strb	r2, [r3, #12]
  26:logger.c      **** 	U0DLL	 = 0x06; // DivisorLatchLow bit
 470              		.loc 1 26 0
 471 02d0 832082E2 		add	r2, r2, #131
 472 02d4 0020C3E5 		strb	r2, [r3, #0]
  27:logger.c      **** 	U0DLM	 = 0x00; // DivisorLatchHigh bit
 473              		.loc 1 27 0
 474 02d8 0020A0E3 		mov	r2, #0
 475 02dc 0420C3E5 		strb	r2, [r3, #4]
  28:logger.c      **** 	U0FDR	|= 0x05; // DivAddVal
 476              		.loc 1 28 0
 477 02e0 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 478 02e4 052082E3 		orr	r2, r2, #5
 479 02e8 2820C3E5 		strb	r2, [r3, #40]
  29:logger.c      **** 	U0FDR	|= 0x0E << 4; // MulVal = 14
 480              		.loc 1 29 0
 481 02ec 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 482 02f0 E02082E3 		orr	r2, r2, #224
 483 02f4 2820C3E5 		strb	r2, [r3, #40]
  36:logger.c      **** 	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 484              		.loc 1 36 0
 485 02f8 0320A0E3 		mov	r2, #3
 486 02fc 0C20C3E5 		strb	r2, [r3, #12]
  37:logger.c      **** }
 487              		.loc 1 37 0
 488 0300 1EFF2FE1 		bx	lr
 489              	.L45:
 490              		.align	2
 491              	.L44:
 492 0304 00C002E0 		.word	-536690688
 493              		.cfi_endproc
 494              	.LFE0:
 495              		.fnend
 497              		.align	2
 498              		.global	log_int
 500              	log_int:
 501              		.fnstart
 502              	.LFB2:
  43:logger.c      **** 
  44:logger.c      **** void log_int(int num){
 503              		.loc 1 44 0
 504              		.cfi_startproc
 505              		@ Function supports interworking.
 506              		@ args = 0, pretend = 0, frame = 0
 507              		@ frame_needed = 0, uses_anonymous_args = 0
 508              	.LVL27:
 509 0308 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 510              		.save {r4, r5, r6, lr}
 511              	.LCFI3:
 512              		.cfi_def_cfa_offset 16
  45:logger.c      **** 	if(num & 0x80000000){ // se for negativo
 513              		.loc 1 45 0
 514 030c 004050E2 		subs	r4, r0, #0
 515              		.cfi_offset 14, -4
 516              		.cfi_offset 6, -8
 517              		.cfi_offset 5, -12
 518              		.cfi_offset 4, -16
 519 0310 030000AA 		bge	.L47
  46:logger.c      **** 		log_char('-');
 520              		.loc 1 46 0
 521 0314 2D00A0E3 		mov	r0, #45
 522              	.LVL28:
 523 0318 38FFFFEB 		bl	log_char
 524              	.LVL29:
  47:logger.c      **** 		num = ~num;
  48:logger.c      **** 		num += 0x1;
 525              		.loc 1 48 0
 526 031c 004064E2 		rsb	r4, r4, #0
 527              	.LVL30:
 528 0320 010000EA 		b	.L48
 529              	.LVL31:
 530              	.L47:
  49:logger.c      **** 	}else
  50:logger.c      **** 		log_char(' ');
 531              		.loc 1 50 0
 532 0324 2000A0E3 		mov	r0, #32
 533              	.LVL32:
 534 0328 34FFFFEB 		bl	log_char
 535              	.L48:
  51:logger.c      **** 	log_char(ascii[num >> 28]);
 536              		.loc 1 51 0
 537 032c 74509FE5 		ldr	r5, .L49
 538 0330 440ED5E7 		ldrb	r0, [r5, r4, asr #28]	@ zero_extendqisi2
 539 0334 31FFFFEB 		bl	log_char
  52:logger.c      **** 	log_char(ascii[num >> 24 & 0x0000000f]);
 540              		.loc 1 52 0
 541 0338 443CA0E1 		mov	r3, r4, asr #24
 542 033c 0F3003E2 		and	r3, r3, #15
 543 0340 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 544 0344 2DFFFFEB 		bl	log_char
  53:logger.c      **** 	log_char(ascii[num >> 20 & 0x0000000f]);
 545              		.loc 1 53 0
 546 0348 443AA0E1 		mov	r3, r4, asr #20
 547 034c 0F3003E2 		and	r3, r3, #15
 548 0350 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 549 0354 29FFFFEB 		bl	log_char
  54:logger.c      **** 	log_char(ascii[num >> 16 & 0x0000000f]);
 550              		.loc 1 54 0
 551 0358 4438A0E1 		mov	r3, r4, asr #16
 552 035c 0F3003E2 		and	r3, r3, #15
 553 0360 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 554 0364 25FFFFEB 		bl	log_char
  55:logger.c      **** 	log_char(ascii[num >> 12 & 0x0000000f]);
 555              		.loc 1 55 0
 556 0368 4436A0E1 		mov	r3, r4, asr #12
 557 036c 0F3003E2 		and	r3, r3, #15
 558 0370 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 559 0374 21FFFFEB 		bl	log_char
  56:logger.c      **** 	log_char(ascii[num >> 8 & 0x0000000f]);
 560              		.loc 1 56 0
 561 0378 4434A0E1 		mov	r3, r4, asr #8
 562 037c 0F3003E2 		and	r3, r3, #15
 563 0380 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 564 0384 1DFFFFEB 		bl	log_char
  57:logger.c      **** 	log_char(ascii[num >> 4 & 0x0000000f]);
 565              		.loc 1 57 0
 566 0388 4432A0E1 		mov	r3, r4, asr #4
 567 038c 0F3003E2 		and	r3, r3, #15
 568 0390 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 569 0394 19FFFFEB 		bl	log_char
  58:logger.c      **** 	log_char(ascii[num & 0x0000000f]);
 570              		.loc 1 58 0
 571 0398 0F4004E2 		and	r4, r4, #15
 572              	.LVL33:
 573 039c 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
  59:logger.c      **** }
 574              		.loc 1 59 0
 575 03a0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
  58:logger.c      **** 	log_char(ascii[num & 0x0000000f]);
 576              		.loc 1 58 0
 577 03a4 15FFFFEA 		b	log_char
 578              	.L50:
 579              		.align	2
 580              	.L49:
 581 03a8 00000000 		.word	.LANCHOR1
 582              		.cfi_endproc
 583              	.LFE2:
 584              		.fnend
 586              		.align	2
 587              		.global	log_short
 589              	log_short:
 590              		.fnstart
 591              	.LFB3:
  60:logger.c      **** 
  61:logger.c      **** void log_short(short num){
 592              		.loc 1 61 0
 593              		.cfi_startproc
 594              		@ Function supports interworking.
 595              		@ args = 0, pretend = 0, frame = 0
 596              		@ frame_needed = 0, uses_anonymous_args = 0
 597              	.LVL34:
 598 03ac 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 599              		.save {r4, r5, r6, lr}
 600              	.LCFI4:
 601              		.cfi_def_cfa_offset 16
  62:logger.c      **** 	if(num & 0x8000){ // se for negativo
 602              		.loc 1 62 0
 603 03b0 004050E2 		subs	r4, r0, #0
 604              		.cfi_offset 14, -4
 605              		.cfi_offset 6, -8
 606              		.cfi_offset 5, -12
 607              		.cfi_offset 4, -16
 608 03b4 050000AA 		bge	.L52
  63:logger.c      **** 		log_char('-');
  64:logger.c      **** 		num = ~num;
  65:logger.c      **** 		num++;
 609              		.loc 1 65 0
 610 03b8 004064E2 		rsb	r4, r4, #0
  63:logger.c      **** 		log_char('-');
 611              		.loc 1 63 0
 612 03bc 2D00A0E3 		mov	r0, #45
 613              	.LVL35:
 614              		.loc 1 65 0
 615 03c0 0448A0E1 		mov	r4, r4, asl #16
  63:logger.c      **** 		log_char('-');
 616              		.loc 1 63 0
 617 03c4 0DFFFFEB 		bl	log_char
 618              		.loc 1 65 0
 619 03c8 4448A0E1 		mov	r4, r4, asr #16
 620              	.LVL36:
 621 03cc 010000EA 		b	.L53
 622              	.LVL37:
 623              	.L52:
  66:logger.c      **** 	}else
  67:logger.c      **** 		log_char(' ');
 624              		.loc 1 67 0
 625 03d0 2000A0E3 		mov	r0, #32
 626              	.LVL38:
 627 03d4 09FFFFEB 		bl	log_char
 628              	.L53:
 629              	.LVL39:
  68:logger.c      **** 	log_char(ascii[num >> 12]);
 630              		.loc 1 68 0
 631 03d8 34509FE5 		ldr	r5, .L54
 632 03dc 4406D5E7 		ldrb	r0, [r5, r4, asr #12]	@ zero_extendqisi2
 633 03e0 06FFFFEB 		bl	log_char
  69:logger.c      **** 	log_char(ascii[num >> 8 & 0x000f]);
 634              		.loc 1 69 0
 635 03e4 2434A0E1 		mov	r3, r4, lsr #8
 636 03e8 0F3003E2 		and	r3, r3, #15
 637 03ec 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 638 03f0 02FFFFEB 		bl	log_char
  70:logger.c      **** 	log_char(ascii[num >> 4 & 0x000f]);
 639              		.loc 1 70 0
 640 03f4 2432A0E1 		mov	r3, r4, lsr #4
 641 03f8 0F3003E2 		and	r3, r3, #15
 642 03fc 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 643 0400 FEFEFFEB 		bl	log_char
  71:logger.c      **** 	log_char(ascii[num & 0x000f]);
 644              		.loc 1 71 0
 645 0404 0F4004E2 		and	r4, r4, #15
 646              	.LVL40:
 647 0408 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
  72:logger.c      **** }
 648              		.loc 1 72 0
 649 040c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
  71:logger.c      **** 	log_char(ascii[num & 0x000f]);
 650              		.loc 1 71 0
 651 0410 FAFEFFEA 		b	log_char
 652              	.L55:
 653              		.align	2
 654              	.L54:
 655 0414 00000000 		.word	.LANCHOR1
 656              		.cfi_endproc
 657              	.LFE3:
 658              		.fnend
 660              		.align	2
 661              		.global	log_string
 663              	log_string:
 664              		.fnstart
 665              	.LFB4:
  73:logger.c      **** 
  74:logger.c      **** void log_string(const char *s){
 666              		.loc 1 74 0
 667              		.cfi_startproc
 668              		@ Function supports interworking.
 669              		@ args = 0, pretend = 0, frame = 0
 670              		@ frame_needed = 0, uses_anonymous_args = 0
 671              	.LVL41:
 672 0418 10402DE9 		stmfd	sp!, {r4, lr}
 673              		.save {r4, lr}
 674              	.LCFI5:
 675              		.cfi_def_cfa_offset 8
 676              		.loc 1 74 0
 677 041c 0040A0E1 		mov	r4, r0
 678              		.cfi_offset 14, -4
 679              		.cfi_offset 4, -8
  75:logger.c      **** 	while(*s){
 680              		.loc 1 75 0
 681 0420 040000EA 		b	.L57
 682              	.LVL42:
 683              	.L59:
  76:logger.c      **** 		if(*s == '\n')
 684              		.loc 1 76 0
 685 0424 0A0053E3 		cmp	r3, #10
  77:logger.c      **** 			log_char('\r'); // \n + \r = new line
 686              		.loc 1 77 0
 687 0428 0D00A003 		moveq	r0, #13
 688 042c F3FEFF0B 		bleq	log_char
 689              	.L58:
  78:logger.c      **** 		log_char(*s);
 690              		.loc 1 78 0
 691 0430 010054E5 		ldrb	r0, [r4, #-1]	@ zero_extendqisi2
 692 0434 F1FEFFEB 		bl	log_char
 693              	.L57:
  75:logger.c      **** 	while(*s){
 694              		.loc 1 75 0 discriminator 1
 695 0438 0130D4E4 		ldrb	r3, [r4], #1	@ zero_extendqisi2
 696 043c 000053E3 		cmp	r3, #0
 697 0440 F7FFFF1A 		bne	.L59
  79:logger.c      **** 		s++;
  80:logger.c      **** 	}
  81:logger.c      **** }
 698              		.loc 1 81 0
 699 0444 1040BDE8 		ldmfd	sp!, {r4, lr}
 700 0448 1EFF2FE1 		bx	lr
 701              		.cfi_endproc
 702              	.LFE4:
 703              		.fnend
 705              		.align	2
 706              		.global	log_byte
 708              	log_byte:
 709              		.fnstart
 710              	.LFB5:
  82:logger.c      **** 
  83:logger.c      **** void log_byte(char c){
 711              		.loc 1 83 0
 712              		.cfi_startproc
 713              		@ Function supports interworking.
 714              		@ args = 0, pretend = 0, frame = 0
 715              		@ frame_needed = 0, uses_anonymous_args = 0
 716              	.LVL43:
  84:logger.c      **** 	if(c & 0x80){ // se for negativo
 717              		.loc 1 84 0
 718 044c 800010E3 		tst	r0, #128
  83:logger.c      **** void log_byte(char c){
 719              		.loc 1 83 0
 720 0450 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 721              		.save {r4, r5, r6, lr}
 722              	.LCFI6:
 723              		.cfi_def_cfa_offset 16
  83:logger.c      **** void log_byte(char c){
 724              		.loc 1 83 0
 725 0454 0040A0E1 		mov	r4, r0
 726              		.cfi_offset 14, -4
 727              		.cfi_offset 6, -8
 728              		.cfi_offset 5, -12
 729              		.cfi_offset 4, -16
 730              		.loc 1 84 0
 731 0458 0400000A 		beq	.L61
  85:logger.c      **** 		log_char('-');
 732              		.loc 1 85 0
 733 045c 2D00A0E3 		mov	r0, #45
 734              	.LVL44:
  86:logger.c      **** 		c = ~c;
  87:logger.c      **** 		c++;
 735              		.loc 1 87 0
 736 0460 004064E2 		rsb	r4, r4, #0
  85:logger.c      **** 		log_char('-');
 737              		.loc 1 85 0
 738 0464 E5FEFFEB 		bl	log_char
 739              		.loc 1 87 0
 740 0468 FF4004E2 		and	r4, r4, #255
 741              	.LVL45:
 742 046c 010000EA 		b	.L62
 743              	.LVL46:
 744              	.L61:
  88:logger.c      **** 	}else
  89:logger.c      **** 		log_char(' ');
 745              		.loc 1 89 0
 746 0470 2000A0E3 		mov	r0, #32
 747              	.LVL47:
 748 0474 E1FEFFEB 		bl	log_char
 749              	.L62:
 750              	.LVL48:
  90:logger.c      **** 	log_char(ascii[c >> 4]);
 751              		.loc 1 90 0
 752 0478 14509FE5 		ldr	r5, .L63
 753 047c 2402D5E7 		ldrb	r0, [r5, r4, lsr #4]	@ zero_extendqisi2
 754 0480 DEFEFFEB 		bl	log_char
  91:logger.c      **** 	log_char(ascii[c & 0x000f]);
 755              		.loc 1 91 0
 756 0484 0F4004E2 		and	r4, r4, #15
 757              	.LVL49:
 758 0488 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
  92:logger.c      **** }
 759              		.loc 1 92 0
 760 048c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
  91:logger.c      **** 	log_char(ascii[c & 0x000f]);
 761              		.loc 1 91 0
 762 0490 DAFEFFEA 		b	log_char
 763              	.L64:
 764              		.align	2
 765              	.L63:
 766 0494 00000000 		.word	.LANCHOR1
 767              		.cfi_endproc
 768              	.LFE5:
 769              		.fnend
 771              		.align	2
 772              		.global	log2bytes
 774              	log2bytes:
 775              		.fnstart
 776              	.LFB6:
  93:logger.c      **** 
  94:logger.c      **** void log2bytes(short c){
 777              		.loc 1 94 0
 778              		.cfi_startproc
 779              		@ Function supports interworking.
 780              		@ args = 0, pretend = 0, frame = 0
 781              		@ frame_needed = 0, uses_anonymous_args = 0
 782              	.LVL50:
 783 0498 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 784              		.save {r4, r5, r6, lr}
 785              	.LCFI7:
 786              		.cfi_def_cfa_offset 16
  95:logger.c      **** 	if(c & 0x8000){ // se for negativo
 787              		.loc 1 95 0
 788 049c 004050E2 		subs	r4, r0, #0
 789              		.cfi_offset 14, -4
 790              		.cfi_offset 6, -8
 791              		.cfi_offset 5, -12
 792              		.cfi_offset 4, -16
 793 04a0 050000AA 		bge	.L66
  96:logger.c      **** 		log_char('-');
  97:logger.c      **** 		c = ~c;
  98:logger.c      **** 		c++;
 794              		.loc 1 98 0
 795 04a4 004064E2 		rsb	r4, r4, #0
  96:logger.c      **** 		log_char('-');
 796              		.loc 1 96 0
 797 04a8 2D00A0E3 		mov	r0, #45
 798              	.LVL51:
 799              		.loc 1 98 0
 800 04ac 0448A0E1 		mov	r4, r4, asl #16
  96:logger.c      **** 		log_char('-');
 801              		.loc 1 96 0
 802 04b0 D2FEFFEB 		bl	log_char
 803              		.loc 1 98 0
 804 04b4 4448A0E1 		mov	r4, r4, asr #16
 805              	.LVL52:
 806 04b8 010000EA 		b	.L67
 807              	.LVL53:
 808              	.L66:
  99:logger.c      **** 	}else
 100:logger.c      **** 		log_char(' ');
 809              		.loc 1 100 0
 810 04bc 2000A0E3 		mov	r0, #32
 811              	.LVL54:
 812 04c0 CEFEFFEB 		bl	log_char
 813              	.L67:
 814              	.LVL55:
 101:logger.c      **** 	log_char(ascii[c >> 12]);
 815              		.loc 1 101 0
 816 04c4 34509FE5 		ldr	r5, .L68
 817 04c8 4406D5E7 		ldrb	r0, [r5, r4, asr #12]	@ zero_extendqisi2
 818 04cc CBFEFFEB 		bl	log_char
 102:logger.c      **** 	log_char(ascii[c >> 8 & 0x000f]);
 819              		.loc 1 102 0
 820 04d0 2434A0E1 		mov	r3, r4, lsr #8
 821 04d4 0F3003E2 		and	r3, r3, #15
 822 04d8 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 823 04dc C7FEFFEB 		bl	log_char
 103:logger.c      **** 	log_char(ascii[c >> 4 & 0x000f]);
 824              		.loc 1 103 0
 825 04e0 2432A0E1 		mov	r3, r4, lsr #4
 826 04e4 0F3003E2 		and	r3, r3, #15
 827 04e8 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 828 04ec C3FEFFEB 		bl	log_char
 104:logger.c      **** 	log_char(ascii[c & 0x000f]);
 829              		.loc 1 104 0
 830 04f0 0F4004E2 		and	r4, r4, #15
 831              	.LVL56:
 832 04f4 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 105:logger.c      **** }
 833              		.loc 1 105 0
 834 04f8 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 104:logger.c      **** 	log_char(ascii[c & 0x000f]);
 835              		.loc 1 104 0
 836 04fc BFFEFFEA 		b	log_char
 837              	.L69:
 838              		.align	2
 839              	.L68:
 840 0500 00000000 		.word	.LANCHOR1
 841              		.cfi_endproc
 842              	.LFE6:
 843              		.fnend
 845              		.align	2
 846              		.global	log4bytes
 848              	log4bytes:
 849              		.fnstart
 850              	.LFB7:
 106:logger.c      **** 
 107:logger.c      **** void log4bytes(int c){
 851              		.loc 1 107 0
 852              		.cfi_startproc
 853              		@ Function supports interworking.
 854              		@ args = 0, pretend = 0, frame = 0
 855              		@ frame_needed = 0, uses_anonymous_args = 0
 856              	.LVL57:
 857 0504 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 858              		.save {r4, r5, r6, lr}
 859              	.LCFI8:
 860              		.cfi_def_cfa_offset 16
 108:logger.c      **** 	if(c & 0x80000000){ // se for negativo
 861              		.loc 1 108 0
 862 0508 004050E2 		subs	r4, r0, #0
 863              		.cfi_offset 14, -4
 864              		.cfi_offset 6, -8
 865              		.cfi_offset 5, -12
 866              		.cfi_offset 4, -16
 867 050c 030000AA 		bge	.L71
 109:logger.c      **** 		log_char('-');
 868              		.loc 1 109 0
 869 0510 2D00A0E3 		mov	r0, #45
 870              	.LVL58:
 871 0514 B9FEFFEB 		bl	log_char
 872              	.LVL59:
 110:logger.c      **** 		c = ~c;
 111:logger.c      **** 		c += 0x1;
 873              		.loc 1 111 0
 874 0518 004064E2 		rsb	r4, r4, #0
 875              	.LVL60:
 876 051c 010000EA 		b	.L72
 877              	.LVL61:
 878              	.L71:
 112:logger.c      **** 	}else
 113:logger.c      **** 		log_char(' ');
 879              		.loc 1 113 0
 880 0520 2000A0E3 		mov	r0, #32
 881              	.LVL62:
 882 0524 B5FEFFEB 		bl	log_char
 883              	.L72:
 114:logger.c      **** 	log_char(ascii[c >> 28]);
 884              		.loc 1 114 0
 885 0528 74509FE5 		ldr	r5, .L73
 886 052c 440ED5E7 		ldrb	r0, [r5, r4, asr #28]	@ zero_extendqisi2
 887 0530 B2FEFFEB 		bl	log_char
 115:logger.c      **** 	log_char(ascii[c >> 24 & 0x0000000f]);
 888              		.loc 1 115 0
 889 0534 443CA0E1 		mov	r3, r4, asr #24
 890 0538 0F3003E2 		and	r3, r3, #15
 891 053c 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 892 0540 AEFEFFEB 		bl	log_char
 116:logger.c      **** 	log_char(ascii[c >> 20 & 0x0000000f]);
 893              		.loc 1 116 0
 894 0544 443AA0E1 		mov	r3, r4, asr #20
 895 0548 0F3003E2 		and	r3, r3, #15
 896 054c 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 897 0550 AAFEFFEB 		bl	log_char
 117:logger.c      **** 	log_char(ascii[c >> 16 & 0x0000000f]);
 898              		.loc 1 117 0
 899 0554 4438A0E1 		mov	r3, r4, asr #16
 900 0558 0F3003E2 		and	r3, r3, #15
 901 055c 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 902 0560 A6FEFFEB 		bl	log_char
 118:logger.c      **** 	log_char(ascii[c >> 12 & 0x0000000f]);
 903              		.loc 1 118 0
 904 0564 4436A0E1 		mov	r3, r4, asr #12
 905 0568 0F3003E2 		and	r3, r3, #15
 906 056c 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 907 0570 A2FEFFEB 		bl	log_char
 119:logger.c      **** 	log_char(ascii[c >> 8 & 0x0000000f]);
 908              		.loc 1 119 0
 909 0574 4434A0E1 		mov	r3, r4, asr #8
 910 0578 0F3003E2 		and	r3, r3, #15
 911 057c 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 912 0580 9EFEFFEB 		bl	log_char
 120:logger.c      **** 	log_char(ascii[c >> 4 & 0x0000000f]);
 913              		.loc 1 120 0
 914 0584 4432A0E1 		mov	r3, r4, asr #4
 915 0588 0F3003E2 		and	r3, r3, #15
 916 058c 0300D5E7 		ldrb	r0, [r5, r3]	@ zero_extendqisi2
 917 0590 9AFEFFEB 		bl	log_char
 121:logger.c      **** 	log_char(ascii[c & 0x0000000f]);
 918              		.loc 1 121 0
 919 0594 0F4004E2 		and	r4, r4, #15
 920              	.LVL63:
 921 0598 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 122:logger.c      **** }
 922              		.loc 1 122 0
 923 059c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 121:logger.c      **** 	log_char(ascii[c & 0x0000000f]);
 924              		.loc 1 121 0
 925 05a0 96FEFFEA 		b	log_char
 926              	.L74:
 927              		.align	2
 928              	.L73:
 929 05a4 00000000 		.word	.LANCHOR1
 930              		.cfi_endproc
 931              	.LFE7:
 932              		.fnend
 934              		.align	2
 935              		.global	i2c_init
 937              	i2c_init:
 938              		.fnstart
 939              	.LFB15:
  27:i2c.c         **** void i2c_init(void){
 940              		.loc 3 27 0
 941              		.cfi_startproc
 942              		@ Function supports interworking.
 943              		@ args = 0, pretend = 0, frame = 0
 944              		@ frame_needed = 0, uses_anonymous_args = 0
 945              		@ link register save eliminated.
  32:i2c.c         **** 	PINSEL1 |= 0x1 << 2; // SCL1
 946              		.loc 3 32 0
 947 05a8 54309FE5 		ldr	r3, .L76
 948 05ac 042093E5 		ldr	r2, [r3, #4]
 949 05b0 042082E3 		orr	r2, r2, #4
 950 05b4 042083E5 		str	r2, [r3, #4]
  33:i2c.c         **** 	PINSEL1 |= 0x1 << 4; // SDA1
 951              		.loc 3 33 0
 952 05b8 042093E5 		ldr	r2, [r3, #4]
 953 05bc 102082E3 		orr	r2, r2, #16
 954 05c0 042083E5 		str	r2, [r3, #4]
  35:i2c.c         **** 	I2C1CONCLR = 0x6C; // clear all flags
 955              		.loc 3 35 0
 956 05c4 033883E2 		add	r3, r3, #196608
 957 05c8 6C20A0E3 		mov	r2, #108
 958 05cc 1820C3E5 		strb	r2, [r3, #24]
  36:i2c.c         **** 	I2C1CONSET |= 0x1 << 6; // enable i2c1
 959              		.loc 3 36 0
 960 05d0 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 961 05d4 402082E3 		orr	r2, r2, #64
 962 05d8 0020C3E5 		strb	r2, [r3, #0]
  37:i2c.c         **** 	I2C1SCLH = 19; // Set the bit rate:
 963              		.loc 3 37 0
 964 05dc 1320A0E3 		mov	r2, #19
 965 05e0 B021C3E1 		strh	r2, [r3, #16]	@ movhi
  38:i2c.c         **** 	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
 966              		.loc 3 38 0
 967 05e4 B421C3E1 		strh	r2, [r3, #20]	@ movhi
  41:i2c.c         **** 	VICVectCntl0 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
 968              		.loc 3 41 0
 969 05e8 0030E0E3 		mvn	r3, #0
 970 05ec 202082E2 		add	r2, r2, #32
 971 05f0 FF2D03E5 		str	r2, [r3, #-3583]
  42:i2c.c         **** 	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
 972              		.loc 3 42 0
 973 05f4 EF2F13E5 		ldr	r2, [r3, #-4079]
 974 05f8 022782E3 		orr	r2, r2, #524288
 975 05fc EF2F03E5 		str	r2, [r3, #-4079]
  45:i2c.c         **** }
 976              		.loc 3 45 0
 977 0600 1EFF2FE1 		bx	lr
 978              	.L77:
 979              		.align	2
 980              	.L76:
 981 0604 00C002E0 		.word	-536690688
 982              		.cfi_endproc
 983              	.LFE15:
 984              		.fnend
 986              		.align	2
 987              		.global	i2c_read_bytes
 989              	i2c_read_bytes:
 990              		.fnstart
 991              	.LFB17:
  56:i2c.c         **** int i2c_read_bytes(char reg_addr, char length, char* data) {
 992              		.loc 3 56 0
 993              		.cfi_startproc
 994              		@ Function supports interworking.
 995              		@ args = 0, pretend = 0, frame = 0
 996              		@ frame_needed = 0, uses_anonymous_args = 0
 997              		@ link register save eliminated.
 998              	.LVL64:
  59:i2c.c         **** 	buff_size = length;
 999              		.loc 3 59 0
 1000 0608 44309FE5 		ldr	r3, .L80
 1001 060c 081083E5 		str	r1, [r3, #8]
  60:i2c.c         **** 	buff_pos = 0;
 1002              		.loc 3 60 0
 1003 0610 0010A0E3 		mov	r1, #0
 1004              	.LVL65:
 1005 0614 041083E5 		str	r1, [r3, #4]
  62:i2c.c         **** 	c_buff = data;
 1006              		.loc 3 62 0
 1007 0618 0C2083E5 		str	r2, [r3, #12]
  67:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_read_bytes_isr;
 1008              		.loc 3 67 0
 1009 061c 34109FE5 		ldr	r1, .L80+4
  64:i2c.c         **** 	busy = 1;
 1010              		.loc 3 64 0
 1011 0620 0120A0E3 		mov	r2, #1
 1012              	.LVL66:
 1013 0624 102083E5 		str	r2, [r3, #16]
  67:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_read_bytes_isr;
 1014              		.loc 3 67 0
 1015 0628 0020E0E3 		mvn	r2, #0
  61:i2c.c         **** 	ra_buff = reg_addr;
 1016              		.loc 3 61 0
 1017 062c 0000C3E5 		strb	r0, [r3, #0]
  67:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_read_bytes_isr;
 1018              		.loc 3 67 0
 1019 0630 FF1E02E5 		str	r1, [r2, #-3839]
  69:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 1020              		.loc 3 69 0
 1021 0634 20209FE5 		ldr	r2, .L80+8
 1022 0638 2010A0E3 		mov	r1, #32
 1023 063c 0010C2E5 		strb	r1, [r2, #0]
 1024              	.L79:
  73:i2c.c         **** 	while (busy); // busy wait for read process
 1025              		.loc 3 73 0 discriminator 1
 1026 0640 102093E5 		ldr	r2, [r3, #16]
 1027 0644 000052E3 		cmp	r2, #0
 1028 0648 FCFFFF1A 		bne	.L79
  77:i2c.c         **** }
 1029              		.loc 3 77 0
 1030 064c 0100A0E3 		mov	r0, #1
 1031              	.LVL67:
 1032 0650 1EFF2FE1 		bx	lr
 1033              	.L81:
 1034              		.align	2
 1035              	.L80:
 1036 0654 00000000 		.word	.LANCHOR0
 1037 0658 00000000 		.word	i2c_read_bytes_isr
 1038 065c 00C005E0 		.word	-536494080
 1039              		.cfi_endproc
 1040              	.LFE17:
 1041              		.fnend
 1043              		.align	2
 1044              		.global	i2c_read_byte
 1046              	i2c_read_byte:
 1047              		.fnstart
 1048              	.LFB16:
  47:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
 1049              		.loc 3 47 0
 1050              		.cfi_startproc
 1051              		@ Function supports interworking.
 1052              		@ args = 0, pretend = 0, frame = 0
 1053              		@ frame_needed = 0, uses_anonymous_args = 0
 1054              		@ link register save eliminated.
 1055              	.LVL68:
  47:i2c.c         **** int i2c_read_byte(char reg_addr, char* data) {
 1056              		.loc 3 47 0
 1057 0660 0120A0E1 		mov	r2, r1
  50:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
 1058              		.loc 3 50 0
 1059 0664 0110A0E3 		mov	r1, #1
 1060              	.LVL69:
  54:i2c.c         **** }
 1061              		.loc 3 54 0
  50:i2c.c         **** 	int i = i2c_read_bytes(reg_addr,1,data);
 1062              		.loc 3 50 0
 1063 0668 FEFFFFEA 		b	i2c_read_bytes
 1064              		.cfi_endproc
 1065              	.LFE16:
 1066              		.fnend
 1068              		.align	2
 1069              		.global	i2c_write_byte
 1071              	i2c_write_byte:
 1072              		.fnstart
 1073              	.LFB20:
 181:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 1074              		.loc 3 181 0
 1075              		.cfi_startproc
 1076              		@ Function supports interworking.
 1077              		@ args = 0, pretend = 0, frame = 8
 1078              		@ frame_needed = 0, uses_anonymous_args = 0
 1079              		@ link register save eliminated.
 1080              	.LVL70:
 1081              		.pad #8
 1082 066c 08D04DE2 		sub	sp, sp, #8
 1083              	.LCFI9:
 1084              		.cfi_def_cfa_offset 8
 184:i2c.c         **** 	buff_size = 1;
 1085              		.loc 3 184 0
 1086 0670 50209FE5 		ldr	r2, .L85
 181:i2c.c         **** int i2c_write_byte(char reg_addr, char data) {
 1087              		.loc 3 181 0
 1088 0674 08308DE2 		add	r3, sp, #8
 1089 0678 011063E5 		strb	r1, [r3, #-1]!
 184:i2c.c         **** 	buff_size = 1;
 1090              		.loc 3 184 0
 1091 067c 0110A0E3 		mov	r1, #1
 1092              	.LVL71:
 1093 0680 081082E5 		str	r1, [r2, #8]
 189:i2c.c         **** 	busy = 1;
 1094              		.loc 3 189 0
 1095 0684 101082E5 		str	r1, [r2, #16]
 192:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_write_byte_isr;
 1096              		.loc 3 192 0
 1097 0688 3C109FE5 		ldr	r1, .L85+4
 187:i2c.c         **** 	c_buff = &data;
 1098              		.loc 3 187 0
 1099 068c 0C3082E5 		str	r3, [r2, #12]
 185:i2c.c         **** 	buff_pos = 0;
 1100              		.loc 3 185 0
 1101 0690 00C0A0E3 		mov	ip, #0
 192:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_write_byte_isr;
 1102              		.loc 3 192 0
 1103 0694 0030E0E3 		mvn	r3, #0
 185:i2c.c         **** 	buff_pos = 0;
 1104              		.loc 3 185 0
 1105 0698 04C082E5 		str	ip, [r2, #4]
 186:i2c.c         **** 	ra_buff = reg_addr;
 1106              		.loc 3 186 0
 1107 069c 0000C2E5 		strb	r0, [r2, #0]
 192:i2c.c         **** 	VICVectAddr0 = (unsigned int) &i2c_write_byte_isr;
 1108              		.loc 3 192 0
 1109 06a0 FF1E03E5 		str	r1, [r3, #-3839]
 194:i2c.c         **** 	I2C1CONSET = 0x20; // Transmit start condition
 1110              		.loc 3 194 0
 1111 06a4 24309FE5 		ldr	r3, .L85+8
 1112 06a8 2010A0E3 		mov	r1, #32
 1113 06ac 0010C3E5 		strb	r1, [r3, #0]
 1114              	.L84:
 196:i2c.c         **** 	while (busy); // busy wait for read process
 1115              		.loc 3 196 0 discriminator 1
 1116 06b0 103092E5 		ldr	r3, [r2, #16]
 1117 06b4 000053E3 		cmp	r3, #0
 1118 06b8 FCFFFF1A 		bne	.L84
 200:i2c.c         **** }
 1119              		.loc 3 200 0
 1120 06bc 0100A0E3 		mov	r0, #1
 1121              	.LVL72:
 1122 06c0 08D08DE2 		add	sp, sp, #8
 1123 06c4 1EFF2FE1 		bx	lr
 1124              	.L86:
 1125              		.align	2
 1126              	.L85:
 1127 06c8 00000000 		.word	.LANCHOR0
 1128 06cc 00000000 		.word	i2c_write_byte_isr
 1129 06d0 00C005E0 		.word	-536494080
 1130              		.cfi_endproc
 1131              	.LFE20:
 1132              		.fnend
 1134              		.align	2
 1135              		.global	i2c_write_bits
 1137              	i2c_write_bits:
 1138              		.fnstart
 1139              	.LFB19:
 161:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 1140              		.loc 3 161 0
 1141              		.cfi_startproc
 1142              		@ Function supports interworking.
 1143              		@ args = 0, pretend = 0, frame = 8
 1144              		@ frame_needed = 0, uses_anonymous_args = 0
 1145              	.LVL73:
 1146 06d4 F7402DE9 		stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, lr}
 1147              		.save {r0, r1, r2, r4, r5, r6, r7, lr}
 1148              	.LCFI10:
 1149              		.cfi_def_cfa_offset 32
 161:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 1150              		.loc 3 161 0
 1151 06d8 0150A0E1 		mov	r5, r1
 1152              		.cfi_offset 14, -4
 1153              		.cfi_offset 7, -8
 1154              		.cfi_offset 6, -12
 1155              		.cfi_offset 5, -16
 1156              		.cfi_offset 4, -20
 1157              		.cfi_offset 2, -24
 1158              		.cfi_offset 1, -28
 1159              		.cfi_offset 0, -32
 171:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 1160              		.loc 3 171 0
 1161 06dc 07108DE2 		add	r1, sp, #7
 1162              	.LVL74:
 161:i2c.c         **** int i2c_write_bits(char reg_addr, char bit, char length, char data){
 1163              		.loc 3 161 0
 1164 06e0 0260A0E1 		mov	r6, r2
 1165 06e4 0040A0E1 		mov	r4, r0
 1166 06e8 0370A0E1 		mov	r7, r3
 172:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 1167              		.loc 3 172 0
 1168 06ec 015085E2 		add	r5, r5, #1
 171:i2c.c         **** 	i2c_read_byte(reg_addr, &c);
 1169              		.loc 3 171 0
 1170 06f0 FEFFFFEB 		bl	i2c_read_byte
 1171              	.LVL75:
 172:i2c.c         **** 	char mask = ((1 << length) - 1) << (bit - length + 1);
 1172              		.loc 3 172 0
 1173 06f4 0030E0E3 		mvn	r3, #0
 1174 06f8 055066E0 		rsb	r5, r6, r5
 1175 06fc 1366E0E1 		mvn	r6, r3, asl r6
 1176 0700 1665A0E1 		mov	r6, r6, asl r5
 1177 0704 FF6006E2 		and	r6, r6, #255
 1178              	.LVL76:
 174:i2c.c         **** 	data &= mask; // zero all non-important bits in data
 1179              		.loc 3 174 0
 1180 0708 177506E0 		and	r7, r6, r7, asl r5
 1181              	.LVL77:
 175:i2c.c         **** 	c &= ~(mask); // zero all important bits in existing byte
 1182              		.loc 3 175 0
 1183 070c 0710DDE5 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
 1184              	.LVL78:
 1185 0710 0610C1E1 		bic	r1, r1, r6
 1186              	.LVL79:
 176:i2c.c         **** 	c |= data; // combine data with existing byte
 1187              		.loc 3 176 0
 1188 0714 071081E1 		orr	r1, r1, r7
 1189              	.LVL80:
 178:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 1190              		.loc 3 178 0
 1191 0718 0400A0E1 		mov	r0, r4
 1192              	.LVL81:
 176:i2c.c         **** 	c |= data; // combine data with existing byte
 1193              		.loc 3 176 0
 1194 071c 0710CDE5 		strb	r1, [sp, #7]
 178:i2c.c         **** 	return i2c_write_byte(reg_addr, c);
 1195              		.loc 3 178 0
 1196 0720 FEFFFFEB 		bl	i2c_write_byte
 1197              	.LVL82:
 179:i2c.c         **** }
 1198              		.loc 3 179 0
 1199 0724 FE40BDE8 		ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, lr}
 1200 0728 1EFF2FE1 		bx	lr
 1201              		.cfi_endproc
 1202              	.LFE19:
 1203              		.fnend
 1205              		.align	2
 1206              		.global	mpu_set_clock_source
 1208              	mpu_set_clock_source:
 1209              		.fnstart
 1210              	.LFB23:
 1211              		.file 5 "mpu6050.c"
   1:mpu6050.c     **** /*
   2:mpu6050.c     ****  * mpu6050.c
   3:mpu6050.c     ****  *
   4:mpu6050.c     ****  *  Created on: Mar 21, 2013
   5:mpu6050.c     ****  *      Author: telmo
   6:mpu6050.c     ****  *
   7:mpu6050.c     ****  *  This code was based on Jeff Rowberg code for arduino https://github.com/jrowberg/i2cdevlib/tree
   8:mpu6050.c     ****  */
   9:mpu6050.c     **** #include "lpc2103.h"
  10:mpu6050.c     **** #include "i2c.h"
  11:mpu6050.c     **** #include "logger.h"
  12:mpu6050.c     **** #include "mpu6050.h"
  13:mpu6050.c     **** 
  14:mpu6050.c     **** /** Power on and prepare for general usage.
  15:mpu6050.c     **** * This will activate the device and take it out of sleep mode (which must be done
  16:mpu6050.c     **** * after start-up). This function also sets both the accelerometer and the gyroscope
  17:mpu6050.c     **** * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
  18:mpu6050.c     **** * the clock source to use the X Gyro for reference, which is slightly better than
  19:mpu6050.c     **** * the default internal clock source.
  20:mpu6050.c     **** */
  21:mpu6050.c     **** void mpu_init(void) {
  22:mpu6050.c     **** 	log_string_mpu(">> mpu_init\n");
  23:mpu6050.c     **** 
  24:mpu6050.c     ****     // configure clock source
  25:mpu6050.c     **** 	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
  26:mpu6050.c     **** 	// disable temperature sensor
  27:mpu6050.c     **** 	mpu_set_temperature_sensor_enabled(0);
  28:mpu6050.c     **** 	// set scale to
  29:mpu6050.c     **** 	// acc 2g 16384 LSB/g
  30:mpu6050.c     **** 	// gyro  250 /s 131 LSB//s
  31:mpu6050.c     ****     mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
  32:mpu6050.c     ****     mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
  33:mpu6050.c     **** 
  34:mpu6050.c     ****     // divide gyro output rate do 7, if DLPF>0 set back to 0 to keep output rate 1kHz
  35:mpu6050.c     ****     mpu_set_gyro_rate(7);
  36:mpu6050.c     ****     // set digital low pass filter cut off frequency (disabled)
  37:mpu6050.c     ****     mpu_set_DLPF_mode(0);
  38:mpu6050.c     **** 
  39:mpu6050.c     ****     // enable FIFO
  40:mpu6050.c     ****     mpu_set_6axis_FIFO_enabled(1);
  41:mpu6050.c     **** 
  42:mpu6050.c     ****     // configure interruption
  43:mpu6050.c     ****     mpu_set_interrupt_mode(0); // active high
  44:mpu6050.c     ****     mpu_set_interrupt_drive(0); // push/pull
  45:mpu6050.c     ****     mpu_set_interrupt_latch(0); // 50us pulse on interrupt
  46:mpu6050.c     ****     mpu_set_FIFO_overflow_interrupt(1); // generate interrupt on FIFO overflow
  47:mpu6050.c     ****     mpu_set_data_ready_interrupt(1); // data ready interrupt
  48:mpu6050.c     **** 
  49:mpu6050.c     ****     // clear interrupts
  50:mpu6050.c     **** 	char source;
  51:mpu6050.c     **** 	mpu_clear_interrupt(&source);
  52:mpu6050.c     ****     // reset FIFO
  53:mpu6050.c     ****     mpu_reset_FIFO();
  54:mpu6050.c     ****     // enable fifo
  55:mpu6050.c     ****     mpu_set_FIFO_enabled(1);
  56:mpu6050.c     **** 
  57:mpu6050.c     ****     // stop sleeping
  58:mpu6050.c     ****     mpu_set_sleep_enable(0);
  59:mpu6050.c     **** 
  60:mpu6050.c     **** 	log_string_mpu("<< mpu_init\n");
  61:mpu6050.c     **** }
  62:mpu6050.c     **** 
  63:mpu6050.c     **** /** Set clock source setting.
  64:mpu6050.c     **** * An internal 8MHz oscillator, gyroscope based clock, or external sources can
  65:mpu6050.c     **** * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator
  66:mpu6050.c     **** * or an external source is chosen as the clock source, the MPU-60X0 can operate
  67:mpu6050.c     **** * in low power modes with the gyroscopes disabled.
  68:mpu6050.c     **** *
  69:mpu6050.c     **** * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.
  70:mpu6050.c     **** * However, it is highly recommended that the device be configured to use one of
  71:mpu6050.c     **** * the gyroscopes (or an external clock source) as the clock reference for
  72:mpu6050.c     **** * improved stability. The clock source can be selected according to the following table:
  73:mpu6050.c     **** *
  74:mpu6050.c     **** * <pre>
  75:mpu6050.c     **** * CLK_SEL | Clock Source
  76:mpu6050.c     **** * --------+--------------------------------------
  77:mpu6050.c     **** * 0 | Internal oscillator
  78:mpu6050.c     **** * 1 | PLL with X Gyro reference
  79:mpu6050.c     **** * 2 | PLL with Y Gyro reference
  80:mpu6050.c     **** * 3 | PLL with Z Gyro reference
  81:mpu6050.c     **** * 4 | PLL with external 32.768kHz reference
  82:mpu6050.c     **** * 5 | PLL with external 19.2MHz reference
  83:mpu6050.c     **** * 6 | Reserved
  84:mpu6050.c     **** * 7 | Stops the clock and keeps the timing generator in reset
  85:mpu6050.c     **** * </pre>
  86:mpu6050.c     **** *
  87:mpu6050.c     **** * @param source New clock source setting
  88:mpu6050.c     **** * @see getClockSource()
  89:mpu6050.c     **** * @see MPU6050_RA_PWR_MGMT_1
  90:mpu6050.c     **** * @see MPU6050_PWR1_CLKSEL_BIT
  91:mpu6050.c     **** * @see MPU6050_PWR1_CLKSEL_LENGTH
  92:mpu6050.c     **** */
  93:mpu6050.c     **** void mpu_set_clock_source(char source) {
 1212              		.loc 5 93 0
 1213              		.cfi_startproc
 1214              		@ Function supports interworking.
 1215              		@ args = 0, pretend = 0, frame = 0
 1216              		@ frame_needed = 0, uses_anonymous_args = 0
 1217              		@ link register save eliminated.
 1218              	.LVL83:
 1219              		.loc 5 93 0
 1220 072c 0030A0E1 		mov	r3, r0
  94:mpu6050.c     ****     i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, sour
 1221              		.loc 5 94 0
 1222 0730 0210A0E3 		mov	r1, #2
 1223 0734 6B00A0E3 		mov	r0, #107
 1224              	.LVL84:
 1225 0738 0320A0E3 		mov	r2, #3
  95:mpu6050.c     **** }
 1226              		.loc 5 95 0
  94:mpu6050.c     ****     i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, sour
 1227              		.loc 5 94 0
 1228 073c FEFFFFEA 		b	i2c_write_bits
 1229              		.cfi_endproc
 1230              	.LFE23:
 1231              		.fnend
 1233              		.align	2
 1234              		.global	mpu_set_full_scale_gyro_range
 1236              	mpu_set_full_scale_gyro_range:
 1237              		.fnstart
 1238              	.LFB24:
  96:mpu6050.c     **** 
  97:mpu6050.c     **** /** Set full-scale gyroscope range.
  98:mpu6050.c     **** * @param range New full-scale gyroscope range value
  99:mpu6050.c     **** * @see getFullScaleRange()
 100:mpu6050.c     **** * @see MPU6050_GYRO_FS_250
 101:mpu6050.c     **** * @see MPU6050_RA_GYRO_CONFIG
 102:mpu6050.c     **** * @see MPU6050_GCONFIG_FS_SEL_BIT
 103:mpu6050.c     **** * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 104:mpu6050.c     **** */
 105:mpu6050.c     **** void mpu_set_full_scale_gyro_range(char range) {
 1239              		.loc 5 105 0
 1240              		.cfi_startproc
 1241              		@ Function supports interworking.
 1242              		@ args = 0, pretend = 0, frame = 0
 1243              		@ frame_needed = 0, uses_anonymous_args = 0
 1244              		@ link register save eliminated.
 1245              	.LVL85:
 1246              		.loc 5 105 0
 1247 0740 0030A0E1 		mov	r3, r0
 106:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, 
 1248              		.loc 5 106 0
 1249 0744 0410A0E3 		mov	r1, #4
 1250 0748 1B00A0E3 		mov	r0, #27
 1251              	.LVL86:
 1252 074c 0220A0E3 		mov	r2, #2
 107:mpu6050.c     **** }
 1253              		.loc 5 107 0
 106:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, 
 1254              		.loc 5 106 0
 1255 0750 FEFFFFEA 		b	i2c_write_bits
 1256              		.cfi_endproc
 1257              	.LFE24:
 1258              		.fnend
 1260              		.align	2
 1261              		.global	mpu_set_full_scale_accel_range
 1263              	mpu_set_full_scale_accel_range:
 1264              		.fnstart
 1265              	.LFB25:
 108:mpu6050.c     **** 
 109:mpu6050.c     **** /** Set full-scale accelerometer range.
 110:mpu6050.c     **** * @param range New full-scale accelerometer range setting
 111:mpu6050.c     **** * @see getFullScaleAccelRange()
 112:mpu6050.c     **** */
 113:mpu6050.c     **** void mpu_set_full_scale_accel_range(char range) {
 1266              		.loc 5 113 0
 1267              		.cfi_startproc
 1268              		@ Function supports interworking.
 1269              		@ args = 0, pretend = 0, frame = 0
 1270              		@ frame_needed = 0, uses_anonymous_args = 0
 1271              		@ link register save eliminated.
 1272              	.LVL87:
 1273              		.loc 5 113 0
 1274 0754 0030A0E1 		mov	r3, r0
 114:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGT
 1275              		.loc 5 114 0
 1276 0758 0410A0E3 		mov	r1, #4
 1277 075c 1C00A0E3 		mov	r0, #28
 1278              	.LVL88:
 1279 0760 0220A0E3 		mov	r2, #2
 115:mpu6050.c     **** }
 1280              		.loc 5 115 0
 114:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGT
 1281              		.loc 5 114 0
 1282 0764 FEFFFFEA 		b	i2c_write_bits
 1283              		.cfi_endproc
 1284              	.LFE25:
 1285              		.fnend
 1287              		.align	2
 1288              		.global	mpu_set_sleep_enable
 1290              	mpu_set_sleep_enable:
 1291              		.fnstart
 1292              	.LFB26:
 116:mpu6050.c     **** 
 117:mpu6050.c     **** /** Set sleep mode status.
 118:mpu6050.c     **** * @param enabled New sleep mode enabled status
 119:mpu6050.c     **** * @see getSleepEnabled()
 120:mpu6050.c     **** * @see MPU6050_RA_PWR_MGMT_1
 121:mpu6050.c     **** * @see MPU6050_PWR1_SLEEP_BIT
 122:mpu6050.c     **** */
 123:mpu6050.c     **** void mpu_set_sleep_enable(int enable) {
 1293              		.loc 5 123 0
 1294              		.cfi_startproc
 1295              		@ Function supports interworking.
 1296              		@ args = 0, pretend = 0, frame = 0
 1297              		@ frame_needed = 0, uses_anonymous_args = 0
 1298              		@ link register save eliminated.
 1299              	.LVL89:
 124:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, enable);
 1300              		.loc 5 124 0
 1301 0768 FF3000E2 		and	r3, r0, #255
 1302 076c 0610A0E3 		mov	r1, #6
 1303 0770 6B00A0E3 		mov	r0, #107
 1304              	.LVL90:
 1305 0774 0120A0E3 		mov	r2, #1
 125:mpu6050.c     **** }
 1306              		.loc 5 125 0
 124:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, enable);
 1307              		.loc 5 124 0
 1308 0778 FEFFFFEA 		b	i2c_write_bits
 1309              		.cfi_endproc
 1310              	.LFE26:
 1311              		.fnend
 1313              		.align	2
 1314              		.global	mpu_set_temperature_sensor_enabled
 1316              	mpu_set_temperature_sensor_enabled:
 1317              		.fnstart
 1318              	.LFB27:
 126:mpu6050.c     **** 
 127:mpu6050.c     **** /**
 128:mpu6050.c     ****  * Set temperature sensor enabled status.
 129:mpu6050.c     ****  * Note: this register stores the *disabled* value, but for consistency with the
 130:mpu6050.c     ****  * rest of the code, the function is named and used with standard true/false
 131:mpu6050.c     ****  * values to indicate whether the sensor is enabled or disabled, respectively.
 132:mpu6050.c     ****  * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 133:mpu6050.c     ****  * bit automatically clears to 0 after the reset has been triggered.
 134:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 135:mpu6050.c     ****  */
 136:mpu6050.c     **** void mpu_set_temperature_sensor_enabled(char enabled) {
 1319              		.loc 5 136 0
 1320              		.cfi_startproc
 1321              		@ Function supports interworking.
 1322              		@ args = 0, pretend = 0, frame = 0
 1323              		@ frame_needed = 0, uses_anonymous_args = 0
 1324              		@ link register save eliminated.
 1325              	.LVL91:
 137:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, 1, 1-enabled);
 1326              		.loc 5 137 0
 1327 077c 013060E2 		rsb	r3, r0, #1
 1328 0780 FF3003E2 		and	r3, r3, #255
 1329 0784 6B00A0E3 		mov	r0, #107
 1330              	.LVL92:
 1331 0788 0310A0E3 		mov	r1, #3
 1332 078c 0120A0E3 		mov	r2, #1
 138:mpu6050.c     **** }
 1333              		.loc 5 138 0
 137:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, 1, 1-enabled);
 1334              		.loc 5 137 0
 1335 0790 FEFFFFEA 		b	i2c_write_bits
 1336              		.cfi_endproc
 1337              	.LFE27:
 1338              		.fnend
 1340              		.align	2
 1341              		.global	mpu_set_gyro_rate
 1343              	mpu_set_gyro_rate:
 1344              		.fnstart
 1345              	.LFB28:
 139:mpu6050.c     **** 
 140:mpu6050.c     **** /** Set gyroscope output rate divider.
 141:mpu6050.c     **** * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
 142:mpu6050.c     **** * Motion detection, and Free Fall detection are all based on the Sample Rate.
 143:mpu6050.c     **** * The Sample Rate is generated by dividing the gyroscope output rate by
 144:mpu6050.c     **** * SMPLRT_DIV:
 145:mpu6050.c     **** *
 146:mpu6050.c     **** * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 147:mpu6050.c     **** *
 148:mpu6050.c     **** * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
 149:mpu6050.c     **** * 7), and 1kHz when the DLPF is enabled (see Register 26).
 150:mpu6050.c     **** *
 151:mpu6050.c     **** * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 152:mpu6050.c     **** * Rate greater than 1kHz, the same accelerometer sample may be output to the
 153:mpu6050.c     **** * FIFO, DMP, and sensor registers more than once.
 154:mpu6050.c     **** *
 155:mpu6050.c     **** * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
 156:mpu6050.c     **** * of the MPU-6000/MPU-6050 Product Specification document.
 157:mpu6050.c     **** *
 158:mpu6050.c     **** * @param rate New sample rate divider
 159:mpu6050.c     **** * @see getRate()
 160:mpu6050.c     **** * @see MPU6050_RA_SMPLRT_DIV
 161:mpu6050.c     **** */
 162:mpu6050.c     **** void mpu_set_gyro_rate(char rate) {
 1346              		.loc 5 162 0
 1347              		.cfi_startproc
 1348              		@ Function supports interworking.
 1349              		@ args = 0, pretend = 0, frame = 0
 1350              		@ frame_needed = 0, uses_anonymous_args = 0
 1351              		@ link register save eliminated.
 1352              	.LVL93:
 1353              		.loc 5 162 0
 1354 0794 0010A0E1 		mov	r1, r0
 163:mpu6050.c     ****     i2c_write_byte(MPU6050_RA_SMPLRT_DIV, rate);
 1355              		.loc 5 163 0
 1356 0798 1900A0E3 		mov	r0, #25
 1357              	.LVL94:
 164:mpu6050.c     **** }
 1358              		.loc 5 164 0
 163:mpu6050.c     ****     i2c_write_byte(MPU6050_RA_SMPLRT_DIV, rate);
 1359              		.loc 5 163 0
 1360 079c FEFFFFEA 		b	i2c_write_byte
 1361              		.cfi_endproc
 1362              	.LFE28:
 1363              		.fnend
 1365              		.align	2
 1366              		.global	mpu_set_DLPF_mode
 1368              	mpu_set_DLPF_mode:
 1369              		.fnstart
 1370              	.LFB29:
 165:mpu6050.c     **** 
 166:mpu6050.c     **** /** Get digital low-pass filter configuration.
 167:mpu6050.c     **** * The DLPF_CFG parameter sets the digital low pass filter configuration. It
 168:mpu6050.c     **** * also determines the internal sampling rate used by the device as shown in
 169:mpu6050.c     **** * the table below.
 170:mpu6050.c     **** *
 171:mpu6050.c     **** * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 172:mpu6050.c     **** * Rate greater than 1kHz, the same accelerometer sample may be output to the
 173:mpu6050.c     **** * FIFO, DMP, and sensor registers more than once.
 174:mpu6050.c     **** *
 175:mpu6050.c     **** * <pre>
 176:mpu6050.c     **** * | ACCELEROMETER | GYROSCOPE
 177:mpu6050.c     **** * DLPF_CFG | Bandwidth | Delay | Bandwidth | Delay | Sample Rate
 178:mpu6050.c     **** * ---------+-----------+--------+-----------+--------+-------------
 179:mpu6050.c     **** * 0 | 260Hz | 0ms | 256Hz | 0.98ms | 8kHz
 180:mpu6050.c     **** * 1 | 184Hz | 2.0ms | 188Hz | 1.9ms | 1kHz
 181:mpu6050.c     **** * 2 | 94Hz | 3.0ms | 98Hz | 2.8ms | 1kHz
 182:mpu6050.c     **** * 3 | 44Hz | 4.9ms | 42Hz | 4.8ms | 1kHz
 183:mpu6050.c     **** * 4 | 21Hz | 8.5ms | 20Hz | 8.3ms | 1kHz
 184:mpu6050.c     **** * 5 | 10Hz | 13.8ms | 10Hz | 13.4ms | 1kHz
 185:mpu6050.c     **** * 6 | 5Hz | 19.0ms | 5Hz | 18.6ms | 1kHz
 186:mpu6050.c     **** * 7 | -- Reserved -- | -- Reserved -- | Reserved
 187:mpu6050.c     **** * </pre>
 188:mpu6050.c     **** *
 189:mpu6050.c     **** * @return DLFP configuration
 190:mpu6050.c     **** * @see MPU6050_RA_CONFIG
 191:mpu6050.c     **** * @see MPU6050_CFG_DLPF_CFG_BIT
 192:mpu6050.c     **** * @see MPU6050_CFG_DLPF_CFG_LENGTH
 193:mpu6050.c     **** */
 194:mpu6050.c     **** void mpu_set_DLPF_mode(char mode) {
 1371              		.loc 5 194 0
 1372              		.cfi_startproc
 1373              		@ Function supports interworking.
 1374              		@ args = 0, pretend = 0, frame = 0
 1375              		@ frame_needed = 0, uses_anonymous_args = 0
 1376              		@ link register save eliminated.
 1377              	.LVL95:
 1378              		.loc 5 194 0
 1379 07a0 0030A0E1 		mov	r3, r0
 195:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
 1380              		.loc 5 195 0
 1381 07a4 0210A0E3 		mov	r1, #2
 1382 07a8 1A00A0E3 		mov	r0, #26
 1383              	.LVL96:
 1384 07ac 0320A0E3 		mov	r2, #3
 196:mpu6050.c     **** }
 1385              		.loc 5 196 0
 195:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
 1386              		.loc 5 195 0
 1387 07b0 FEFFFFEA 		b	i2c_write_bits
 1388              		.cfi_endproc
 1389              	.LFE29:
 1390              		.fnend
 1392              		.align	2
 1393              		.global	mpu_set_6axis_FIFO_enabled
 1395              	mpu_set_6axis_FIFO_enabled:
 1396              		.fnstart
 1397              	.LFB30:
 197:mpu6050.c     **** 
 198:mpu6050.c     **** /**
 199:mpu6050.c     ****  * Configure FIFO to store data from accelerometer temp and gyro
 200:mpu6050.c     ****  * @param enabled 0 disabled; 1 enabled
 201:mpu6050.c     ****  */
 202:mpu6050.c     **** void mpu_set_6axis_FIFO_enabled(char enabled) {
 1398              		.loc 5 202 0
 1399              		.cfi_startproc
 1400              		@ Function supports interworking.
 1401              		@ args = 0, pretend = 0, frame = 0
 1402              		@ frame_needed = 0, uses_anonymous_args = 0
 1403              		@ link register save eliminated.
 1404              	.LVL97:
 203:mpu6050.c     **** 	i2c_write_byte(MPU6050_RA_FIFO_EN, 0x78);
 1405              		.loc 5 203 0
 1406 07b4 2300A0E3 		mov	r0, #35
 1407              	.LVL98:
 1408 07b8 7810A0E3 		mov	r1, #120
 204:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, 1, enabled);
 205:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, 1, 0);
 206:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, 1, enabled);
 207:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, 1, enabled);
 208:mpu6050.c     **** //	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, 1, enabled);
 209:mpu6050.c     **** }
 1409              		.loc 5 209 0
 203:mpu6050.c     **** 	i2c_write_byte(MPU6050_RA_FIFO_EN, 0x78);
 1410              		.loc 5 203 0
 1411 07bc FEFFFFEA 		b	i2c_write_byte
 1412              		.cfi_endproc
 1413              	.LFE30:
 1414              		.fnend
 1416              		.align	2
 1417              		.global	mpu_set_interrupt_mode
 1419              	mpu_set_interrupt_mode:
 1420              		.fnstart
 1421              	.LFB31:
 210:mpu6050.c     **** 
 211:mpu6050.c     **** /**
 212:mpu6050.c     ****  * Configure interruption mode
 213:mpu6050.c     ****  * @param mode 0 active high; 1 active low
 214:mpu6050.c     ****  */
 215:mpu6050.c     **** void mpu_set_interrupt_mode(char mode) {
 1422              		.loc 5 215 0
 1423              		.cfi_startproc
 1424              		@ Function supports interworking.
 1425              		@ args = 0, pretend = 0, frame = 0
 1426              		@ frame_needed = 0, uses_anonymous_args = 0
 1427              		@ link register save eliminated.
 1428              	.LVL99:
 1429              		.loc 5 215 0
 1430 07c0 0030A0E1 		mov	r3, r0
 216:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, 1, mode);
 1431              		.loc 5 216 0
 1432 07c4 0710A0E3 		mov	r1, #7
 1433 07c8 3700A0E3 		mov	r0, #55
 1434              	.LVL100:
 1435 07cc 0120A0E3 		mov	r2, #1
 217:mpu6050.c     **** }
 1436              		.loc 5 217 0
 216:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, 1, mode);
 1437              		.loc 5 216 0
 1438 07d0 FEFFFFEA 		b	i2c_write_bits
 1439              		.cfi_endproc
 1440              	.LFE31:
 1441              		.fnend
 1443              		.align	2
 1444              		.global	mpu_set_interrupt_drive
 1446              	mpu_set_interrupt_drive:
 1447              		.fnstart
 1448              	.LFB32:
 218:mpu6050.c     **** 
 219:mpu6050.c     **** /**
 220:mpu6050.c     ****  * Set interrupt drive mode
 221:mpu6050.c     ****  * @param drive 0 push/pull; 1 open-drain
 222:mpu6050.c     ****  */
 223:mpu6050.c     **** void mpu_set_interrupt_drive(char drive) {
 1449              		.loc 5 223 0
 1450              		.cfi_startproc
 1451              		@ Function supports interworking.
 1452              		@ args = 0, pretend = 0, frame = 0
 1453              		@ frame_needed = 0, uses_anonymous_args = 0
 1454              		@ link register save eliminated.
 1455              	.LVL101:
 1456              		.loc 5 223 0
 1457 07d4 0030A0E1 		mov	r3, r0
 224:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, 1, drive);
 1458              		.loc 5 224 0
 1459 07d8 0610A0E3 		mov	r1, #6
 1460 07dc 3700A0E3 		mov	r0, #55
 1461              	.LVL102:
 1462 07e0 0120A0E3 		mov	r2, #1
 225:mpu6050.c     **** }
 1463              		.loc 5 225 0
 224:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, 1, drive);
 1464              		.loc 5 224 0
 1465 07e4 FEFFFFEA 		b	i2c_write_bits
 1466              		.cfi_endproc
 1467              	.LFE32:
 1468              		.fnend
 1470              		.align	2
 1471              		.global	mpu_set_interrupt_latch
 1473              	mpu_set_interrupt_latch:
 1474              		.fnstart
 1475              	.LFB33:
 226:mpu6050.c     **** 
 227:mpu6050.c     **** /**
 228:mpu6050.c     ****  * Set interrupt latch mode
 229:mpu6050.c     ****  * @param latch 0 50us pulse; 1 high until interrupt is cleared
 230:mpu6050.c     ****  */
 231:mpu6050.c     **** void mpu_set_interrupt_latch(char latch) {
 1476              		.loc 5 231 0
 1477              		.cfi_startproc
 1478              		@ Function supports interworking.
 1479              		@ args = 0, pretend = 0, frame = 0
 1480              		@ frame_needed = 0, uses_anonymous_args = 0
 1481              		@ link register save eliminated.
 1482              	.LVL103:
 1483              		.loc 5 231 0
 1484 07e8 0030A0E1 		mov	r3, r0
 232:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, 1, latch);
 1485              		.loc 5 232 0
 1486 07ec 0510A0E3 		mov	r1, #5
 1487 07f0 3700A0E3 		mov	r0, #55
 1488              	.LVL104:
 1489 07f4 0120A0E3 		mov	r2, #1
 233:mpu6050.c     **** }
 1490              		.loc 5 233 0
 232:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, 1, latch);
 1491              		.loc 5 232 0
 1492 07f8 FEFFFFEA 		b	i2c_write_bits
 1493              		.cfi_endproc
 1494              	.LFE33:
 1495              		.fnend
 1497              		.align	2
 1498              		.global	mpu_set_FIFO_overflow_interrupt
 1500              	mpu_set_FIFO_overflow_interrupt:
 1501              		.fnstart
 1502              	.LFB34:
 234:mpu6050.c     **** 
 235:mpu6050.c     **** /**
 236:mpu6050.c     ****  * Set FIFO Buffer Overflow interrupt enabled status.
 237:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 238:mpu6050.c     ****  */
 239:mpu6050.c     **** void mpu_set_FIFO_overflow_interrupt(char enabled) {
 1503              		.loc 5 239 0
 1504              		.cfi_startproc
 1505              		@ Function supports interworking.
 1506              		@ args = 0, pretend = 0, frame = 0
 1507              		@ frame_needed = 0, uses_anonymous_args = 0
 1508              		@ link register save eliminated.
 1509              	.LVL105:
 1510              		.loc 5 239 0
 1511 07fc 0030A0E1 		mov	r3, r0
 240:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, 1, enabled);
 1512              		.loc 5 240 0
 1513 0800 0410A0E3 		mov	r1, #4
 1514 0804 3800A0E3 		mov	r0, #56
 1515              	.LVL106:
 1516 0808 0120A0E3 		mov	r2, #1
 241:mpu6050.c     **** }
 1517              		.loc 5 241 0
 240:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, 1, enabled);
 1518              		.loc 5 240 0
 1519 080c FEFFFFEA 		b	i2c_write_bits
 1520              		.cfi_endproc
 1521              	.LFE34:
 1522              		.fnend
 1524              		.align	2
 1525              		.global	mpu_set_data_ready_interrupt
 1527              	mpu_set_data_ready_interrupt:
 1528              		.fnstart
 1529              	.LFB35:
 242:mpu6050.c     **** 
 243:mpu6050.c     **** /**
 244:mpu6050.c     ****  * Set Data Ready interrupt enabled status.
 245:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 246:mpu6050.c     ****  */
 247:mpu6050.c     **** void mpu_set_data_ready_interrupt(char enabled) {
 1530              		.loc 5 247 0
 1531              		.cfi_startproc
 1532              		@ Function supports interworking.
 1533              		@ args = 0, pretend = 0, frame = 0
 1534              		@ frame_needed = 0, uses_anonymous_args = 0
 1535              		@ link register save eliminated.
 1536              	.LVL107:
 1537              		.loc 5 247 0
 1538 0810 0030A0E1 		mov	r3, r0
 248:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, 1, enabled);
 1539              		.loc 5 248 0
 1540 0814 0010A0E3 		mov	r1, #0
 1541 0818 3800A0E3 		mov	r0, #56
 1542              	.LVL108:
 1543 081c 0120A0E3 		mov	r2, #1
 249:mpu6050.c     **** }
 1544              		.loc 5 249 0
 248:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, 1, enabled);
 1545              		.loc 5 248 0
 1546 0820 FEFFFFEA 		b	i2c_write_bits
 1547              		.cfi_endproc
 1548              	.LFE35:
 1549              		.fnend
 1551              		.align	2
 1552              		.global	mpu_clear_interrupt
 1554              	mpu_clear_interrupt:
 1555              		.fnstart
 1556              	.LFB36:
 250:mpu6050.c     **** 
 251:mpu6050.c     **** /** Get full set of interrupt status bits.
 252:mpu6050.c     **** * These bits clear to 0 after the register has been read. Very useful
 253:mpu6050.c     **** * for getting multiple INT statuses, since each single bit read clears
 254:mpu6050.c     **** * all of them because it has to read the whole byte.
 255:mpu6050.c     **** * @see MPU6050_RA_INT_STATUS
 256:mpu6050.c     **** */
 257:mpu6050.c     **** int mpu_clear_interrupt(char* data) {
 1557              		.loc 5 257 0
 1558              		.cfi_startproc
 1559              		@ Function supports interworking.
 1560              		@ args = 0, pretend = 0, frame = 0
 1561              		@ frame_needed = 0, uses_anonymous_args = 0
 1562              		@ link register save eliminated.
 1563              	.LVL109:
 1564              		.loc 5 257 0
 1565 0824 0010A0E1 		mov	r1, r0
 258:mpu6050.c     **** 	return i2c_read_byte(MPU6050_RA_INT_STATUS, data);
 1566              		.loc 5 258 0
 1567 0828 3A00A0E3 		mov	r0, #58
 1568              	.LVL110:
 259:mpu6050.c     **** }
 1569              		.loc 5 259 0
 258:mpu6050.c     **** 	return i2c_read_byte(MPU6050_RA_INT_STATUS, data);
 1570              		.loc 5 258 0
 1571 082c FEFFFFEA 		b	i2c_read_byte
 1572              		.cfi_endproc
 1573              	.LFE36:
 1574              		.fnend
 1576              		.align	2
 1577              		.global	mpu_set_FIFO_enabled
 1579              	mpu_set_FIFO_enabled:
 1580              		.fnstart
 1581              	.LFB37:
 260:mpu6050.c     **** 
 261:mpu6050.c     **** /** Enable FIFO usage.
 262:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 263:mpu6050.c     ****  */
 264:mpu6050.c     **** void mpu_set_FIFO_enabled(char enabled) {
 1582              		.loc 5 264 0
 1583              		.cfi_startproc
 1584              		@ Function supports interworking.
 1585              		@ args = 0, pretend = 0, frame = 0
 1586              		@ frame_needed = 0, uses_anonymous_args = 0
 1587              		@ link register save eliminated.
 1588              	.LVL111:
 1589              		.loc 5 264 0
 1590 0830 0030A0E1 		mov	r3, r0
 265:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, 1, enabled);
 1591              		.loc 5 265 0
 1592 0834 0610A0E3 		mov	r1, #6
 1593 0838 6A00A0E3 		mov	r0, #106
 1594              	.LVL112:
 1595 083c 0120A0E3 		mov	r2, #1
 266:mpu6050.c     **** }
 1596              		.loc 5 266 0
 265:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, 1, enabled);
 1597              		.loc 5 265 0
 1598 0840 FEFFFFEA 		b	i2c_write_bits
 1599              		.cfi_endproc
 1600              	.LFE37:
 1601              		.fnend
 1603              		.align	2
 1604              		.global	mpu_reset_FIFO
 1606              	mpu_reset_FIFO:
 1607              		.fnstart
 1608              	.LFB38:
 267:mpu6050.c     **** 
 268:mpu6050.c     **** /**
 269:mpu6050.c     ****  * Reset the FIFO.
 270:mpu6050.c     ****  * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 271:mpu6050.c     ****  * bit automatically clears to 0 after the reset has been triggered.
 272:mpu6050.c     ****  * @param enabled 1 enabled; 0 disabled
 273:mpu6050.c     ****  */
 274:mpu6050.c     **** void mpu_reset_FIFO(void) {
 1609              		.loc 5 274 0
 1610              		.cfi_startproc
 1611              		@ Function supports interworking.
 1612              		@ args = 0, pretend = 0, frame = 0
 1613              		@ frame_needed = 0, uses_anonymous_args = 0
 1614              		@ link register save eliminated.
 275:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);
 1615              		.loc 5 275 0
 1616 0844 0120A0E3 		mov	r2, #1
 1617 0848 6A00A0E3 		mov	r0, #106
 1618 084c 0210A0E3 		mov	r1, #2
 1619 0850 0230A0E1 		mov	r3, r2
 276:mpu6050.c     **** }
 1620              		.loc 5 276 0
 275:mpu6050.c     **** 	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);
 1621              		.loc 5 275 0
 1622 0854 FEFFFFEA 		b	i2c_write_bits
 1623              		.cfi_endproc
 1624              	.LFE38:
 1625              		.fnend
 1627              		.align	2
 1628              		.global	mpu_init
 1630              	mpu_init:
 1631              		.fnstart
 1632              	.LFB22:
  21:mpu6050.c     **** void mpu_init(void) {
 1633              		.loc 5 21 0
 1634              		.cfi_startproc
 1635              		@ Function supports interworking.
 1636              		@ args = 0, pretend = 0, frame = 8
 1637              		@ frame_needed = 0, uses_anonymous_args = 0
 1638 0858 07402DE9 		stmfd	sp!, {r0, r1, r2, lr}
 1639              		.save {r0, r1, r2, lr}
 1640              	.LCFI11:
 1641              		.cfi_def_cfa_offset 16
  25:mpu6050.c     **** 	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
 1642              		.loc 5 25 0
 1643 085c 0100A0E3 		mov	r0, #1
 1644              		.cfi_offset 14, -4
 1645              		.cfi_offset 2, -8
 1646              		.cfi_offset 1, -12
 1647              		.cfi_offset 0, -16
 1648 0860 FEFFFFEB 		bl	mpu_set_clock_source
  27:mpu6050.c     **** 	mpu_set_temperature_sensor_enabled(0);
 1649              		.loc 5 27 0
 1650 0864 0000A0E3 		mov	r0, #0
 1651 0868 FEFFFFEB 		bl	mpu_set_temperature_sensor_enabled
  31:mpu6050.c     ****     mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
 1652              		.loc 5 31 0
 1653 086c 0000A0E3 		mov	r0, #0
 1654 0870 FEFFFFEB 		bl	mpu_set_full_scale_gyro_range
  32:mpu6050.c     ****     mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
 1655              		.loc 5 32 0
 1656 0874 0000A0E3 		mov	r0, #0
 1657 0878 FEFFFFEB 		bl	mpu_set_full_scale_accel_range
  35:mpu6050.c     ****     mpu_set_gyro_rate(7);
 1658              		.loc 5 35 0
 1659 087c 0700A0E3 		mov	r0, #7
 1660 0880 FEFFFFEB 		bl	mpu_set_gyro_rate
  37:mpu6050.c     ****     mpu_set_DLPF_mode(0);
 1661              		.loc 5 37 0
 1662 0884 0000A0E3 		mov	r0, #0
 1663 0888 FEFFFFEB 		bl	mpu_set_DLPF_mode
  40:mpu6050.c     ****     mpu_set_6axis_FIFO_enabled(1);
 1664              		.loc 5 40 0
 1665 088c 0100A0E3 		mov	r0, #1
 1666 0890 FEFFFFEB 		bl	mpu_set_6axis_FIFO_enabled
  43:mpu6050.c     ****     mpu_set_interrupt_mode(0); // active high
 1667              		.loc 5 43 0
 1668 0894 0000A0E3 		mov	r0, #0
 1669 0898 FEFFFFEB 		bl	mpu_set_interrupt_mode
  44:mpu6050.c     ****     mpu_set_interrupt_drive(0); // push/pull
 1670              		.loc 5 44 0
 1671 089c 0000A0E3 		mov	r0, #0
 1672 08a0 FEFFFFEB 		bl	mpu_set_interrupt_drive
  45:mpu6050.c     ****     mpu_set_interrupt_latch(0); // 50us pulse on interrupt
 1673              		.loc 5 45 0
 1674 08a4 0000A0E3 		mov	r0, #0
 1675 08a8 FEFFFFEB 		bl	mpu_set_interrupt_latch
  46:mpu6050.c     ****     mpu_set_FIFO_overflow_interrupt(1); // generate interrupt on FIFO overflow
 1676              		.loc 5 46 0
 1677 08ac 0100A0E3 		mov	r0, #1
 1678 08b0 FEFFFFEB 		bl	mpu_set_FIFO_overflow_interrupt
  47:mpu6050.c     ****     mpu_set_data_ready_interrupt(1); // data ready interrupt
 1679              		.loc 5 47 0
 1680 08b4 0100A0E3 		mov	r0, #1
 1681 08b8 FEFFFFEB 		bl	mpu_set_data_ready_interrupt
  51:mpu6050.c     **** 	mpu_clear_interrupt(&source);
 1682              		.loc 5 51 0
 1683 08bc 07008DE2 		add	r0, sp, #7
 1684 08c0 FEFFFFEB 		bl	mpu_clear_interrupt
  53:mpu6050.c     ****     mpu_reset_FIFO();
 1685              		.loc 5 53 0
 1686 08c4 FEFFFFEB 		bl	mpu_reset_FIFO
  55:mpu6050.c     ****     mpu_set_FIFO_enabled(1);
 1687              		.loc 5 55 0
 1688 08c8 0100A0E3 		mov	r0, #1
 1689 08cc FEFFFFEB 		bl	mpu_set_FIFO_enabled
  58:mpu6050.c     ****     mpu_set_sleep_enable(0);
 1690              		.loc 5 58 0
 1691 08d0 0000A0E3 		mov	r0, #0
 1692 08d4 FEFFFFEB 		bl	mpu_set_sleep_enable
  61:mpu6050.c     **** }
 1693              		.loc 5 61 0
 1694 08d8 0E40BDE8 		ldmfd	sp!, {r1, r2, r3, lr}
 1695 08dc 1EFF2FE1 		bx	lr
 1696              		.cfi_endproc
 1697              	.LFE22:
 1698              		.fnend
 1700              		.align	2
 1701              		.global	mpu_get_FIFO_size
 1703              	mpu_get_FIFO_size:
 1704              		.fnstart
 1705              	.LFB39:
 277:mpu6050.c     **** 
 278:mpu6050.c     **** 
 279:mpu6050.c     **** /** Get current FIFO buffer size.
 280:mpu6050.c     **** * This value indicates the number of bytes stored in the FIFO buffer. This
 281:mpu6050.c     **** * number is in turn the number of bytes that can be read from the FIFO buffer
 282:mpu6050.c     **** * and it is directly proportional to the number of samples available given the
 283:mpu6050.c     **** * set of sensor data bound to be stored in the FIFO (register 35 and 36).
 284:mpu6050.c     **** */
 285:mpu6050.c     **** void mpu_get_FIFO_size(int* size) {
 1706              		.loc 5 285 0
 1707              		.cfi_startproc
 1708              		@ Function supports interworking.
 1709              		@ args = 0, pretend = 0, frame = 8
 1710              		@ frame_needed = 0, uses_anonymous_args = 0
 1711              	.LVL113:
 1712 08e0 13402DE9 		stmfd	sp!, {r0, r1, r4, lr}
 1713              		.save {r0, r1, r4, lr}
 1714              	.LCFI12:
 1715              		.cfi_def_cfa_offset 16
 1716              		.loc 5 285 0
 1717 08e4 0040A0E1 		mov	r4, r0
 1718              		.cfi_offset 14, -4
 1719              		.cfi_offset 4, -8
 1720              		.cfi_offset 1, -12
 1721              		.cfi_offset 0, -16
 286:mpu6050.c     **** 	char count[2];
 287:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_FIFO_COUNTH, 2, count);
 1722              		.loc 5 287 0
 1723 08e8 04208DE2 		add	r2, sp, #4
 1724 08ec 7200A0E3 		mov	r0, #114
 1725              	.LVL114:
 1726 08f0 0210A0E3 		mov	r1, #2
 1727 08f4 FEFFFFEB 		bl	i2c_read_bytes
 288:mpu6050.c     **** 	*size = (((int)count[0]) << 8) | count[1];
 1728              		.loc 5 288 0
 1729 08f8 0420DDE5 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 1730 08fc 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 1731 0900 023483E1 		orr	r3, r3, r2, asl #8
 1732 0904 003084E5 		str	r3, [r4, #0]
 289:mpu6050.c     **** }
 1733              		.loc 5 289 0
 1734 0908 1C40BDE8 		ldmfd	sp!, {r2, r3, r4, lr}
 1735 090c 1EFF2FE1 		bx	lr
 1736              		.cfi_endproc
 1737              	.LFE39:
 1738              		.fnend
 1740              		.align	2
 1741              		.global	mpu_get_motion6
 1743              	mpu_get_motion6:
 1744              		.fnstart
 1745              	.LFB40:
 290:mpu6050.c     **** 
 291:mpu6050.c     **** /** Get raw 6-axis motion sensor readings (accel/gyro).
 292:mpu6050.c     **** * Retrieves all currently available motion sensor values.
 293:mpu6050.c     **** * @param ax 16-bit signed integer container for accelerometer X-axis value
 294:mpu6050.c     **** * @param ay 16-bit signed integer container for accelerometer Y-axis value
 295:mpu6050.c     **** * @param az 16-bit signed integer container for accelerometer Z-axis value
 296:mpu6050.c     **** * @param gx 16-bit signed integer container for gyroscope X-axis value
 297:mpu6050.c     **** * @param gy 16-bit signed integer container for gyroscope Y-axis value
 298:mpu6050.c     **** * @param gz 16-bit signed integer container for gyroscope Z-axis value
 299:mpu6050.c     **** * @see getAcceleration()
 300:mpu6050.c     **** * @see getRotation()
 301:mpu6050.c     **** * @see MPU6050_RA_ACCEL_XOUT_H
 302:mpu6050.c     **** */
 303:mpu6050.c     **** //void MPU6050::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t
 304:mpu6050.c     **** //    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 14, buffer);
 305:mpu6050.c     **** //    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];
 306:mpu6050.c     **** //    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];
 307:mpu6050.c     **** //    *az = (((int16_t)buffer[4]) << 8) | buffer[5];
 308:mpu6050.c     **** //    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];
 309:mpu6050.c     **** //    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];
 310:mpu6050.c     **** //    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];
 311:mpu6050.c     **** //}
 312:mpu6050.c     **** void mpu_get_motion6(char* ax_h, char* ax_l, char* ay_h, char* ay_l, char* az_h, char* az_l,
 313:mpu6050.c     **** 		char* gx_h, char* gx_l, char* gy_h, char* gy_l, char* gz_h, char* gz_l) {
 1746              		.loc 5 313 0
 1747              		.cfi_startproc
 1748              		@ Function supports interworking.
 1749              		@ args = 32, pretend = 0, frame = 16
 1750              		@ frame_needed = 0, uses_anonymous_args = 0
 1751              	.LVL115:
 1752 0910 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1753              		.save {r4, r5, r6, r7, lr}
 1754              	.LCFI13:
 1755              		.cfi_def_cfa_offset 20
 1756              		.pad #20
 1757 0914 14D04DE2 		sub	sp, sp, #20
 1758              	.LCFI14:
 1759              		.cfi_def_cfa_offset 40
 1760              		.loc 5 313 0
 1761 0918 0060A0E1 		mov	r6, r0
 1762              		.cfi_offset 14, -4
 1763              		.cfi_offset 7, -8
 1764              		.cfi_offset 6, -12
 1765              		.cfi_offset 5, -16
 1766              		.cfi_offset 4, -20
 1767 091c 0150A0E1 		mov	r5, r1
 1768 0920 0240A0E1 		mov	r4, r2
 314:mpu6050.c     **** 	char c[14];
 315:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_ACCEL_XOUT_H, 14, c);
 1769              		.loc 5 315 0
 1770 0924 3B00A0E3 		mov	r0, #59
 1771              	.LVL116:
 1772 0928 0D20A0E1 		mov	r2, sp
 1773              	.LVL117:
 1774 092c 0E10A0E3 		mov	r1, #14
 1775              	.LVL118:
 313:mpu6050.c     **** 		char* gx_h, char* gx_l, char* gy_h, char* gy_l, char* gz_h, char* gz_l) {
 1776              		.loc 5 313 0
 1777 0930 0370A0E1 		mov	r7, r3
 1778              		.loc 5 315 0
 1779 0934 FEFFFFEB 		bl	i2c_read_bytes
 1780              	.LVL119:
 316:mpu6050.c     **** 	*ax_h = c[0];
 1781              		.loc 5 316 0
 1782 0938 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1783 093c 0030C6E5 		strb	r3, [r6, #0]
 317:mpu6050.c     **** 	*ax_l = c[1];
 1784              		.loc 5 317 0
 1785 0940 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1786 0944 0030C5E5 		strb	r3, [r5, #0]
 318:mpu6050.c     **** 	*ay_h = c[2];
 1787              		.loc 5 318 0
 1788 0948 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1789 094c 0030C4E5 		strb	r3, [r4, #0]
 319:mpu6050.c     **** 	*ay_l = c[3];
 1790              		.loc 5 319 0
 1791 0950 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 320:mpu6050.c     **** 	*az_h = c[4];
 1792              		.loc 5 320 0
 1793 0954 0420DDE5 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 319:mpu6050.c     **** 	*ay_l = c[3];
 1794              		.loc 5 319 0
 1795 0958 0030C7E5 		strb	r3, [r7, #0]
 1796              		.loc 5 320 0
 1797 095c 28309DE5 		ldr	r3, [sp, #40]
 1798 0960 0020C3E5 		strb	r2, [r3, #0]
 321:mpu6050.c     **** 	*az_l = c[5];
 1799              		.loc 5 321 0
 1800 0964 2C309DE5 		ldr	r3, [sp, #44]
 1801 0968 0520DDE5 		ldrb	r2, [sp, #5]	@ zero_extendqisi2
 1802 096c 0020C3E5 		strb	r2, [r3, #0]
 322:mpu6050.c     **** 	*gx_h = c[8];
 1803              		.loc 5 322 0
 1804 0970 30309DE5 		ldr	r3, [sp, #48]
 1805 0974 0820DDE5 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 1806 0978 0020C3E5 		strb	r2, [r3, #0]
 323:mpu6050.c     **** 	*gx_l = c[9];
 1807              		.loc 5 323 0
 1808 097c 34309DE5 		ldr	r3, [sp, #52]
 1809 0980 0920DDE5 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 1810 0984 0020C3E5 		strb	r2, [r3, #0]
 324:mpu6050.c     **** 	*gy_h = c[10];
 1811              		.loc 5 324 0
 1812 0988 38309DE5 		ldr	r3, [sp, #56]
 1813 098c 0A20DDE5 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 1814 0990 0020C3E5 		strb	r2, [r3, #0]
 325:mpu6050.c     **** 	*gy_l = c[11];
 1815              		.loc 5 325 0
 1816 0994 3C309DE5 		ldr	r3, [sp, #60]
 1817 0998 0B20DDE5 		ldrb	r2, [sp, #11]	@ zero_extendqisi2
 1818 099c 0020C3E5 		strb	r2, [r3, #0]
 326:mpu6050.c     **** 	*gz_h = c[12];
 1819              		.loc 5 326 0
 1820 09a0 40309DE5 		ldr	r3, [sp, #64]
 1821 09a4 0C20DDE5 		ldrb	r2, [sp, #12]	@ zero_extendqisi2
 1822 09a8 0020C3E5 		strb	r2, [r3, #0]
 327:mpu6050.c     **** 	*gz_l = c[13];
 1823              		.loc 5 327 0
 1824 09ac 44309DE5 		ldr	r3, [sp, #68]
 1825 09b0 0D20DDE5 		ldrb	r2, [sp, #13]	@ zero_extendqisi2
 1826 09b4 0020C3E5 		strb	r2, [r3, #0]
 328:mpu6050.c     **** }
 1827              		.loc 5 328 0
 1828 09b8 14D08DE2 		add	sp, sp, #20
 1829 09bc F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1830 09c0 1EFF2FE1 		bx	lr
 1831              		.cfi_endproc
 1832              	.LFE40:
 1833              		.fnend
 1835              		.align	2
 1836              		.global	mpu_get_FIFO_motion6
 1838              	mpu_get_FIFO_motion6:
 1839              		.fnstart
 1840              	.LFB41:
 329:mpu6050.c     **** 
 330:mpu6050.c     **** /** Get byte from FIFO buffer.
 331:mpu6050.c     **** * This register is used to read and write data from the FIFO buffer. Data is
 332:mpu6050.c     **** * written to the FIFO in order of register number (from lowest to highest). If
 333:mpu6050.c     **** * all the FIFO enable flags (see below) are enabled and all External Sensor
 334:mpu6050.c     **** * Data registers (Registers 73 to 96) are associated with a Slave device, the
 335:mpu6050.c     **** * contents of registers 59 through 96 will be written in order at the Sample
 336:mpu6050.c     **** * Rate.
 337:mpu6050.c     **** *
 338:mpu6050.c     **** * The contents of the sensor data registers (Registers 59 to 96) are written
 339:mpu6050.c     **** * into the FIFO buffer when their corresponding FIFO enable flags are set to 1
 340:mpu6050.c     **** * in FIFO_EN (Register 35). An additional flag for the sensor data registers
 341:mpu6050.c     **** * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).
 342:mpu6050.c     **** *
 343:mpu6050.c     **** * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is
 344:mpu6050.c     **** * automatically set to 1. This bit is located in INT_STATUS (Register 58).
 345:mpu6050.c     **** * When the FIFO buffer has overflowed, the oldest data will be lost and new
 346:mpu6050.c     **** * data will be written to the FIFO.
 347:mpu6050.c     **** *
 348:mpu6050.c     **** * If the FIFO buffer is empty, reading this register will return the last byte
 349:mpu6050.c     **** * that was previously read from the FIFO until new data is available. The user
 350:mpu6050.c     **** * should check FIFO_COUNT to ensure that the FIFO buffer is not read when
 351:mpu6050.c     **** * empty.
 352:mpu6050.c     **** */
 353:mpu6050.c     **** void mpu_get_FIFO_motion6(char* ax_h, char* ax_l, char* ay_h, char* ay_l, char* az_h, char* az_l,
 354:mpu6050.c     **** 		char* gx_h, char* gx_l, char* gy_h, char* gy_l, char* gz_h, char* gz_l) {
 1841              		.loc 5 354 0
 1842              		.cfi_startproc
 1843              		@ Function supports interworking.
 1844              		@ args = 32, pretend = 0, frame = 16
 1845              		@ frame_needed = 0, uses_anonymous_args = 0
 1846              	.LVL120:
 1847 09c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1848              		.save {r4, r5, r6, r7, lr}
 1849              	.LCFI15:
 1850              		.cfi_def_cfa_offset 20
 1851              		.pad #20
 1852 09c8 14D04DE2 		sub	sp, sp, #20
 1853              	.LCFI16:
 1854              		.cfi_def_cfa_offset 40
 1855              		.loc 5 354 0
 1856 09cc 0060A0E1 		mov	r6, r0
 1857              		.cfi_offset 14, -4
 1858              		.cfi_offset 7, -8
 1859              		.cfi_offset 6, -12
 1860              		.cfi_offset 5, -16
 1861              		.cfi_offset 4, -20
 1862 09d0 0150A0E1 		mov	r5, r1
 1863 09d4 0240A0E1 		mov	r4, r2
 355:mpu6050.c     **** 
 356:mpu6050.c     **** 	char c[12];
 357:mpu6050.c     **** 	i2c_read_bytes(MPU6050_RA_FIFO_R_W, 12, c);
 1864              		.loc 5 357 0
 1865 09d8 7400A0E3 		mov	r0, #116
 1866              	.LVL121:
 1867 09dc 04208DE2 		add	r2, sp, #4
 1868              	.LVL122:
 1869 09e0 0C10A0E3 		mov	r1, #12
 1870              	.LVL123:
 354:mpu6050.c     **** 		char* gx_h, char* gx_l, char* gy_h, char* gy_l, char* gz_h, char* gz_l) {
 1871              		.loc 5 354 0
 1872 09e4 0370A0E1 		mov	r7, r3
 1873              		.loc 5 357 0
 1874 09e8 FEFFFFEB 		bl	i2c_read_bytes
 1875              	.LVL124:
 358:mpu6050.c     **** 	*ax_h = c[0];
 1876              		.loc 5 358 0
 1877 09ec 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1878 09f0 0030C6E5 		strb	r3, [r6, #0]
 359:mpu6050.c     **** 	*ax_l = c[1];
 1879              		.loc 5 359 0
 1880 09f4 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 1881 09f8 0030C5E5 		strb	r3, [r5, #0]
 360:mpu6050.c     **** 	*ay_h = c[2];
 1882              		.loc 5 360 0
 1883 09fc 0630DDE5 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 1884 0a00 0030C4E5 		strb	r3, [r4, #0]
 361:mpu6050.c     **** 	*ay_l = c[3];
 1885              		.loc 5 361 0
 1886 0a04 0730DDE5 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 362:mpu6050.c     **** 	*az_h = c[4];
 1887              		.loc 5 362 0
 1888 0a08 0820DDE5 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 361:mpu6050.c     **** 	*ay_l = c[3];
 1889              		.loc 5 361 0
 1890 0a0c 0030C7E5 		strb	r3, [r7, #0]
 1891              		.loc 5 362 0
 1892 0a10 28309DE5 		ldr	r3, [sp, #40]
 1893 0a14 0020C3E5 		strb	r2, [r3, #0]
 363:mpu6050.c     **** 	*az_l = c[5];
 1894              		.loc 5 363 0
 1895 0a18 2C309DE5 		ldr	r3, [sp, #44]
 1896 0a1c 0920DDE5 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 1897 0a20 0020C3E5 		strb	r2, [r3, #0]
 364:mpu6050.c     **** 	*gx_h = c[6];
 1898              		.loc 5 364 0
 1899 0a24 30309DE5 		ldr	r3, [sp, #48]
 1900 0a28 0A20DDE5 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 1901 0a2c 0020C3E5 		strb	r2, [r3, #0]
 365:mpu6050.c     **** 	*gx_l = c[7];
 1902              		.loc 5 365 0
 1903 0a30 34309DE5 		ldr	r3, [sp, #52]
 1904 0a34 0B20DDE5 		ldrb	r2, [sp, #11]	@ zero_extendqisi2
 1905 0a38 0020C3E5 		strb	r2, [r3, #0]
 366:mpu6050.c     **** 	*gy_h = c[8];
 1906              		.loc 5 366 0
 1907 0a3c 38309DE5 		ldr	r3, [sp, #56]
 1908 0a40 0C20DDE5 		ldrb	r2, [sp, #12]	@ zero_extendqisi2
 1909 0a44 0020C3E5 		strb	r2, [r3, #0]
 367:mpu6050.c     **** 	*gy_l = c[9];
 1910              		.loc 5 367 0
 1911 0a48 3C309DE5 		ldr	r3, [sp, #60]
 1912 0a4c 0D20DDE5 		ldrb	r2, [sp, #13]	@ zero_extendqisi2
 1913 0a50 0020C3E5 		strb	r2, [r3, #0]
 368:mpu6050.c     **** 	*gz_h = c[10];
 1914              		.loc 5 368 0
 1915 0a54 40309DE5 		ldr	r3, [sp, #64]
 1916 0a58 0E20DDE5 		ldrb	r2, [sp, #14]	@ zero_extendqisi2
 1917 0a5c 0020C3E5 		strb	r2, [r3, #0]
 369:mpu6050.c     **** 	*gz_l = c[11];
 1918              		.loc 5 369 0
 1919 0a60 44309DE5 		ldr	r3, [sp, #68]
 1920 0a64 0F20DDE5 		ldrb	r2, [sp, #15]	@ zero_extendqisi2
 1921 0a68 0020C3E5 		strb	r2, [r3, #0]
 370:mpu6050.c     **** 
 371:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ax_h);
 372:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ax_l);
 373:mpu6050.c     **** //
 374:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ay_h);
 375:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, ay_l);
 376:mpu6050.c     **** //
 377:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, az_h);
 378:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, az_l);
 379:mpu6050.c     **** //
 380:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gx_h);
 381:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gx_l);
 382:mpu6050.c     **** //
 383:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_h);
 384:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_l);
 385:mpu6050.c     **** //
 386:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_h);
 387:mpu6050.c     **** //	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_l);
 388:mpu6050.c     **** }
 1922              		.loc 5 388 0
 1923 0a6c 14D08DE2 		add	sp, sp, #20
 1924 0a70 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1925 0a74 1EFF2FE1 		bx	lr
 1926              		.cfi_endproc
 1927              	.LFE41:
 1928              		.fnend
 1930              		.align	2
 1931              		.global	main
 1933              	main:
 1934              		.fnstart
 1935              	.LFB42:
  81:bellator_low_level.c **** int main(void){
 1936              		.loc 4 81 0
 1937              		.cfi_startproc
 1938              		@ Function supports interworking.
 1939              		@ args = 0, pretend = 0, frame = 8
 1940              		@ frame_needed = 0, uses_anonymous_args = 0
 1941 0a78 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1942              		.save {r4, r5, r6, r7, r8, lr}
 1943              	.LCFI17:
 1944              		.cfi_def_cfa_offset 24
 1945              	.LBB42:
 1946              	.LBB43:
 196:bellator_low_level.c **** 	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 1947              		.loc 4 196 0
 1948 0a7c 80349FE5 		ldr	r3, .L120
 1949 0a80 2420A0E3 		mov	r2, #36
 1950 0a84 8420C3E5 		strb	r2, [r3, #132]
 202:bellator_low_level.c **** 	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 1951              		.loc 4 202 0
 1952 0a88 0120A0E3 		mov	r2, #1
 1953 0a8c 8020C3E5 		strb	r2, [r3, #128]
 203:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 1954              		.loc 4 203 0
 1955 0a90 5520E0E3 		mvn	r2, #85
 1956 0a94 8C20C3E5 		strb	r2, [r3, #140]
 204:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 1957              		.loc 4 204 0
 1958 0a98 AB2082E2 		add	r2, r2, #171
 1959 0a9c 8C20C3E5 		strb	r2, [r3, #140]
 1960              	.LBE43:
 1961              	.LBE42:
  81:bellator_low_level.c **** int main(void){
 1962              		.loc 4 81 0
 1963              		.pad #40
 1964 0aa0 28D04DE2 		sub	sp, sp, #40
 1965              	.LCFI18:
 1966              		.cfi_def_cfa_offset 64
 1967 0aa4 0320A0E1 		mov	r2, r3
 1968              	.L109:
 1969              	.LBB45:
 1970              	.LBB44:
 205:bellator_low_level.c **** 	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 1971              		.loc 4 205 0
 1972 0aa8 B818D2E1 		ldrh	r1, [r2, #136]
 1973 0aac 010B11E3 		tst	r1, #1024
 1974 0ab0 4C349FE5 		ldr	r3, .L120
 1975 0ab4 FBFFFF0A 		beq	.L109
 1976              		.cfi_offset 14, -4
 1977              		.cfi_offset 8, -8
 1978              		.cfi_offset 7, -12
 1979              		.cfi_offset 6, -16
 1980              		.cfi_offset 5, -20
 1981              		.cfi_offset 4, -24
 206:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 1982              		.loc 4 206 0
 1983 0ab8 0360A0E3 		mov	r6, #3
 207:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 1984              		.loc 4 207 0
 1985 0abc 5520E0E3 		mvn	r2, #85
 206:bellator_low_level.c **** 	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 1986              		.loc 4 206 0
 1987 0ac0 8060C3E5 		strb	r6, [r3, #128]
 207:bellator_low_level.c **** 	PLLFEED=0xAA;               // Validation sequence
 1988              		.loc 4 207 0
 1989 0ac4 8C20C3E5 		strb	r2, [r3, #140]
 208:bellator_low_level.c **** 	PLLFEED=0x55;               // Validation sequence
 1990              		.loc 4 208 0
 1991 0ac8 AB2082E2 		add	r2, r2, #171
 1992 0acc 8C20C3E5 		strb	r2, [r3, #140]
 1993              	.LBE44:
 1994              	.LBE45:
 1995              	.LBB46:
 1996              	.LBB47:
 222:bellator_low_level.c **** 	MAMTIM = 4; // 4 clock fetches
 1997              		.loc 4 222 0
 1998 0ad0 0420A0E3 		mov	r2, #4
 1999 0ad4 0420C3E5 		strb	r2, [r3, #4]
 227:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 2000              		.loc 4 227 0
 2001 0ad8 0220A0E3 		mov	r2, #2
 2002              	.LBE47:
 2003              	.LBE46:
 2004              	.LBB49:
 2005              	.LBB50:
 236:bellator_low_level.c **** 	APBDIV &= ~0x03;
 2006              		.loc 4 236 0
 2007 0adc 24549FE5 		ldr	r5, .L120+4
 2008              	.LBE50:
 2009              	.LBE49:
 2010              	.LBB52:
 2011              	.LBB48:
 227:bellator_low_level.c **** 	MAMCR = 2;	// MAM functions fully enabled
 2012              		.loc 4 227 0
 2013 0ae0 0020C3E5 		strb	r2, [r3, #0]
 2014              	.LBE48:
 2015              	.LBE52:
 2016              	.LBB53:
 2017              	.LBB51:
 236:bellator_low_level.c **** 	APBDIV &= ~0x03;
 2018              		.loc 4 236 0
 2019 0ae4 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 2020 0ae8 FC3003E2 		and	r3, r3, #252
 2021 0aec 0030C5E5 		strb	r3, [r5, #0]
 2022              	.LBE51:
 2023              	.LBE53:
  87:bellator_low_level.c **** 	logger_init(); // uart0
 2024              		.loc 4 87 0
 2025 0af0 FEFFFFEB 		bl	logger_init
 2026              	.LBB54:
 2027              	.LBB55:
  21:irq.c         **** 
  22:irq.c         **** static inline unsigned enableIRQ(void)
  23:irq.c         **** {
  24:irq.c         ****   unsigned _cpsr;
  25:irq.c         **** 
  26:irq.c         ****   _cpsr = asm_get_cpsr();
 2028              		.loc 2 26 0
 2029 0af4 48FDFFEB 		bl	asm_get_cpsr
 2030              	.LVL125:
 2031              	.LBE55:
 2032              	.LBE54:
 2033              	.LBB57:
 2034              	.LBB58:
 253:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 2035              		.loc 4 253 0
 2036 0af8 0C749FE5 		ldr	r7, .L120+8
 2037              	.LBE58:
 2038              	.LBE57:
 2039              	.LBB60:
 2040              	.LBB56:
  27:irq.c         ****   asm_set_cpsr(_cpsr & ~IRQ_MASK);
 2041              		.loc 2 27 0
 2042 0afc 8000C0E3 		bic	r0, r0, #128
 2043              	.LVL126:
 2044 0b00 47FDFFEB 		bl	asm_set_cpsr
 2045              	.LBE56:
 2046              	.LBE60:
 2047              	.LBB61:
 2048              	.LBB59:
 253:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 22; // CAP2.0
 2049              		.loc 4 253 0
 2050 0b04 043097E5 		ldr	r3, [r7, #4]
 2051 0b08 023583E3 		orr	r3, r3, #8388608
 2052 0b0c 043087E5 		str	r3, [r7, #4]
 254:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 24; // CAP2.1
 2053              		.loc 4 254 0
 2054 0b10 043097E5 		ldr	r3, [r7, #4]
 2055 0b14 023483E3 		orr	r3, r3, #33554432
 2056 0b18 043087E5 		str	r3, [r7, #4]
 255:bellator_low_level.c **** 	PINSEL1 |= 0x2 << 26; // CAP2.2
 2057              		.loc 4 255 0
 2058 0b1c 043097E5 		ldr	r3, [r7, #4]
 2059 0b20 023383E3 		orr	r3, r3, #134217728
 2060 0b24 043087E5 		str	r3, [r7, #4]
 256:bellator_low_level.c **** 	PINSEL1 |= 0x1 << 0;  // EINT0
 2061              		.loc 4 256 0
 2062 0b28 043097E5 		ldr	r3, [r7, #4]
 2063 0b2c 013083E3 		orr	r3, r3, #1
 2064 0b30 043087E5 		str	r3, [r7, #4]
 259:bellator_low_level.c **** 	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
 2065              		.loc 4 259 0
 2066 0b34 D4339FE5 		ldr	r3, .L120+12
 2067 0b38 B822D3E1 		ldrh	r2, [r3, #40]
 2068 0b3c 052082E3 		orr	r2, r2, #5
 2069 0b40 B822C3E1 		strh	r2, [r3, #40]	@ movhi
 260:bellator_low_level.c **** 	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
 2070              		.loc 4 260 0
 2071 0b44 B822D3E1 		ldrh	r2, [r3, #40]
 2072 0b48 282082E3 		orr	r2, r2, #40
 2073 0b4c B822C3E1 		strh	r2, [r3, #40]	@ movhi
 261:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 2074              		.loc 4 261 0
 2075 0b50 B822D3E1 		ldrh	r2, [r3, #40]
 262:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 2076              		.loc 4 262 0
 2077 0b54 0180A0E3 		mov	r8, #1
 261:bellator_low_level.c **** 	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
 2078              		.loc 4 261 0
 2079 0b58 052D82E3 		orr	r2, r2, #320
 2080 0b5c B822C3E1 		strh	r2, [r3, #40]	@ movhi
 262:bellator_low_level.c **** 	T2TCR = 1; //enable T2
 2081              		.loc 4 262 0
 2082 0b60 0480C3E5 		strb	r8, [r3, #4]
 265:bellator_low_level.c **** 	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
 2083              		.loc 4 265 0
 2084 0b64 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 2085 0b68 083083E1 		orr	r3, r3, r8
 2086 0b6c 4830C5E5 		strb	r3, [r5, #72]
 266:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
 2087              		.loc 4 266 0
 2088 0b70 4C30D5E5 		ldrb	r3, [r5, #76]	@ zero_extendqisi2
 2089 0b74 083083E1 		orr	r3, r3, r8
 2090 0b78 4C30C5E5 		strb	r3, [r5, #76]
 267:bellator_low_level.c **** 	EXTINT |= 0x1 << 0; // reset EINT0
 2091              		.loc 4 267 0
 2092 0b7c 4030D5E5 		ldrb	r3, [r5, #64]	@ zero_extendqisi2
 2093 0b80 083083E1 		orr	r3, r3, r8
 2094 0b84 4030C5E5 		strb	r3, [r5, #64]
 270:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 26;// Timer 2 as FIQ
 2095              		.loc 4 270 0
 2096 0b88 0040E0E3 		mvn	r4, #0
 2097 0b8c F33F14E5 		ldr	r3, [r4, #-4083]
 2098 0b90 013383E3 		orr	r3, r3, #67108864
 2099 0b94 F33F04E5 		str	r3, [r4, #-4083]
 271:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
 2100              		.loc 4 271 0
 2101 0b98 EF3F14E5 		ldr	r3, [r4, #-4079]
 2102 0b9c 013383E3 		orr	r3, r3, #67108864
 2103 0ba0 EF3F04E5 		str	r3, [r4, #-4079]
 272:bellator_low_level.c **** 	VICIntSelect |= 0x1 << 14;// EINT2 as FIQ
 2104              		.loc 4 272 0
 2105 0ba4 F33F14E5 		ldr	r3, [r4, #-4083]
 2106 0ba8 013983E3 		orr	r3, r3, #16384
 2107 0bac F33F04E5 		str	r3, [r4, #-4083]
 273:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
 2108              		.loc 4 273 0
 2109 0bb0 EF3F14E5 		ldr	r3, [r4, #-4079]
 2110 0bb4 013983E3 		orr	r3, r3, #16384
 2111 0bb8 EF3F04E5 		str	r3, [r4, #-4079]
 2112              	.LBE59:
 2113              	.LBE61:
 2114              	.LBB62:
 2115              	.LBB63:
 288:bellator_low_level.c **** 	i2c_init();
 2116              		.loc 4 288 0
 2117 0bbc FEFFFFEB 		bl	i2c_init
 290:bellator_low_level.c **** 	mpu_init();
 2118              		.loc 4 290 0
 2119 0bc0 FEFFFFEB 		bl	mpu_init
 294:bellator_low_level.c **** 	PINSEL0 |= 0x1 << 30;  // EINT2
 2120              		.loc 4 294 0
 2121 0bc4 003097E5 		ldr	r3, [r7, #0]
 2122 0bc8 013183E3 		orr	r3, r3, #1073741824
 2123 0bcc 003087E5 		str	r3, [r7, #0]
 297:bellator_low_level.c **** 	EXTMODE |= 0x1 << 2; // EINT2 is edge sensitive
 2124              		.loc 4 297 0
 2125 0bd0 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 2126 0bd4 043083E3 		orr	r3, r3, #4
 2127 0bd8 4830C5E5 		strb	r3, [r5, #72]
 298:bellator_low_level.c **** 	EXTPOLAR |= 0x1 << 2; // EINT2 is rising edge sensitive
 2128              		.loc 4 298 0
 2129 0bdc 4C30D5E5 		ldrb	r3, [r5, #76]	@ zero_extendqisi2
 2130 0be0 043083E3 		orr	r3, r3, #4
 2131 0be4 4C30C5E5 		strb	r3, [r5, #76]
 299:bellator_low_level.c **** 	EXTINT |= 0x1 << 2; // reset EINT2
 2132              		.loc 4 299 0
 2133 0be8 4030D5E5 		ldrb	r3, [r5, #64]	@ zero_extendqisi2
 2134 0bec 043083E3 		orr	r3, r3, #4
 2135 0bf0 4030C5E5 		strb	r3, [r5, #64]
 301:bellator_low_level.c **** 	VICVectAddr1 = (unsigned int) &imu_data_ready; //Setting the interrupt handler location
 2136              		.loc 4 301 0
 2137 0bf4 18339FE5 		ldr	r3, .L120+16
 2138 0bf8 FB3E04E5 		str	r3, [r4, #-3835]
 302:bellator_low_level.c **** 	VICVectCntl1 = 0x30; //Vectored Interrupt slot enabled with source #16 (EINT2)
 2139              		.loc 4 302 0
 2140 0bfc 3030A0E3 		mov	r3, #48
 2141 0c00 FB3D04E5 		str	r3, [r4, #-3579]
 303:bellator_low_level.c **** 	VICIntEnable |= 0x1 << 16; //source #16 enabled as FIQ or IRQ
 2142              		.loc 4 303 0
 2143 0c04 EF3F14E5 		ldr	r3, [r4, #-4079]
 2144 0c08 013883E3 		orr	r3, r3, #65536
 2145 0c0c EF3F04E5 		str	r3, [r4, #-4079]
 2146              	.LBE63:
 2147              	.LBE62:
 2148              	.LBB64:
 2149              	.LBB65:
 316:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 12; // AD0.0
 2150              		.loc 4 316 0
 2151 0c10 043097E5 		ldr	r3, [r7, #4]
 2152 0c14 033A83E3 		orr	r3, r3, #12288
 2153 0c18 043087E5 		str	r3, [r7, #4]
 317:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 14; // AD0.1
 2154              		.loc 4 317 0
 2155 0c1c 043097E5 		ldr	r3, [r7, #4]
 2156 0c20 033983E3 		orr	r3, r3, #49152
 2157 0c24 043087E5 		str	r3, [r7, #4]
 318:bellator_low_level.c **** 	PINSEL1 |= 0x3 << 16; // AD0.2
 2158              		.loc 4 318 0
 2159 0c28 043097E5 		ldr	r3, [r7, #4]
 2160 0c2c 033883E3 		orr	r3, r3, #196608
 2161 0c30 043087E5 		str	r3, [r7, #4]
 319:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 20; // AD0.3
 2162              		.loc 4 319 0
 2163 0c34 003097E5 		ldr	r3, [r7, #0]
 2164 0c38 033683E3 		orr	r3, r3, #3145728
 2165 0c3c 003087E5 		str	r3, [r7, #0]
 320:bellator_low_level.c **** 	PINSEL0 |= 0x3 << 22; // AD0.4
 2166              		.loc 4 320 0
 2167 0c40 003097E5 		ldr	r3, [r7, #0]
 2168 0c44 033583E3 		orr	r3, r3, #12582912
 2169 0c48 003087E5 		str	r3, [r7, #0]
 323:bellator_low_level.c **** 	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
 2170              		.loc 4 323 0
 2171 0c4c C4329FE5 		ldr	r3, .L120+20
 2172 0c50 002093E5 		ldr	r2, [r3, #0]
 2173 0c54 012882E3 		orr	r2, r2, #65536
 2174 0c58 002083E5 		str	r2, [r3, #0]
 324:bellator_low_level.c **** 	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
 2175              		.loc 4 324 0
 2176 0c5c 002093E5 		ldr	r2, [r3, #0]
 2177 0c60 032C82E3 		orr	r2, r2, #768
 2178 0c64 002083E5 		str	r2, [r3, #0]
 325:bellator_low_level.c **** 	ADCR |= 0x1F; // Read AD0.0 - AD0.4
 2179              		.loc 4 325 0
 2180 0c68 002093E5 		ldr	r2, [r3, #0]
 2181 0c6c 1F2082E3 		orr	r2, r2, #31
 2182 0c70 002083E5 		str	r2, [r3, #0]
 326:bellator_low_level.c **** 	ADCR |= 0x01 << 21; // The ADC is operational
 2183              		.loc 4 326 0
 2184 0c74 002093E5 		ldr	r2, [r3, #0]
 2185 0c78 022682E3 		orr	r2, r2, #2097152
 2186 0c7c 002083E5 		str	r2, [r3, #0]
 2187              	.LBE65:
 2188              	.LBE64:
 2189              	.LBB66:
 2190              	.LBB67:
 341:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 6;  // MAT0.0
 2191              		.loc 4 341 0
 2192 0c80 003097E5 		ldr	r3, [r7, #0]
 2193 0c84 803083E3 		orr	r3, r3, #128
 2194 0c88 003087E5 		str	r3, [r7, #0]
 342:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 10; // MAT0.1
 2195              		.loc 4 342 0
 2196 0c8c 003097E5 		ldr	r3, [r7, #0]
 2197 0c90 023B83E3 		orr	r3, r3, #2048
 2198 0c94 003087E5 		str	r3, [r7, #0]
 343:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 24; // MAT1.0
 2199              		.loc 4 343 0
 2200 0c98 003097E5 		ldr	r3, [r7, #0]
 2201 0c9c 023483E3 		orr	r3, r3, #33554432
 2202 0ca0 003087E5 		str	r3, [r7, #0]
 344:bellator_low_level.c **** 	PINSEL0 |= 0x2 << 26; // MAT1.1
 2203              		.loc 4 344 0
 2204 0ca4 003097E5 		ldr	r3, [r7, #0]
 2205 0ca8 023383E3 		orr	r3, r3, #134217728
 2206 0cac 003087E5 		str	r3, [r7, #0]
 347:bellator_low_level.c **** 	T0PR = 294; // 255 levels for T2TC in 5ms
 2207              		.loc 4 347 0
 2208 0cb0 64229FE5 		ldr	r2, .L120+24
 348:bellator_low_level.c **** 	T1PR = 294;
 2209              		.loc 4 348 0
 2210 0cb4 64329FE5 		ldr	r3, .L120+28
 347:bellator_low_level.c **** 	T0PR = 294; // 255 levels for T2TC in 5ms
 2211              		.loc 4 347 0
 2212 0cb8 64129FE5 		ldr	r1, .L120+32
 2213 0cbc 0C1082E5 		str	r1, [r2, #12]
 348:bellator_low_level.c **** 	T1PR = 294;
 2214              		.loc 4 348 0
 2215 0cc0 0C1083E5 		str	r1, [r3, #12]
 355:bellator_low_level.c **** 	T0PC = 0; // Prescale = 0
 2216              		.loc 4 355 0
 2217 0cc4 0010A0E3 		mov	r1, #0
 2218 0cc8 101082E5 		str	r1, [r2, #16]
 356:bellator_low_level.c **** 	T1PC = 0;
 2219              		.loc 4 356 0
 2220 0ccc 101083E5 		str	r1, [r3, #16]
 357:bellator_low_level.c **** 	T0TC = 0; // Counter = 0
 2221              		.loc 4 357 0
 2222 0cd0 081082E5 		str	r1, [r2, #8]
 358:bellator_low_level.c **** 	T1TC = 0;
 2223              		.loc 4 358 0
 2224 0cd4 081083E5 		str	r1, [r3, #8]
 360:bellator_low_level.c **** 	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
 2225              		.loc 4 360 0
 2226 0cd8 B401D2E1 		ldrh	r0, [r2, #20]
 2227 0cdc 010B80E3 		orr	r0, r0, #1024
 2228 0ce0 B401C2E1 		strh	r0, [r2, #20]	@ movhi
 361:bellator_low_level.c **** 	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
 2229              		.loc 4 361 0
 2230 0ce4 B401D3E1 		ldrh	r0, [r3, #20]
 2231 0ce8 010B80E3 		orr	r0, r0, #1024
 2232 0cec B401C3E1 		strh	r0, [r3, #20]	@ movhi
 362:bellator_low_level.c **** 	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
 2233              		.loc 4 362 0
 2234 0cf0 FF00A0E3 		mov	r0, #255
 2235 0cf4 240082E5 		str	r0, [r2, #36]
 363:bellator_low_level.c **** 	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
 2236              		.loc 4 363 0
 2237 0cf8 240083E5 		str	r0, [r3, #36]
 365:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
 2238              		.loc 4 365 0
 2239 0cfc 740092E5 		ldr	r0, [r2, #116]
 2240 0d00 080080E1 		orr	r0, r0, r8
 2241 0d04 740082E5 		str	r0, [r2, #116]
 366:bellator_low_level.c **** 	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
 2242              		.loc 4 366 0
 2243 0d08 740092E5 		ldr	r0, [r2, #116]
 2244 0d0c 020080E3 		orr	r0, r0, #2
 2245 0d10 740082E5 		str	r0, [r2, #116]
 367:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
 2246              		.loc 4 367 0
 2247 0d14 740093E5 		ldr	r0, [r3, #116]
 2248 0d18 080080E1 		orr	r0, r0, r8
 2249 0d1c 740083E5 		str	r0, [r3, #116]
 368:bellator_low_level.c **** 	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
 2250              		.loc 4 368 0
 2251 0d20 740093E5 		ldr	r0, [r3, #116]
 2252 0d24 020080E3 		orr	r0, r0, #2
 2253 0d28 740083E5 		str	r0, [r3, #116]
 370:bellator_low_level.c **** 	T0MR0 = 256; // initially LOW
 2254              		.loc 4 370 0
 2255 0d2c 010CA0E3 		mov	r0, #256
 2256 0d30 180082E5 		str	r0, [r2, #24]
 371:bellator_low_level.c **** 	T0MR1 = 256; // initially LOW
 2257              		.loc 4 371 0
 2258 0d34 1C0082E5 		str	r0, [r2, #28]
 372:bellator_low_level.c **** 	T1MR0 = 256; // initially LOW
 2259              		.loc 4 372 0
 2260 0d38 180083E5 		str	r0, [r3, #24]
 373:bellator_low_level.c **** 	T1MR1 = 256; // initially LOW
 2261              		.loc 4 373 0
 2262 0d3c 1C0083E5 		str	r0, [r3, #28]
 375:bellator_low_level.c **** 	T0TCR = 1; // enable T0
 2263              		.loc 4 375 0
 2264 0d40 0480C2E5 		strb	r8, [r2, #4]
 376:bellator_low_level.c **** 	T1TCR = 1; // enable T1
 2265              		.loc 4 376 0
 2266 0d44 0480C3E5 		strb	r8, [r3, #4]
 2267              	.LBE67:
 2268              	.LBE66:
 2269              	.LBB68:
 2270              	.LBB69:
 400:bellator_low_level.c **** 	PINSEL0 |= 0x05 << 16; // Set the pins function
 2271              		.loc 4 400 0
 2272 0d48 003097E5 		ldr	r3, [r7, #0]
 2273 0d4c 053883E3 		orr	r3, r3, #327680
 2274 0d50 003087E5 		str	r3, [r7, #0]
 401:bellator_low_level.c **** 	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 2275              		.loc 4 401 0
 2276 0d54 CC319FE5 		ldr	r3, .L120+36
 2277 0d58 0720A0E3 		mov	r2, #7
 2278 0d5c 0820C3E5 		strb	r2, [r3, #8]
 402:bellator_low_level.c **** 	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 2279              		.loc 4 402 0
 2280 0d60 7C20E0E3 		mvn	r2, #124
 2281 0d64 0C20C3E5 		strb	r2, [r3, #12]
 405:bellator_low_level.c **** 	U1DLL	 = 0x06; // DivisorLatchLow bit
 2282              		.loc 4 405 0
 2283 0d68 832082E2 		add	r2, r2, #131
 2284 0d6c 0020C3E5 		strb	r2, [r3, #0]
 406:bellator_low_level.c **** 	U1DLM	 = 0x00; // DivisorLatchHigh bit
 2285              		.loc 4 406 0
 2286 0d70 0410C3E5 		strb	r1, [r3, #4]
 407:bellator_low_level.c **** 	U1FDR	|= 0x05; // DivAddVal
 2287              		.loc 4 407 0
 2288 0d74 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2289 0d78 052082E3 		orr	r2, r2, #5
 2290 0d7c 2820C3E5 		strb	r2, [r3, #40]
 408:bellator_low_level.c **** 	U1FDR	|= 0x0E << 4; // MulVal = 14
 2291              		.loc 4 408 0
 2292 0d80 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2293 0d84 E02082E3 		orr	r2, r2, #224
 2294 0d88 2820C3E5 		strb	r2, [r3, #40]
 417:bellator_low_level.c **** 	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 2295              		.loc 4 417 0
 2296 0d8c 98219FE5 		ldr	r2, .L120+40
 415:bellator_low_level.c **** 	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 2297              		.loc 4 415 0
 2298 0d90 0C60C3E5 		strb	r6, [r3, #12]
 417:bellator_low_level.c **** 	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th ve
 2299              		.loc 4 417 0
 2300 0d94 F72E04E5 		str	r2, [r4, #-3831]
 418:bellator_low_level.c **** 	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 2301              		.loc 4 418 0
 2302 0d98 2720A0E3 		mov	r2, #39
 2303 0d9c F72D04E5 		str	r2, [r4, #-3575]
 419:bellator_low_level.c **** 	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 2304              		.loc 4 419 0
 2305 0da0 EF2F14E5 		ldr	r2, [r4, #-4079]
 2306 0da4 802082E3 		orr	r2, r2, #128
 2307 0da8 EF2F04E5 		str	r2, [r4, #-4079]
 421:bellator_low_level.c **** 	cmd_out.i = 0;
 2308              		.loc 4 421 0
 2309 0dac 7C219FE5 		ldr	r2, .L120+44
 2310 0db0 181082E5 		str	r1, [r2, #24]
 422:bellator_low_level.c **** 	cmd_in.i = 0;
 2311              		.loc 4 422 0
 2312 0db4 3C1082E5 		str	r1, [r2, #60]
 424:bellator_low_level.c **** 	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 2313              		.loc 4 424 0
 2314 0db8 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 2315 0dbc 2720CDE5 		strb	r2, [sp, #39]
 2316              	.LVL127:
 425:bellator_low_level.c **** 	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
 2317              		.loc 4 425 0
 2318 0dc0 0480C3E5 		strb	r8, [r3, #4]
 2319              	.LBE69:
 2320              	.LBE68:
 2321              	.LBB70:
 2322              	.LBB71:
  28:irq.c         ****   return _cpsr;
  29:irq.c         **** }
  30:irq.c         **** 
  31:irq.c         **** static inline unsigned disableIRQ(void)
  32:irq.c         **** {
  33:irq.c         ****   unsigned _cpsr;
  34:irq.c         **** 
  35:irq.c         ****   _cpsr = asm_get_cpsr();
  36:irq.c         ****   asm_set_cpsr(_cpsr | IRQ_MASK);
  37:irq.c         ****   return _cpsr;
  38:irq.c         **** }
  39:irq.c         **** 
  40:irq.c         **** static inline unsigned restoreIRQ(unsigned oldCPSR)
  41:irq.c         **** {
  42:irq.c         ****   unsigned _cpsr;
  43:irq.c         **** 
  44:irq.c         ****   _cpsr = asm_get_cpsr();
  45:irq.c         ****   asm_set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  46:irq.c         ****   return _cpsr;
  47:irq.c         **** }
  48:irq.c         **** 
  49:irq.c         **** static inline unsigned enableFIQ(void)
  50:irq.c         **** {
  51:irq.c         ****   unsigned _cpsr;
  52:irq.c         **** 
  53:irq.c         ****   _cpsr = asm_get_cpsr();
 2323              		.loc 2 53 0
 2324 0dc4 94FCFFEB 		bl	asm_get_cpsr
 2325              	.LVL128:
  54:irq.c         ****   asm_set_cpsr(_cpsr & ~FIQ_MASK);
 2326              		.loc 2 54 0
 2327 0dc8 4000C0E3 		bic	r0, r0, #64
 2328              	.LVL129:
 2329 0dcc 94FCFFEB 		bl	asm_set_cpsr
 2330              	.LBE71:
 2331              	.LBE70:
 100:bellator_low_level.c **** 	VICDefVectAddr = (unsigned int) &error;
 2332              		.loc 4 100 0
 2333 0dd0 5C319FE5 		ldr	r3, .L120+48
 2334 0dd4 CB3F04E5 		str	r3, [r4, #-4043]
 2335              	.LVL130:
 2336              	.L119:
 108:bellator_low_level.c **** 		if(imu_data_available) {
 2337              		.loc 4 108 0
 2338 0dd8 50319FE5 		ldr	r3, .L120+44
 2339 0ddc 1430D3E5 		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 2340 0de0 000053E3 		cmp	r3, #0
 2341 0de4 FBFFFF0A 		beq	.L119
 2342              	.LBB72:
 111:bellator_low_level.c **** 			mpu_clear_interrupt(&source);
 2343              		.loc 4 111 0
 2344 0de8 27008DE2 		add	r0, sp, #39
 2345 0dec FEFFFFEB 		bl	mpu_clear_interrupt
 2346              	.LVL131:
 117:bellator_low_level.c **** 			if (source & (0x1 << MPU6050_INTERRUPT_DATA_RDY_BIT)) {
 2347              		.loc 4 117 0
 2348 0df0 2730DDE5 		ldrb	r3, [sp, #39]	@ zero_extendqisi2
 2349              	.LVL132:
 2350 0df4 010013E3 		tst	r3, #1
 2351              	.LVL133:
 2352 0df8 3D00000A 		beq	.L111
 2353              	.LBB73:
 122:bellator_low_level.c **** 				mpu_get_FIFO_size(&size);
 2354              		.loc 4 122 0
 2355 0dfc 20008DE2 		add	r0, sp, #32
 2356 0e00 FEFFFFEB 		bl	mpu_get_FIFO_size
 2357              	.LVL134:
 128:bellator_low_level.c **** 				if (size > 840 || source & (0x1 << MPU6050_INTERRUPT_FIFO_OFLOW_BIT)) {
 2358              		.loc 4 128 0
 2359 0e04 20309DE5 		ldr	r3, [sp, #32]
 2360 0e08 D20F53E3 		cmp	r3, #840
 2361 0e0c 020000CA 		bgt	.L112
 2362              	.LVL135:
 128:bellator_low_level.c **** 				if (size > 840 || source & (0x1 << MPU6050_INTERRUPT_FIFO_OFLOW_BIT)) {
 2363              		.loc 4 128 0 is_stmt 0 discriminator 1
 2364 0e10 2730DDE5 		ldrb	r3, [sp, #39]	@ zero_extendqisi2
 2365              	.LVL136:
 2366 0e14 100013E3 		tst	r3, #16
 2367              	.LVL137:
 2368 0e18 3200000A 		beq	.L114
 2369              	.L112:
 130:bellator_low_level.c **** 					mpu_set_FIFO_enabled(0);
 2370              		.loc 4 130 0 is_stmt 1
 2371 0e1c 0000A0E3 		mov	r0, #0
 2372 0e20 FEFFFFEB 		bl	mpu_set_FIFO_enabled
 2373              	.LVL138:
 131:bellator_low_level.c **** 					mpu_reset_FIFO();
 2374              		.loc 4 131 0
 2375 0e24 FEFFFFEB 		bl	mpu_reset_FIFO
 132:bellator_low_level.c **** 					mpu_set_FIFO_enabled(1);
 2376              		.loc 4 132 0
 2377 0e28 0100A0E3 		mov	r0, #1
 2378 0e2c FEFFFFEB 		bl	mpu_set_FIFO_enabled
 133:bellator_low_level.c **** 					mpu_get_FIFO_size(&size);
 2379              		.loc 4 133 0
 2380 0e30 20008DE2 		add	r0, sp, #32
 2381 0e34 FEFFFFEB 		bl	mpu_get_FIFO_size
 2382 0e38 2A0000EA 		b	.L114
 2383              	.L116:
 2384              	.LBB74:
 140:bellator_low_level.c **** 					short imu_data_in_pos_tmp = (imu_data_in_pos + 1) % IMU_BUFF_SIZE;
 2385              		.loc 4 140 0
 2386 0e3c EC409FE5 		ldr	r4, .L120+44
 2387 0e40 B066D4E1 		ldrh	r6, [r4, #96]
 2388 0e44 016086E2 		add	r6, r6, #1
 2389 0e48 FF6006E2 		and	r6, r6, #255
 2390              	.LVL139:
 153:bellator_low_level.c **** 					mpu_get_FIFO_motion6(&(data->ax_h), &(data->ax_l), &(data->ay_h), &(data->ay_l), &(data->az_h)
 2391              		.loc 4 153 0
 2392 0e4c 0E50A0E3 		mov	r5, #14
 2393 0e50 960505E0 		mul	r5, r6, r5
 137:bellator_low_level.c **** 					size -= 12;
 2394              		.loc 4 137 0
 2395 0e54 0C3043E2 		sub	r3, r3, #12
 2396 0e58 20308DE5 		str	r3, [sp, #32]
 143:bellator_low_level.c **** 					if (imu_data_in_pos_tmp == imu_data_out_pos) {
 2397              		.loc 4 143 0
 2398 0e5c B236D4E1 		ldrh	r3, [r4, #98]
 2399 0e60 030056E1 		cmp	r6, r3
 146:bellator_low_level.c **** 						imu_data_out_pos = ++imu_data_out_pos % IMU_BUFF_SIZE;
 2400              		.loc 4 146 0
 2401 0e64 01308602 		addeq	r3, r6, #1
 2402 0e68 FF300302 		andeq	r3, r3, #255
 2403 0e6c B236C401 		streqh	r3, [r4, #98]	@ movhi
 2404              	.LVL140:
 153:bellator_low_level.c **** 					mpu_get_FIFO_motion6(&(data->ax_h), &(data->ax_l), &(data->ay_h), &(data->ay_l), &(data->az_h)
 2405              		.loc 4 153 0
 2406 0e70 C0309FE5 		ldr	r3, .L120+52
 2407 0e74 050083E0 		add	r0, r3, r5
 2408 0e78 042080E2 		add	r2, r0, #4
 2409 0e7c 00208DE5 		str	r2, [sp, #0]
 2410 0e80 052080E2 		add	r2, r0, #5
 2411 0e84 04208DE5 		str	r2, [sp, #4]
 2412 0e88 062080E2 		add	r2, r0, #6
 2413 0e8c 08208DE5 		str	r2, [sp, #8]
 2414 0e90 072080E2 		add	r2, r0, #7
 2415 0e94 0C208DE5 		str	r2, [sp, #12]
 2416 0e98 082085E2 		add	r2, r5, #8
 2417 0e9c 023083E0 		add	r3, r3, r2
 2418 0ea0 012083E2 		add	r2, r3, #1
 2419 0ea4 10308DE5 		str	r3, [sp, #16]
 2420 0ea8 14208DE5 		str	r2, [sp, #20]
 2421 0eac 022083E2 		add	r2, r3, #2
 2422 0eb0 033083E2 		add	r3, r3, #3
 2423 0eb4 18208DE5 		str	r2, [sp, #24]
 2424 0eb8 1C308DE5 		str	r3, [sp, #28]
 2425 0ebc 022080E2 		add	r2, r0, #2
 2426 0ec0 033080E2 		add	r3, r0, #3
 2427 0ec4 011080E2 		add	r1, r0, #1
 2428 0ec8 FEFFFFEB 		bl	mpu_get_FIFO_motion6
 155:bellator_low_level.c **** 					data->timestamp = timestamp++;
 2429              		.loc 4 155 0
 2430 0ecc 68309FE5 		ldr	r3, .L120+56
 2431 0ed0 B32094E1 		ldrh	r2, [r4, r3]
 2432 0ed4 055084E0 		add	r5, r4, r5
 2433 0ed8 B027C5E1 		strh	r2, [r5, #112]	@ movhi
 2434 0edc 012082E2 		add	r2, r2, #1
 2435 0ee0 B32084E1 		strh	r2, [r4, r3]	@ movhi
 174:bellator_low_level.c **** 					imu_data_in_pos = imu_data_in_pos_tmp;
 2436              		.loc 4 174 0
 2437 0ee4 B066C4E1 		strh	r6, [r4, #96]	@ movhi
 2438              	.LVL141:
 2439              	.L114:
 2440              	.LBE74:
 136:bellator_low_level.c **** 				while (size >= 12) {
 2441              		.loc 4 136 0 discriminator 1
 2442 0ee8 20309DE5 		ldr	r3, [sp, #32]
 2443              	.LVL142:
 2444 0eec 0B0053E3 		cmp	r3, #11
 2445 0ef0 D1FFFFCA 		bgt	.L116
 2446              	.LVL143:
 2447              	.L111:
 2448              	.LBE73:
 178:bellator_low_level.c **** 			imu_data_available = 0;
 2449              		.loc 4 178 0
 2450 0ef4 34309FE5 		ldr	r3, .L120+44
 2451              	.LVL144:
 2452 0ef8 0020A0E3 		mov	r2, #0
 2453 0efc 1420C3E5 		strb	r2, [r3, #20]
 2454 0f00 B4FFFFEA 		b	.L119
 2455              	.L121:
 2456              		.align	2
 2457              	.L120:
 2458 0f04 00C01FE0 		.word	-534790144
 2459 0f08 00C11FE0 		.word	-534789888
 2460 0f0c 00C002E0 		.word	-536690688
 2461 0f10 000007E0 		.word	-536412160
 2462 0f14 00000000 		.word	imu_data_ready
 2463 0f18 004003E0 		.word	-536657920
 2464 0f1c 004000E0 		.word	-536854528
 2465 0f20 008000E0 		.word	-536838144
 2466 0f24 26010000 		.word	294
 2467 0f28 000001E0 		.word	-536805376
 2468 0f2c 00000000 		.word	protocol_in
 2469 0f30 00000000 		.word	.LANCHOR0
 2470 0f34 00000000 		.word	error
 2471 0f38 64000000 		.word	.LANCHOR0+100
 2472 0f3c 640E0000 		.word	3684
 2473              	.LBE72:
 2474              		.cfi_endproc
 2475              	.LFE42:
 2476              		.fnend
 2478              		.align	2
 2479              		.global	encoder_pulse_in_isr
 2481              	encoder_pulse_in_isr:
 2482              		.fnstart
 2483              	.LFB52:
 536:bellator_low_level.c **** void encoder_pulse_in_isr(void) {
 2484              		.loc 4 536 0
 2485              		.cfi_startproc
 2486              		@ Fast Interrupt Service Routine.
 2487              		@ args = 0, pretend = 0, frame = 0
 2488              		@ frame_needed = 0, uses_anonymous_args = 0
 2489              		@ link register save eliminated.
 2490 0f40 0E002DE9 		stmfd	sp!, {r1, r2, r3}
 2491              		.save {r1, r2, r3}
 2492              	.LCFI19:
 2493              		.cfi_def_cfa_offset 12
 540:bellator_low_level.c **** 	const unsigned short ir = T2IR;
 2494              		.loc 4 540 0
 2495 0f44 84309FE5 		ldr	r3, .L128
 2496              		.cfi_offset 3, -4
 2497              		.cfi_offset 2, -8
 2498              		.cfi_offset 1, -12
 2499 0f48 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 542:bellator_low_level.c **** 	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
 2500              		.loc 4 542 0
 2501 0f4c 100012E3 		tst	r2, #16
 2502 0f50 0600000A 		beq	.L123
 544:bellator_low_level.c **** 		encoder_count[0]++;
 2503              		.loc 4 544 0
 2504 0f54 78209FE5 		ldr	r2, .L128+4
 2505 0f58 681E92E5 		ldr	r1, [r2, #3688]
 2506 0f5c 011081E2 		add	r1, r1, #1
 2507 0f60 681E82E5 		str	r1, [r2, #3688]
 545:bellator_low_level.c **** 		T2IR |= 0x1 << 4; // reset CAP2.0
 2508              		.loc 4 545 0
 2509 0f64 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2510 0f68 102082E3 		orr	r2, r2, #16
 2511 0f6c 030000EA 		b	.L127
 2512              	.L123:
 547:bellator_low_level.c **** 	else if (ir & (0x1 << 5)) { //CAP2.1 left encoder
 2513              		.loc 4 547 0
 2514 0f70 200012E3 		tst	r2, #32
 2515 0f74 0300000A 		beq	.L125
 550:bellator_low_level.c **** 		T2IR |= 0x1 << 5; // reset CAP2.1
 2516              		.loc 4 550 0
 2517 0f78 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2518 0f7c 202082E3 		orr	r2, r2, #32
 2519              	.L127:
 2520 0f80 0020C3E5 		strb	r2, [r3, #0]
 2521 0f84 0C0000EA 		b	.L124
 2522              	.L125:
 552:bellator_low_level.c **** 	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
 2523              		.loc 4 552 0
 2524 0f88 400012E3 		tst	r2, #64
 2525 0f8c 0600000A 		beq	.L126
 554:bellator_low_level.c **** 		encoder_count[1]++;
 2526              		.loc 4 554 0
 2527 0f90 3C209FE5 		ldr	r2, .L128+4
 2528 0f94 6C1E92E5 		ldr	r1, [r2, #3692]
 2529 0f98 011081E2 		add	r1, r1, #1
 2530 0f9c 6C1E82E5 		str	r1, [r2, #3692]
 555:bellator_low_level.c **** 		T2IR |= 0x1 << 6; // reset CAP2.1
 2531              		.loc 4 555 0
 2532 0fa0 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2533 0fa4 402082E3 		orr	r2, r2, #64
 2534 0fa8 F4FFFFEA 		b	.L127
 2535              	.L126:
 560:bellator_low_level.c **** 		EXTINT |= 0x1 << 0; // reset EINT0
 2536              		.loc 4 560 0
 2537 0fac 24309FE5 		ldr	r3, .L128+8
 2538 0fb0 4020D3E5 		ldrb	r2, [r3, #64]	@ zero_extendqisi2
 2539 0fb4 012082E3 		orr	r2, r2, #1
 2540 0fb8 4020C3E5 		strb	r2, [r3, #64]
 2541              	.L124:
 565:bellator_low_level.c **** 	VICVectAddr = 0;
 2542              		.loc 4 565 0
 2543 0fbc 0020A0E3 		mov	r2, #0
 2544 0fc0 0030E0E3 		mvn	r3, #0
 2545 0fc4 CF2F03E5 		str	r2, [r3, #-4047]
 566:bellator_low_level.c **** }
 2546              		.loc 4 566 0
 2547 0fc8 0E00BDE8 		ldmfd	sp!, {r1, r2, r3}
 2548 0fcc 04F05EE2 		subs	pc, lr, #4
 2549              	.L129:
 2550              		.align	2
 2551              	.L128:
 2552 0fd0 000007E0 		.word	-536412160
 2553 0fd4 00000000 		.word	.LANCHOR0
 2554 0fd8 00C11FE0 		.word	-534789888
 2555              		.cfi_endproc
 2556              	.LFE52:
 2557              		.fnend
 2559              		.align	2
 2560              		.global	get_ir_sensor_data
 2562              	get_ir_sensor_data:
 2563              		.fnstart
 2564              	.LFB55:
 590:bellator_low_level.c **** 
 591:bellator_low_level.c **** /**
 592:bellator_low_level.c ****  * Return the value read from the i'th sensor
 593:bellator_low_level.c ****  */
 594:bellator_low_level.c **** int get_ir_sensor_data(unsigned short i) {
 2565              		.loc 4 594 0
 2566              		.cfi_startproc
 2567              		@ Function supports interworking.
 2568              		@ args = 0, pretend = 0, frame = 0
 2569              		@ frame_needed = 0, uses_anonymous_args = 0
 2570              		@ link register save eliminated.
 2571              	.LVL145:
 595:bellator_low_level.c **** 
 596:bellator_low_level.c **** 	int val = 0;
 597:bellator_low_level.c **** 	switch (i) {
 2572              		.loc 4 597 0
 2573 0fdc C30040E2 		sub	r0, r0, #195
 2574              	.LVL146:
 2575 0fe0 040050E3 		cmp	r0, #4
 2576 0fe4 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 2577 0fe8 1D0000EA 		b	.L138
 2578              	.L137:
 2579 0fec 00100000 		.word	.L132
 2580 0ff0 10100000 		.word	.L133
 2581 0ff4 20100000 		.word	.L134
 2582 0ff8 30100000 		.word	.L135
 2583 0ffc 40100000 		.word	.L136
 2584              	.L132:
 598:bellator_low_level.c **** 	case IR_L:
 599:bellator_low_level.c **** 		while(ADDR0 & ((0x1 << 31) == 0));
 2585              		.loc 4 599 0 discriminator 1
 2586 1000 64309FE5 		ldr	r3, .L140
 2587 1004 102093E5 		ldr	r2, [r3, #16]
 600:bellator_low_level.c **** 		val = (ADDR0 >> 6) & 0x3FF;
 2588              		.loc 4 600 0 discriminator 1
 2589 1008 100093E5 		ldr	r0, [r3, #16]
 2590 100c 0E0000EA 		b	.L139
 2591              	.L133:
 601:bellator_low_level.c **** 		val >>= 0x2; // they want a value from 1 to 255
 602:bellator_low_level.c **** 		val += (val == 0);
 603:bellator_low_level.c **** 		break;
 604:bellator_low_level.c **** 	case IR_ML:
 605:bellator_low_level.c **** 		while(ADDR1 & ((0x1 << 31) == 0));
 2592              		.loc 4 605 0 discriminator 1
 2593 1010 54309FE5 		ldr	r3, .L140
 2594 1014 142093E5 		ldr	r2, [r3, #20]
 606:bellator_low_level.c **** 		val = (ADDR1 >> 6) & 0x3FF;
 2595              		.loc 4 606 0 discriminator 1
 2596 1018 140093E5 		ldr	r0, [r3, #20]
 2597 101c 0A0000EA 		b	.L139
 2598              	.L134:
 607:bellator_low_level.c **** 		val >>= 0x2; // they want a value from 1 to 255
 608:bellator_low_level.c **** 		val += (val == 0);
 609:bellator_low_level.c **** 		break;
 610:bellator_low_level.c **** 	case IR_M:
 611:bellator_low_level.c **** 		while(ADDR2 & ((0x1 << 31) == 0));
 2599              		.loc 4 611 0 discriminator 1
 2600 1020 44309FE5 		ldr	r3, .L140
 2601 1024 182093E5 		ldr	r2, [r3, #24]
 612:bellator_low_level.c **** 		val = (ADDR2 >> 6) & 0x3FF;
 2602              		.loc 4 612 0 discriminator 1
 2603 1028 180093E5 		ldr	r0, [r3, #24]
 2604 102c 060000EA 		b	.L139
 2605              	.L135:
 613:bellator_low_level.c **** 		val >>= 0x2; // they want a value from 1 to 255
 614:bellator_low_level.c **** 		val += (val == 0);
 615:bellator_low_level.c **** 		break;
 616:bellator_low_level.c **** 	case IR_MR:
 617:bellator_low_level.c **** 		while(ADDR3 & ((0x1 << 31) == 0));
 2606              		.loc 4 617 0 discriminator 1
 2607 1030 34309FE5 		ldr	r3, .L140
 2608 1034 1C2093E5 		ldr	r2, [r3, #28]
 618:bellator_low_level.c **** 		val = (ADDR3 >> 6) & 0x3FF;
 2609              		.loc 4 618 0 discriminator 1
 2610 1038 1C0093E5 		ldr	r0, [r3, #28]
 2611 103c 020000EA 		b	.L139
 2612              	.L136:
 619:bellator_low_level.c **** 		val >>= 0x2; // they want a value from 1 to 255
 620:bellator_low_level.c **** 		val += (val == 0);
 621:bellator_low_level.c **** 		break;
 622:bellator_low_level.c **** 	case IR_R:
 623:bellator_low_level.c **** 		while(ADDR4 & ((0x1 << 31) == 0));
 2613              		.loc 4 623 0 discriminator 1
 2614 1040 24309FE5 		ldr	r3, .L140
 2615 1044 202093E5 		ldr	r2, [r3, #32]
 624:bellator_low_level.c **** 		val = (ADDR4 >> 6) & 0x3FF;
 2616              		.loc 4 624 0 discriminator 1
 2617 1048 200093E5 		ldr	r0, [r3, #32]
 2618              	.L139:
 2619 104c 0008A0E1 		mov	r0, r0, asl #16
 2620              	.LVL147:
 625:bellator_low_level.c **** 		val >>= 0x2; // they want a value from 1 to 255
 626:bellator_low_level.c **** 		val += (val == 0);
 2621              		.loc 4 626 0 discriminator 1
 2622 1050 200CB0E1 		movs	r0, r0, lsr #24
 2623              	.LVL148:
 2624 1054 0030A013 		movne	r3, #0
 2625 1058 0130A003 		moveq	r3, #1
 2626 105c 000083E0 		add	r0, r3, r0
 2627              	.LVL149:
 627:bellator_low_level.c **** 		break;
 2628              		.loc 4 627 0 discriminator 1
 2629 1060 1EFF2FE1 		bx	lr
 2630              	.LVL150:
 2631              	.L138:
 596:bellator_low_level.c **** 	int val = 0;
 2632              		.loc 4 596 0
 2633 1064 0000A0E3 		mov	r0, #0
 2634              	.LVL151:
 628:bellator_low_level.c **** 	}
 629:bellator_low_level.c **** 
 630:bellator_low_level.c **** 	return val;
 631:bellator_low_level.c **** }
 2635              		.loc 4 631 0
 2636 1068 1EFF2FE1 		bx	lr
 2637              	.L141:
 2638              		.align	2
 2639              	.L140:
 2640 106c 004003E0 		.word	-536657920
 2641              		.cfi_endproc
 2642              	.LFE55:
 2643              		.fnend
 2645              		.align	2
 2646              		.global	get_encoder_count
 2648              	get_encoder_count:
 2649              		.fnstart
 2650              	.LFB56:
 632:bellator_low_level.c **** 
 633:bellator_low_level.c **** 
 634:bellator_low_level.c **** 
 635:bellator_low_level.c **** /**
 636:bellator_low_level.c ****  * Return the count value read from the i'th sensor
 637:bellator_low_level.c ****  */
 638:bellator_low_level.c **** int get_encoder_count(unsigned short i) {
 2651              		.loc 4 638 0
 2652              		.cfi_startproc
 2653              		@ Function supports interworking.
 2654              		@ args = 0, pretend = 0, frame = 0
 2655              		@ frame_needed = 0, uses_anonymous_args = 0
 2656              		@ link register save eliminated.
 2657              	.LVL152:
 639:bellator_low_level.c **** 	unsigned int val, res;
 640:bellator_low_level.c **** 	val = encoder_count[i - ENCODER_L];
 2658              		.loc 4 640 0
 2659 1070 18309FE5 		ldr	r3, .L143
 2660 1074 C10040E2 		sub	r0, r0, #193
 2661              	.LVL153:
 2662 1078 003183E0 		add	r3, r3, r0, asl #2
 2663 107c 682E93E5 		ldr	r2, [r3, #3688]
 2664              	.LVL154:
 641:bellator_low_level.c **** 	res = val - sent_encoder_count[i - ENCODER_L];
 2665              		.loc 4 641 0
 2666 1080 700E93E5 		ldr	r0, [r3, #3696]
 2667              	.LVL155:
 642:bellator_low_level.c **** 	sent_encoder_count[i - ENCODER_L] = val;
 2668              		.loc 4 642 0
 2669 1084 702E83E5 		str	r2, [r3, #3696]
 643:bellator_low_level.c **** 	return res;
 644:bellator_low_level.c **** }
 2670              		.loc 4 644 0
 2671 1088 020060E0 		rsb	r0, r0, r2
 2672 108c 1EFF2FE1 		bx	lr
 2673              	.L144:
 2674              		.align	2
 2675              	.L143:
 2676 1090 00000000 		.word	.LANCHOR0
 2677              		.cfi_endproc
 2678              	.LFE56:
 2679              		.fnend
 2681              		.align	2
 2682              		.global	set_wheel_pwm
 2684              	set_wheel_pwm:
 2685              		.fnstart
 2686              	.LFB57:
 645:bellator_low_level.c **** 
 646:bellator_low_level.c **** /**
 647:bellator_low_level.c ****  * Set the output pwm value
 648:bellator_low_level.c ****  */
 649:bellator_low_level.c **** void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel) {
 2687              		.loc 4 649 0
 2688              		.cfi_startproc
 2689              		@ Function supports interworking.
 2690              		@ args = 0, pretend = 0, frame = 0
 2691              		@ frame_needed = 0, uses_anonymous_args = 0
 2692              		@ link register save eliminated.
 2693              	.LVL156:
 650:bellator_low_level.c **** 
 651:bellator_low_level.c **** 	if (right_wheel & PWM_DIR) { // Forward
 2694              		.loc 4 651 0
 2695 1094 800011E3 		tst	r1, #128
 652:bellator_low_level.c **** 		T0MR2 = 256;
 653:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 2696              		.loc 4 653 0
 2697 1098 8010C113 		bicne	r1, r1, #128
 2698              	.LVL157:
 2699 109c 54309FE5 		ldr	r3, .L150
 2700 10a0 80106112 		rsbne	r1, r1, #128
 654:bellator_low_level.c **** 	} else { // Backwards
 655:bellator_low_level.c **** 		T0MR1 = 256;
 656:bellator_low_level.c **** 		T0MR2 = 256 - right_wheel*2;
 2701              		.loc 4 656 0
 2702 10a4 80106102 		rsbeq	r1, r1, #128
 2703 10a8 012CA0E3 		mov	r2, #256
 653:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 2704              		.loc 4 653 0
 2705 10ac 8110A011 		movne	r1, r1, asl #1
 2706              		.loc 4 656 0
 2707 10b0 8110A001 		moveq	r1, r1, asl #1
 652:bellator_low_level.c **** 		T0MR2 = 256;
 2708              		.loc 4 652 0
 2709 10b4 20208315 		strne	r2, [r3, #32]
 655:bellator_low_level.c **** 		T0MR1 = 256;
 2710              		.loc 4 655 0
 2711 10b8 1C208305 		streq	r2, [r3, #28]
 653:bellator_low_level.c **** 		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
 2712              		.loc 4 653 0
 2713 10bc 1C108315 		strne	r1, [r3, #28]
 2714              		.loc 4 656 0
 2715 10c0 20108305 		streq	r1, [r3, #32]
 657:bellator_low_level.c **** 	}
 658:bellator_low_level.c **** 
 659:bellator_low_level.c **** 	if (left_wheel & PWM_DIR) { // Forward
 2716              		.loc 4 659 0
 2717 10c4 800010E3 		tst	r0, #128
 660:bellator_low_level.c **** 		T1MR0 = 256;
 661:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 2718              		.loc 4 661 0
 2719 10c8 8000C013 		bicne	r0, r0, #128
 2720              	.LVL158:
 2721 10cc 28309FE5 		ldr	r3, .L150+4
 2722 10d0 80006012 		rsbne	r0, r0, #128
 662:bellator_low_level.c **** 	} else { // Backwards
 663:bellator_low_level.c **** 		T1MR1 = 256;
 664:bellator_low_level.c **** 		T1MR0 = 256 - left_wheel*2;
 2723              		.loc 4 664 0
 2724 10d4 80006002 		rsbeq	r0, r0, #128
 2725 10d8 012CA0E3 		mov	r2, #256
 661:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 2726              		.loc 4 661 0
 2727 10dc 8000A011 		movne	r0, r0, asl #1
 2728              		.loc 4 664 0
 2729 10e0 8000A001 		moveq	r0, r0, asl #1
 660:bellator_low_level.c **** 		T1MR0 = 256;
 2730              		.loc 4 660 0
 2731 10e4 18208315 		strne	r2, [r3, #24]
 663:bellator_low_level.c **** 		T1MR1 = 256;
 2732              		.loc 4 663 0
 2733 10e8 1C208305 		streq	r2, [r3, #28]
 661:bellator_low_level.c **** 		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
 2734              		.loc 4 661 0
 2735 10ec 1C008315 		strne	r0, [r3, #28]
 2736              		.loc 4 664 0
 2737 10f0 18008305 		streq	r0, [r3, #24]
 2738 10f4 1EFF2FE1 		bx	lr
 2739              	.L151:
 2740              		.align	2
 2741              	.L150:
 2742 10f8 004000E0 		.word	-536854528
 2743 10fc 008000E0 		.word	-536838144
 2744              		.cfi_endproc
 2745              	.LFE57:
 2746              		.fnend
 2748              		.align	2
 2749              		.global	protocol_in
 2751              	protocol_in:
 2752              		.fnstart
 2753              	.LFB51:
 436:bellator_low_level.c **** void protocol_in(void){
 2754              		.loc 4 436 0
 2755              		.cfi_startproc
 2756              		@ Interrupt Service Routine.
 2757              		@ args = 0, pretend = 0, frame = 8
 2758              		@ frame_needed = 0, uses_anonymous_args = 0
 2759 1100 04E04EE2 		sub	lr, lr, #4
 2760 1104 1F502DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, ip, lr}
 2761              		.save {r0, r1, r2, r3, r4, ip, lr}
 2762              	.LCFI20:
 2763              		.cfi_def_cfa_offset 28
 2764              		.pad #12
 2765 1108 0CD04DE2 		sub	sp, sp, #12
 2766              	.LCFI21:
 2767              		.cfi_def_cfa_offset 40
 444:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 2768              		.loc 4 444 0
 2769 110c 8B0000EA 		b	.L168
 2770              		.cfi_offset 14, -4
 2771              		.cfi_offset 12, -8
 2772              		.cfi_offset 4, -12
 2773              		.cfi_offset 3, -16
 2774              		.cfi_offset 2, -20
 2775              		.cfi_offset 1, -24
 2776              		.cfi_offset 0, -28
 2777              	.LVL159:
 2778              	.L166:
 445:bellator_low_level.c **** 		switch (iir & 0x0E) {
 2779              		.loc 4 445 0
 2780 1110 0620DDE5 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 2781 1114 0E2002E2 		and	r2, r2, #14
 2782              	.LVL160:
 2783 1118 0C0052E3 		cmp	r2, #12
 2784 111c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 2785 1120 860000EA 		b	.L168
 2786              	.L159:
 2787 1124 38130000 		.word	.L155
 2788 1128 40130000 		.word	.L168
 2789 112c 2C130000 		.word	.L156
 2790 1130 40130000 		.word	.L168
 2791 1134 60110000 		.word	.L157
 2792 1138 40130000 		.word	.L168
 2793 113c 58110000 		.word	.L158
 2794 1140 40130000 		.word	.L168
 2795 1144 40130000 		.word	.L168
 2796 1148 40130000 		.word	.L168
 2797 114c 40130000 		.word	.L168
 2798 1150 40130000 		.word	.L168
 2799 1154 60110000 		.word	.L157
 2800              	.L158:
 447:bellator_low_level.c **** 			dummy = U1LSR; // Just clear the interrupt source
 2801              		.loc 4 447 0
 2802 1158 1430D3E5 		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 2803 115c 760000EA 		b	.L169
 2804              	.L157:
 452:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 2805              		.loc 4 452 0
 2806 1160 04429FE5 		ldr	r4, .L170
 2807 1164 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2808 1168 3C2094E5 		ldr	r2, [r4, #60]
 2809 116c FF3003E2 		and	r3, r3, #255
 2810 1170 021084E0 		add	r1, r4, r2
 455:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 2811              		.loc 4 455 0
 2812 1174 FE0053E3 		cmp	r3, #254
 452:bellator_low_level.c **** 			cmd_in.buff[cmd_in.i] = U1RBR;
 2813              		.loc 4 452 0
 2814 1178 4030C1E5 		strb	r3, [r1, #64]
 455:bellator_low_level.c **** 			if (cmd_in.buff[cmd_in.i] == END_CMD) {
 2815              		.loc 4 455 0
 2816 117c 6400001A 		bne	.L161
 457:bellator_low_level.c **** 				if (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] == ENGINES) {
 2817              		.loc 4 457 0
 2818 1180 023042E2 		sub	r3, r2, #2
 2819 1184 1F3003E2 		and	r3, r3, #31
 2820 1188 033084E0 		add	r3, r4, r3
 2821 118c 4030D3E5 		ldrb	r3, [r3, #64]	@ zero_extendqisi2
 2822 1190 B00053E3 		cmp	r3, #176
 2823 1194 013042E2 		sub	r3, r2, #1
 2824 1198 0700001A 		bne	.L162
 459:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)]));
 2825              		.loc 4 459 0
 2826 119c 1F2002E2 		and	r2, r2, #31
 458:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]),
 2827              		.loc 4 458 0
 2828 11a0 1F3003E2 		and	r3, r3, #31
 2829 11a4 033084E0 		add	r3, r4, r3
 459:bellator_low_level.c **** 								(unsigned short) (cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)]));
 2830              		.loc 4 459 0
 2831 11a8 024084E0 		add	r4, r4, r2
 458:bellator_low_level.c **** 					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]),
 2832              		.loc 4 458 0
 2833 11ac 4000D3E5 		ldrb	r0, [r3, #64]	@ zero_extendqisi2
 2834 11b0 4010D4E5 		ldrb	r1, [r4, #64]	@ zero_extendqisi2
 2835 11b4 FEFFFFEB 		bl	set_wheel_pwm
 2836 11b8 550000EA 		b	.L161
 2837              	.L162:
 462:bellator_low_level.c **** 				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
 2838              		.loc 4 462 0
 2839 11bc 1F3003E2 		and	r3, r3, #31
 2840 11c0 033084E0 		add	r3, r4, r3
 2841 11c4 4030D3E5 		ldrb	r3, [r3, #64]	@ zero_extendqisi2
 2842 11c8 A00053E3 		cmp	r3, #160
 2843 11cc 5000001A 		bne	.L161
 2844              	.LBB81:
 465:bellator_low_level.c **** 					int count = get_encoder_count(ENCODER_L);
 2845              		.loc 4 465 0
 2846 11d0 C100A0E3 		mov	r0, #193
 2847 11d4 FEFFFFEB 		bl	get_encoder_count
 2848              	.LVL161:
 466:bellator_low_level.c **** 					cmd_out.buff[0] = (count >> 0x8) & 0xFF;
 2849              		.loc 4 466 0
 2850 11d8 4034A0E1 		mov	r3, r0, asr #8
 2851 11dc 1C30C4E5 		strb	r3, [r4, #28]
 467:bellator_low_level.c **** 					cmd_out.buff[1] = count & 0xFF;
 2852              		.loc 4 467 0
 2853 11e0 1D00C4E5 		strb	r0, [r4, #29]
 468:bellator_low_level.c **** 					count = get_encoder_count(ENCODER_R);
 2854              		.loc 4 468 0
 2855 11e4 C200A0E3 		mov	r0, #194
 2856              	.LVL162:
 2857 11e8 FEFFFFEB 		bl	get_encoder_count
 2858              	.LVL163:
 469:bellator_low_level.c **** 					cmd_out.buff[2] = (count >> 0x8) & 0xFF;
 2859              		.loc 4 469 0
 2860 11ec 4034A0E1 		mov	r3, r0, asr #8
 2861 11f0 1E30C4E5 		strb	r3, [r4, #30]
 470:bellator_low_level.c **** 					cmd_out.buff[3] = count & 0xFF;
 2862              		.loc 4 470 0
 2863 11f4 1F00C4E5 		strb	r0, [r4, #31]
 472:bellator_low_level.c **** 					char val = get_ir_sensor_data(IR_L);
 2864              		.loc 4 472 0
 2865 11f8 C300A0E3 		mov	r0, #195
 2866              	.LVL164:
 2867 11fc FEFFFFEB 		bl	get_ir_sensor_data
 2868              	.LVL165:
 2869 1200 2000C4E5 		strb	r0, [r4, #32]
 474:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_ML);
 2870              		.loc 4 474 0
 2871 1204 C400A0E3 		mov	r0, #196
 2872              	.LVL166:
 2873 1208 FEFFFFEB 		bl	get_ir_sensor_data
 2874              	.LVL167:
 2875 120c 2100C4E5 		strb	r0, [r4, #33]
 476:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_M);
 2876              		.loc 4 476 0
 2877 1210 C500A0E3 		mov	r0, #197
 2878              	.LVL168:
 2879 1214 FEFFFFEB 		bl	get_ir_sensor_data
 2880              	.LVL169:
 2881 1218 2200C4E5 		strb	r0, [r4, #34]
 478:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_MR);
 2882              		.loc 4 478 0
 2883 121c C600A0E3 		mov	r0, #198
 2884              	.LVL170:
 2885 1220 FEFFFFEB 		bl	get_ir_sensor_data
 2886              	.LVL171:
 2887 1224 2300C4E5 		strb	r0, [r4, #35]
 480:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_R);
 2888              		.loc 4 480 0
 2889 1228 C700A0E3 		mov	r0, #199
 2890              	.LVL172:
 2891 122c FEFFFFEB 		bl	get_ir_sensor_data
 2892              	.LVL173:
 484:bellator_low_level.c **** 					if (imu_data_out_pos != imu_data_in_pos) {
 2893              		.loc 4 484 0
 2894 1230 B236D4E1 		ldrh	r3, [r4, #98]
 2895 1234 B026D4E1 		ldrh	r2, [r4, #96]
 2896 1238 030052E1 		cmp	r2, r3
 485:bellator_low_level.c **** 						imu_data_out_pos = ++imu_data_out_pos % IMU_BUFF_SIZE;
 2897              		.loc 4 485 0
 2898 123c 01308312 		addne	r3, r3, #1
 2899 1240 FF300312 		andne	r3, r3, #255
 2900 1244 B236C411 		strneh	r3, [r4, #98]	@ movhi
 488:bellator_low_level.c **** 					data = &(imu_data_buff[imu_data_out_pos]);
 2901              		.loc 4 488 0
 2902 1248 1C319FE5 		ldr	r3, .L170
 2903 124c B226D3E1 		ldrh	r2, [r3, #98]
 2904              	.LVL174:
 490:bellator_low_level.c **** 					cmd_out.buff[9] = data->ax_h;
 2905              		.loc 4 490 0
 2906 1250 0E10A0E3 		mov	r1, #14
 2907 1254 923121E0 		mla	r1, r2, r1, r3
 480:bellator_low_level.c **** 					val = get_ir_sensor_data(IR_R);
 2908              		.loc 4 480 0
 2909 1258 2400C4E5 		strb	r0, [r4, #36]
 490:bellator_low_level.c **** 					cmd_out.buff[9] = data->ax_h;
 2910              		.loc 4 490 0
 2911 125c 6400D1E5 		ldrb	r0, [r1, #100]	@ zero_extendqisi2
 2912              	.LVL175:
 2913 1260 2500C3E5 		strb	r0, [r3, #37]
 491:bellator_low_level.c **** 					cmd_out.buff[10] = data->ax_l;
 2914              		.loc 4 491 0
 2915 1264 6500D1E5 		ldrb	r0, [r1, #101]	@ zero_extendqisi2
 2916 1268 2600C3E5 		strb	r0, [r3, #38]
 492:bellator_low_level.c **** 					cmd_out.buff[11] = data->ay_h;
 2917              		.loc 4 492 0
 2918 126c 6600D1E5 		ldrb	r0, [r1, #102]	@ zero_extendqisi2
 2919 1270 2700C3E5 		strb	r0, [r3, #39]
 493:bellator_low_level.c **** 					cmd_out.buff[12] = data->ay_l;
 2920              		.loc 4 493 0
 2921 1274 6700D1E5 		ldrb	r0, [r1, #103]	@ zero_extendqisi2
 2922 1278 2800C3E5 		strb	r0, [r3, #40]
 494:bellator_low_level.c **** 					cmd_out.buff[13] = data->az_h;
 2923              		.loc 4 494 0
 2924 127c 6800D1E5 		ldrb	r0, [r1, #104]	@ zero_extendqisi2
 2925 1280 2900C3E5 		strb	r0, [r3, #41]
 495:bellator_low_level.c **** 					cmd_out.buff[14] = data->az_l;
 2926              		.loc 4 495 0
 2927 1284 6900D1E5 		ldrb	r0, [r1, #105]	@ zero_extendqisi2
 2928 1288 2A00C3E5 		strb	r0, [r3, #42]
 496:bellator_low_level.c **** 					cmd_out.buff[15] = data->gx_h;
 2929              		.loc 4 496 0
 2930 128c 6A00D1E5 		ldrb	r0, [r1, #106]	@ zero_extendqisi2
 2931 1290 2B00C3E5 		strb	r0, [r3, #43]
 497:bellator_low_level.c **** 					cmd_out.buff[16] = data->gx_l;
 2932              		.loc 4 497 0
 2933 1294 6B20D1E5 		ldrb	r2, [r1, #107]	@ zero_extendqisi2
 2934              	.LVL176:
 2935 1298 2C20C3E5 		strb	r2, [r3, #44]
 498:bellator_low_level.c **** 					cmd_out.buff[17] = data->gy_h;
 2936              		.loc 4 498 0
 2937 129c 6C00D1E5 		ldrb	r0, [r1, #108]	@ zero_extendqisi2
 2938 12a0 2D00C3E5 		strb	r0, [r3, #45]
 499:bellator_low_level.c **** 					cmd_out.buff[18] = data->gy_l;
 2939              		.loc 4 499 0
 2940 12a4 6D00D1E5 		ldrb	r0, [r1, #109]	@ zero_extendqisi2
 2941 12a8 2E00C3E5 		strb	r0, [r3, #46]
 500:bellator_low_level.c **** 					cmd_out.buff[19] = data->gz_h;
 2942              		.loc 4 500 0
 2943 12ac 6E00D1E5 		ldrb	r0, [r1, #110]	@ zero_extendqisi2
 2944 12b0 2F00C3E5 		strb	r0, [r3, #47]
 501:bellator_low_level.c **** 					cmd_out.buff[20] = data->gz_l;
 2945              		.loc 4 501 0
 2946 12b4 6F20D1E5 		ldrb	r2, [r1, #111]	@ zero_extendqisi2
 2947 12b8 3020C3E5 		strb	r2, [r3, #48]
 502:bellator_low_level.c **** 					cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 2948              		.loc 4 502 0
 2949 12bc B027D1E1 		ldrh	r2, [r1, #112]
 503:bellator_low_level.c **** 					cmd_out.buff[22] = data->timestamp & 0xFF;
 2950              		.loc 4 503 0
 2951 12c0 3220C3E5 		strb	r2, [r3, #50]
 502:bellator_low_level.c **** 					cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 2952              		.loc 4 502 0
 2953 12c4 2214A0E1 		mov	r1, r2, lsr #8
 506:bellator_low_level.c **** 					cmd_out.buff[23] = END_CMD;
 2954              		.loc 4 506 0
 2955 12c8 0120E0E3 		mvn	r2, #1
 2956 12cc 3320C3E5 		strb	r2, [r3, #51]
 507:bellator_low_level.c **** 					cmd_out.buff[24] = '\n';
 2957              		.loc 4 507 0
 2958 12d0 0C2082E2 		add	r2, r2, #12
 502:bellator_low_level.c **** 					cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
 2959              		.loc 4 502 0
 2960 12d4 3110C3E5 		strb	r1, [r3, #49]
 507:bellator_low_level.c **** 					cmd_out.buff[24] = '\n';
 2961              		.loc 4 507 0
 2962 12d8 3420C3E5 		strb	r2, [r3, #52]
 508:bellator_low_level.c **** 					cmd_out.i = 25;
 2963              		.loc 4 508 0
 2964 12dc 0F2082E2 		add	r2, r2, #15
 2965 12e0 182083E5 		str	r2, [r3, #24]
 2966 12e4 0030A0E3 		mov	r3, #0
 2967              	.L165:
 2968              	.LBB82:
 2969              	.LBB83:
 436:bellator_low_level.c **** void protocol_in(void){
 2970              		.loc 4 436 0
 2971 12e8 80209FE5 		ldr	r2, .L170+4
 2972 12ec 032082E0 		add	r2, r2, r3
 665:bellator_low_level.c **** 	}
 666:bellator_low_level.c **** }
 667:bellator_low_level.c **** 
 668:bellator_low_level.c **** /**
 669:bellator_low_level.c ****  *
 670:bellator_low_level.c ****  */
 671:bellator_low_level.c **** static void protocol_out_cmd(){
 672:bellator_low_level.c **** 	for (unsigned short i = 0; i < cmd_out.i; i++)
 673:bellator_low_level.c **** 		protocol_out_char(cmd_out.buff[i]);
 2973              		.loc 4 673 0
 2974 12f0 0410D2E5 		ldrb	r1, [r2, #4]	@ zero_extendqisi2
 2975              	.LVL177:
 2976              	.LBB84:
 2977              	.LBB85:
 674:bellator_low_level.c **** }
 675:bellator_low_level.c **** 
 676:bellator_low_level.c **** /**
 677:bellator_low_level.c ****  *
 678:bellator_low_level.c ****  */
 679:bellator_low_level.c **** static void protocol_out_char(char c){
 680:bellator_low_level.c **** 	U1THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
 2978              		.loc 4 680 0
 2979 12f4 78209FE5 		ldr	r2, .L170+8
 2980 12f8 0010C2E5 		strb	r1, [r2, #0]
 2981              	.LVL178:
 2982              	.L164:
 681:bellator_low_level.c **** 	while(!(U1LSR & 0x40));
 2983              		.loc 4 681 0
 2984 12fc 1410D2E5 		ldrb	r1, [r2, #20]	@ zero_extendqisi2
 2985 1300 400011E3 		tst	r1, #64
 2986 1304 FCFFFF0A 		beq	.L164
 2987 1308 013083E2 		add	r3, r3, #1
 2988              	.LBE85:
 2989              	.LBE84:
 672:bellator_low_level.c **** 	for (unsigned short i = 0; i < cmd_out.i; i++)
 2990              		.loc 4 672 0
 2991 130c 190053E3 		cmp	r3, #25
 2992 1310 F4FFFF1A 		bne	.L165
 2993              	.LVL179:
 2994              	.L161:
 2995              	.LBE83:
 2996              	.LBE82:
 2997              	.LBE81:
 512:bellator_low_level.c **** 			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
 2998              		.loc 4 512 0
 2999 1314 50309FE5 		ldr	r3, .L170
 3000 1318 3C2093E5 		ldr	r2, [r3, #60]
 3001 131c 012082E2 		add	r2, r2, #1
 3002 1320 1F2002E2 		and	r2, r2, #31
 3003 1324 3C2083E5 		str	r2, [r3, #60]
 513:bellator_low_level.c **** 			break;
 3004              		.loc 4 513 0
 3005 1328 040000EA 		b	.L168
 3006              	.L156:
 516:bellator_low_level.c **** 			U1THR = dummy; // Just clear the interrupt source
 3007              		.loc 4 516 0
 3008 132c 0720DDE5 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
 3009              	.LVL180:
 3010 1330 0020C3E5 		strb	r2, [r3, #0]
 517:bellator_low_level.c **** 			break;
 3011              		.loc 4 517 0
 3012 1334 010000EA 		b	.L168
 3013              	.LVL181:
 3014              	.L155:
 520:bellator_low_level.c **** 			dummy = U1MSR; // Just clear the interrupt source
 3015              		.loc 4 520 0
 3016 1338 1830D3E5 		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 3017              	.L169:
 3018 133c 0730CDE5 		strb	r3, [sp, #7]
 3019              	.L168:
 444:bellator_low_level.c **** 	while (((iir = U1IIR) & 0x01) == 0) {
 3020              		.loc 4 444 0 discriminator 1
 3021 1340 2C309FE5 		ldr	r3, .L170+8
 3022 1344 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 3023              	.LVL182:
 3024 1348 0620CDE5 		strb	r2, [sp, #6]
 3025 134c 0620DDE5 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 3026 1350 010012E3 		tst	r2, #1
 3027 1354 6DFFFF0A 		beq	.L166
 530:bellator_low_level.c **** 	VICVectAddr = 0;
 3028              		.loc 4 530 0
 3029 1358 0020A0E3 		mov	r2, #0
 3030              	.LVL183:
 3031 135c 0030E0E3 		mvn	r3, #0
 3032 1360 CF2F03E5 		str	r2, [r3, #-4047]
 531:bellator_low_level.c **** }
 3033              		.loc 4 531 0
 3034 1364 0CD08DE2 		add	sp, sp, #12
 3035 1368 1F90FDE8 		ldmfd	sp!, {r0, r1, r2, r3, r4, ip, pc}^
 3036              	.L171:
 3037              		.align	2
 3038              	.L170:
 3039 136c 00000000 		.word	.LANCHOR0
 3040 1370 18000000 		.word	.LANCHOR0+24
 3041 1374 000001E0 		.word	-536805376
 3042              		.cfi_endproc
 3043              	.LFE51:
 3044              		.fnend
 3046              		.global	ascii
 3047              		.section	.rodata
 3048              	.LANCHOR1 = . + 0
 3051              	ascii:
 3052 0000 30313233 		.ascii	"0123456789ABCDEF\000"
 3052      34353637 
 3052      38394142 
 3052      43444546 
 3052      00
 3053              		.bss
 3054              		.align	2
 3055              	.LANCHOR0 = . + 0
 3058              	ra_buff:
 3059 0000 00       		.space	1
 3060 0001 000000   		.space	3
 3063              	buff_pos:
 3064 0004 00000000 		.space	4
 3067              	buff_size:
 3068 0008 00000000 		.space	4
 3071              	c_buff:
 3072 000c 00000000 		.space	4
 3075              	busy:
 3076 0010 00000000 		.space	4
 3079              	imu_data_available:
 3080 0014 00       		.space	1
 3081 0015 000000   		.space	3
 3084              	cmd_out:
 3085 0018 00000000 		.space	36
 3085      00000000 
 3085      00000000 
 3085      00000000 
 3085      00000000 
 3088              	cmd_in:
 3089 003c 00000000 		.space	36
 3089      00000000 
 3089      00000000 
 3089      00000000 
 3089      00000000 
 3092              	imu_data_in_pos:
 3093 0060 0000     		.space	2
 3096              	imu_data_out_pos:
 3097 0062 0000     		.space	2
 3100              	imu_data_buff:
 3101 0064 00000000 		.space	3584
 3101      00000000 
 3101      00000000 
 3101      00000000 
 3101      00000000 
 3104              	timestamp:
 3105 0e64 0000     		.space	2
 3106 0e66 0000     		.space	2
 3109              	encoder_count:
 3110 0e68 00000000 		.space	8
 3110      00000000 
 3113              	sent_encoder_count:
 3114 0e70 00000000 		.space	8
 3114      00000000 
 3115              		.text
 3116              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 bellator_low_level.c
     /tmp/ccf02MGF.s:21     .text:00000000 $a
     /tmp/ccf02MGF.s:23     .text:00000000 log_char
     /tmp/ccf02MGF.s:47     .text:00000018 $d
                       .ARM.exidx:00000000 $d
     /tmp/ccf02MGF.s:52     .text:0000001c $a
     /tmp/ccf02MGF.s:54     .text:0000001c asm_get_cpsr
     /tmp/ccf02MGF.s:78     .text:00000024 asm_set_cpsr
     /tmp/ccf02MGF.s:102    .text:0000002c i2c_read_bytes_isr
     /tmp/ccf02MGF.s:258    .text:00000178 $d
                       .ARM.extab:00000000 $d
     /tmp/ccf02MGF.s:264    .text:00000180 $a
     /tmp/ccf02MGF.s:267    .text:00000180 i2c_write_byte_isr
     /tmp/ccf02MGF.s:378    .text:00000264 $d
     /tmp/ccf02MGF.s:384    .text:0000026c $a
     /tmp/ccf02MGF.s:387    .text:0000026c imu_data_ready
     /tmp/ccf02MGF.s:422    .text:000002a0 $d
     /tmp/ccf02MGF.s:428    .text:000002a8 $a
     /tmp/ccf02MGF.s:431    .text:000002a8 error
     /tmp/ccf02MGF.s:449    .text:000002ac logger_init
     /tmp/ccf02MGF.s:492    .text:00000304 $d
     /tmp/ccf02MGF.s:497    .text:00000308 $a
     /tmp/ccf02MGF.s:500    .text:00000308 log_int
     /tmp/ccf02MGF.s:581    .text:000003a8 $d
     /tmp/ccf02MGF.s:586    .text:000003ac $a
     /tmp/ccf02MGF.s:589    .text:000003ac log_short
     /tmp/ccf02MGF.s:655    .text:00000414 $d
     /tmp/ccf02MGF.s:660    .text:00000418 $a
     /tmp/ccf02MGF.s:663    .text:00000418 log_string
     /tmp/ccf02MGF.s:708    .text:0000044c log_byte
     /tmp/ccf02MGF.s:766    .text:00000494 $d
     /tmp/ccf02MGF.s:771    .text:00000498 $a
     /tmp/ccf02MGF.s:774    .text:00000498 log2bytes
     /tmp/ccf02MGF.s:840    .text:00000500 $d
     /tmp/ccf02MGF.s:845    .text:00000504 $a
     /tmp/ccf02MGF.s:848    .text:00000504 log4bytes
     /tmp/ccf02MGF.s:929    .text:000005a4 $d
     /tmp/ccf02MGF.s:934    .text:000005a8 $a
     /tmp/ccf02MGF.s:937    .text:000005a8 i2c_init
     /tmp/ccf02MGF.s:981    .text:00000604 $d
     /tmp/ccf02MGF.s:986    .text:00000608 $a
     /tmp/ccf02MGF.s:989    .text:00000608 i2c_read_bytes
     /tmp/ccf02MGF.s:1036   .text:00000654 $d
     /tmp/ccf02MGF.s:1043   .text:00000660 $a
     /tmp/ccf02MGF.s:1046   .text:00000660 i2c_read_byte
     /tmp/ccf02MGF.s:1071   .text:0000066c i2c_write_byte
     /tmp/ccf02MGF.s:1127   .text:000006c8 $d
     /tmp/ccf02MGF.s:1134   .text:000006d4 $a
     /tmp/ccf02MGF.s:1137   .text:000006d4 i2c_write_bits
     /tmp/ccf02MGF.s:1208   .text:0000072c mpu_set_clock_source
     /tmp/ccf02MGF.s:1236   .text:00000740 mpu_set_full_scale_gyro_range
     /tmp/ccf02MGF.s:1263   .text:00000754 mpu_set_full_scale_accel_range
     /tmp/ccf02MGF.s:1290   .text:00000768 mpu_set_sleep_enable
     /tmp/ccf02MGF.s:1316   .text:0000077c mpu_set_temperature_sensor_enabled
     /tmp/ccf02MGF.s:1343   .text:00000794 mpu_set_gyro_rate
     /tmp/ccf02MGF.s:1368   .text:000007a0 mpu_set_DLPF_mode
     /tmp/ccf02MGF.s:1395   .text:000007b4 mpu_set_6axis_FIFO_enabled
     /tmp/ccf02MGF.s:1419   .text:000007c0 mpu_set_interrupt_mode
     /tmp/ccf02MGF.s:1446   .text:000007d4 mpu_set_interrupt_drive
     /tmp/ccf02MGF.s:1473   .text:000007e8 mpu_set_interrupt_latch
     /tmp/ccf02MGF.s:1500   .text:000007fc mpu_set_FIFO_overflow_interrupt
     /tmp/ccf02MGF.s:1527   .text:00000810 mpu_set_data_ready_interrupt
     /tmp/ccf02MGF.s:1554   .text:00000824 mpu_clear_interrupt
     /tmp/ccf02MGF.s:1579   .text:00000830 mpu_set_FIFO_enabled
     /tmp/ccf02MGF.s:1606   .text:00000844 mpu_reset_FIFO
     /tmp/ccf02MGF.s:1630   .text:00000858 mpu_init
     /tmp/ccf02MGF.s:1703   .text:000008e0 mpu_get_FIFO_size
     /tmp/ccf02MGF.s:1743   .text:00000910 mpu_get_motion6
     /tmp/ccf02MGF.s:1838   .text:000009c4 mpu_get_FIFO_motion6
     /tmp/ccf02MGF.s:1933   .text:00000a78 main
     /tmp/ccf02MGF.s:2458   .text:00000f04 $d
     /tmp/ccf02MGF.s:2751   .text:00001100 protocol_in
     /tmp/ccf02MGF.s:2478   .text:00000f40 $a
     /tmp/ccf02MGF.s:2481   .text:00000f40 encoder_pulse_in_isr
     /tmp/ccf02MGF.s:2552   .text:00000fd0 $d
     /tmp/ccf02MGF.s:2559   .text:00000fdc $a
     /tmp/ccf02MGF.s:2562   .text:00000fdc get_ir_sensor_data
     /tmp/ccf02MGF.s:2579   .text:00000fec $d
     /tmp/ccf02MGF.s:2586   .text:00001000 $a
     /tmp/ccf02MGF.s:2640   .text:0000106c $d
     /tmp/ccf02MGF.s:2645   .text:00001070 $a
     /tmp/ccf02MGF.s:2648   .text:00001070 get_encoder_count
     /tmp/ccf02MGF.s:2676   .text:00001090 $d
     /tmp/ccf02MGF.s:2681   .text:00001094 $a
     /tmp/ccf02MGF.s:2684   .text:00001094 set_wheel_pwm
     /tmp/ccf02MGF.s:2742   .text:000010f8 $d
     /tmp/ccf02MGF.s:2748   .text:00001100 $a
     /tmp/ccf02MGF.s:2787   .text:00001124 $d
     /tmp/ccf02MGF.s:2802   .text:00001158 $a
     /tmp/ccf02MGF.s:3039   .text:0000136c $d
     /tmp/ccf02MGF.s:3051   .rodata:00000000 ascii
     /tmp/ccf02MGF.s:3054   .bss:00000000 $d
     /tmp/ccf02MGF.s:3058   .bss:00000000 ra_buff
     /tmp/ccf02MGF.s:3063   .bss:00000004 buff_pos
     /tmp/ccf02MGF.s:3067   .bss:00000008 buff_size
     /tmp/ccf02MGF.s:3071   .bss:0000000c c_buff
     /tmp/ccf02MGF.s:3075   .bss:00000010 busy
     /tmp/ccf02MGF.s:3079   .bss:00000014 imu_data_available
     /tmp/ccf02MGF.s:3084   .bss:00000018 cmd_out
     /tmp/ccf02MGF.s:3088   .bss:0000003c cmd_in
     /tmp/ccf02MGF.s:3092   .bss:00000060 imu_data_in_pos
     /tmp/ccf02MGF.s:3096   .bss:00000062 imu_data_out_pos
     /tmp/ccf02MGF.s:3100   .bss:00000064 imu_data_buff
     /tmp/ccf02MGF.s:3104   .bss:00000e64 timestamp
     /tmp/ccf02MGF.s:3109   .bss:00000e68 encoder_count
     /tmp/ccf02MGF.s:3113   .bss:00000e70 sent_encoder_count
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_unwind_cpp_pr0
__aeabi_unwind_cpp_pr1
