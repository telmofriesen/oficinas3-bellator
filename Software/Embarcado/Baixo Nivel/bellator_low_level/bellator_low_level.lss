
bellator_low_level.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b30  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.extab    00000030  00000b30  00000b30  00008b30  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .ARM.exidx    00000068  00000b60  00000b60  00008b60  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .interp       00000013  00000bc8  00000bc8  00008bc8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .gnu.version  0000000c  00000bdc  00000bdc  00008bdc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .gnu.version_r 00000020  00000be8  00000be8  00008be8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .dynsym       00000060  00000c08  00000c08  00008c08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dynstr       0000006a  00000c68  00000c68  00008c68  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .hash         0000002c  00000cd4  00000cd4  00008cd4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         00000010  40000000  00000d00  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dynamic      00000090  40000010  00000d10  00010010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got.plt      0000000c  400000a0  00000da0  000100a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .bss          00000070  400000ac  00000dac  000100ac  2**2
                  ALLOC
 13 .stack        00000400  4000011c  00000e1c  000100ac  2**0
                  ALLOC
 14 .ARM.attributes 0000002e  00000000  00000000  000100ac  2**0
                  CONTENTS, READONLY
 15 .comment      0000002a  00000000  00000000  000100da  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00000040  00000000  00000000  00010108  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 000001c0  00000000  00000000  00010148  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   0000081e  00000000  00000000  00010308  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 0000030a  00000000  00000000  00010b26  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   00000257  00000000  00000000  00010e30  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00000204  00000000  00000000  00011088  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00000260  00000000  00000000  0001128c  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    00000389  00000000  00000000  000114ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_pubtypes 0000001f  00000000  00000000  00011875  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_ranges 00000018  00000000  00000000  00011894  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_boot>:
_boot:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
   4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
   8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
   c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
  10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
  14:	e1a00000 	nop			; (mov r0, r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xbfffeb14>
        ldr   pc,_fiq                   // FIQ - _fiq
  1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
  20:	00000038 	.word	0x00000038

00000024 <_swi>:
  24:	0000003c 	.word	0x0000003c

00000028 <_pabt>:
  28:	00000040 	.word	0x00000040

0000002c <_dabt>:
  2c:	00000044 	.word	0x00000044

00000030 <_irq>:
  30:	00000048 	.word	0x00000048

00000034 <_fiq>:
  34:	0000004c 	.word	0x0000004c

00000038 <__undf>:
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <__pabt>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     update_position           // FIQ
  4c:	ea0001cc 	b	784 <update_position>

00000050 <_mainCRTStartup>:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
  50:	e59f0098 	ldr	r0, [pc, #152]	; f0 <abort+0x4>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
  54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
  58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
  5c:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
  60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
  64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
  68:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
  6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
  70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
  74:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
  78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
  7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
  80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
  84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
  88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
  8c:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
  90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
  94:	e1a0d000 	mov	sp, r0


// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
  98:	e59f1054 	ldr	r1, [pc, #84]	; f4 <abort+0x8>
        ldr   r2,=_data                 // -> data start
  9c:	e59f2054 	ldr	r2, [pc, #84]	; f8 <abort+0xc>
        ldr   r3,=_edata                // -> end of data
  a0:	e59f3054 	ldr	r3, [pc, #84]	; fc <abort+0x10>
1:      cmp   r2,r3                     // check if data to move
  a4:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
  a8:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
  ac:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
  b0:	3afffffb 	bcc	a4 <IRQ_STACK_SIZE+0x24>
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
  b4:	e3a00000 	mov	r0, #0
        ldr   r1,=__bss_start           // -> bss start
  b8:	e59f1040 	ldr	r1, [pc, #64]	; 100 <abort+0x14>
        ldr   r2,=__bss_end__           // -> bss end
  bc:	e59f2040 	ldr	r2, [pc, #64]	; 104 <abort+0x18>
2:      cmp   r1,r2                     // check if data to clear
  c0:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
  c4:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
  c8:	3afffffc 	bcc	c0 <IRQ_STACK_SIZE+0x40>

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  cc:	e3a00000 	mov	r0, #0
        mov   r1,r0
  d0:	e1a01000 	mov	r1, r0
        mov   r2,r0
  d4:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
  d8:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
  dc:	e1a07000 	mov	r7, r0
        ldr   r10,=main
  e0:	e59fa020 	ldr	sl, [pc, #32]	; 108 <abort+0x1c>
        mov   lr,pc
  e4:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
  e8:	e12fff1a 	bx	sl

000000ec <abort>:
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
  ec:	eafffffe 	b	ec <abort>
  f0:	4000051c 	.word	0x4000051c
  f4:	00000d00 	.word	0x00000d00
  f8:	40000000 	.word	0x40000000
  fc:	400000ac 	.word	0x400000ac
 100:	400000ac 	.word	0x400000ac
 104:	4000011c 	.word	0x4000011c
 108:	00000594 	.word	0x00000594

0000010c <ua_outchar>:

	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
}

static void ua_outchar(char c){
	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
 10c:	e59f3010 	ldr	r3, [pc, #16]	; 124 <ua_outchar+0x18>
 110:	e5c30000 	strb	r0, [r3]
	while(!(U0LSR & 0x40));
 114:	e5d32014 	ldrb	r2, [r3, #20]
 118:	e3120040 	tst	r2, #64	; 0x40
 11c:	0afffffc 	beq	114 <ua_outchar+0x8>
}
 120:	e12fff1e 	bx	lr
 124:	e000c000 	.word	0xe000c000

00000128 <protocol_in>:

	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
	U1IER = 3;       // Enable UART1 RX and THRE Interrupts
}

void protocol_in(void){
 128:	e92d107f 	push	{r0, r1, r2, r3, r4, r5, r6, ip}

		case 0x04: // Receive Data Available
		case 0x0C: // Character Time-Out
			cmd = &cmd_in;

			if (((cmd->in - cmd->out) & ~(CMD_BUFF_SIZE - 1)) == 0) {
 12c:	e59f3114 	ldr	r3, [pc, #276]	; 248 <protocol_in+0x120>
			break;

		case 0x02: // THRE Interrupt, transmit interrupt
			cmd = &cmd_out;

			if (cmd->in != cmd->out) {
 130:	e59f1114 	ldr	r1, [pc, #276]	; 24c <protocol_in+0x124>

		case 0x04: // Receive Data Available
		case 0x0C: // Character Time-Out
			cmd = &cmd_in;

			if (((cmd->in - cmd->out) & ~(CMD_BUFF_SIZE - 1)) == 0) {
 134:	e5935004 	ldr	r5, [r3, #4]
			break;

		case 0x02: // THRE Interrupt, transmit interrupt
			cmd = &cmd_out;

			if (cmd->in != cmd->out) {
 138:	e593c018 	ldr	ip, [r3, #24]
 13c:	e5932000 	ldr	r2, [r3]

	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
	U1IER = 3;       // Enable UART1 RX and THRE Interrupts
}

void protocol_in(void){
 140:	e24dd008 	sub	sp, sp, #8
			break;

		case 0x02: // THRE Interrupt, transmit interrupt
			cmd = &cmd_out;

			if (cmd->in != cmd->out) {
 144:	e593301c 	ldr	r3, [r3, #28]
 148:	e5910000 	ldr	r0, [r1]
	volatile char dummy;
	volatile char iir;
	struct cmd_buff *cmd;

	// Repeat while there is at least one interrupt source.
	while (((iir = U1IIR) & 0x01) == 0) {
 14c:	ea00002c 	b	204 <protocol_in+0xdc>
		switch (iir & 0x0E) {
 150:	e5dd4006 	ldrb	r4, [sp, #6]
 154:	e204400e 	and	r4, r4, #14
 158:	e354000c 	cmp	r4, #12
 15c:	979ff104 	ldrls	pc, [pc, r4, lsl #2]
 160:	ea000027 	b	204 <protocol_in+0xdc>
 164:	000001fc 	.word	0x000001fc
 168:	00000204 	.word	0x00000204
 16c:	000001c8 	.word	0x000001c8
 170:	00000204 	.word	0x00000204
 174:	000001a0 	.word	0x000001a0
 178:	00000204 	.word	0x00000204
 17c:	00000198 	.word	0x00000198
 180:	00000204 	.word	0x00000204
 184:	00000204 	.word	0x00000204
 188:	00000204 	.word	0x00000204
 18c:	00000204 	.word	0x00000204
 190:	00000204 	.word	0x00000204
 194:	000001a0 	.word	0x000001a0
		case 0x06: // Receive Line Status
			dummy = U1LSR; // Just clear the interrupt source
 198:	e5d11014 	ldrb	r1, [r1, #20]
 19c:	ea000017 	b	200 <protocol_in+0xd8>

		case 0x04: // Receive Data Available
		case 0x0C: // Character Time-Out
			cmd = &cmd_in;

			if (((cmd->in - cmd->out) & ~(CMD_BUFF_SIZE - 1)) == 0) {
 1a0:	e0654002 	rsb	r4, r5, r2
 1a4:	e3d4600f 	bics	r6, r4, #15
 1a8:	1a000015 	bne	204 <protocol_in+0xdc>
				cmd->buff[cmd->in & (CMD_BUFF_SIZE - 1)] = U1RBR;
 1ac:	e59f6094 	ldr	r6, [pc, #148]	; 248 <protocol_in+0x120>
 1b0:	e5d14000 	ldrb	r4, [r1]
 1b4:	e202100f 	and	r1, r2, #15
 1b8:	e0861001 	add	r1, r6, r1
 1bc:	e5c14008 	strb	r4, [r1, #8]
				cmd->in++;
 1c0:	e2822001 	add	r2, r2, #1
 1c4:	ea00000e 	b	204 <protocol_in+0xdc>
			break;

		case 0x02: // THRE Interrupt, transmit interrupt
			cmd = &cmd_out;

			if (cmd->in != cmd->out) {
 1c8:	e15c0003 	cmp	ip, r3
 1cc:	01a0300c 	moveq	r3, ip
				U1THR = cmd->buff[cmd->out & (CMD_BUFF_SIZE - 1)];
				cmd->out++;
				tx_restart = 0;
			} else {
				tx_restart = 1;
 1d0:	03a00001 	moveq	r0, #1
			break;

		case 0x02: // THRE Interrupt, transmit interrupt
			cmd = &cmd_out;

			if (cmd->in != cmd->out) {
 1d4:	0a00000a 	beq	204 <protocol_in+0xdc>
				U1THR = cmd->buff[cmd->out & (CMD_BUFF_SIZE - 1)];
 1d8:	e59f0068 	ldr	r0, [pc, #104]	; 248 <protocol_in+0x120>
 1dc:	e203100f 	and	r1, r3, #15
 1e0:	e0801001 	add	r1, r0, r1
 1e4:	e5d10020 	ldrb	r0, [r1, #32]
 1e8:	e59f1060 	ldr	r1, [pc, #96]	; 250 <protocol_in+0x128>
				cmd->out++;
 1ec:	e2833001 	add	r3, r3, #1

		case 0x02: // THRE Interrupt, transmit interrupt
			cmd = &cmd_out;

			if (cmd->in != cmd->out) {
				U1THR = cmd->buff[cmd->out & (CMD_BUFF_SIZE - 1)];
 1f0:	e5c10000 	strb	r0, [r1]
				cmd->out++;
				tx_restart = 0;
 1f4:	e3a00000 	mov	r0, #0
 1f8:	ea000001 	b	204 <protocol_in+0xdc>
			} else {
				tx_restart = 1;
			}
			break;
		case 0x00: // Modem Interrupt
			dummy = U1MSR; // Just clear the interrupt source
 1fc:	e5d11018 	ldrb	r1, [r1, #24]
 200:	e5cd1007 	strb	r1, [sp, #7]
	volatile char dummy;
	volatile char iir;
	struct cmd_buff *cmd;

	// Repeat while there is at least one interrupt source.
	while (((iir = U1IIR) & 0x01) == 0) {
 204:	e59f1044 	ldr	r1, [pc, #68]	; 250 <protocol_in+0x128>
 208:	e5d14008 	ldrb	r4, [r1, #8]
 20c:	e5cd4006 	strb	r4, [sp, #6]
 210:	e5dd4006 	ldrb	r4, [sp, #6]
 214:	e3140001 	tst	r4, #1
 218:	0affffcc 	beq	150 <protocol_in+0x28>
 21c:	e59f1024 	ldr	r1, [pc, #36]	; 248 <protocol_in+0x120>
 220:	e581301c 	str	r3, [r1, #28]
 224:	e59f3020 	ldr	r3, [pc, #32]	; 24c <protocol_in+0x124>
 228:	e5812000 	str	r2, [r1]
 22c:	e5830000 	str	r0, [r3]
		default:
			break;
		}
	}

	VICVectAddr = 0;
 230:	e3a02000 	mov	r2, #0
 234:	e3e03000 	mvn	r3, #0
 238:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
 23c:	e28dd008 	add	sp, sp, #8
 240:	e8bd107f 	pop	{r0, r1, r2, r3, r4, r5, r6, ip}
 244:	e25ef004 	subs	pc, lr, #4
 248:	400000ac 	.word	0x400000ac
 24c:	40000000 	.word	0x40000000
 250:	e0010000 	.word	0xe0010000

00000254 <ADC0_Read>:
	//T3TC = T2TC;
}

static inline int ADC0_Read(void){
	int i;
	ADCR |= 0x01200601; // Start A/D Conversion Enabled, No Burst, 4,28MHz se pclk=30MHz
 254:	e59f303c 	ldr	r3, [pc, #60]	; 298 <ADC0_Read+0x44>
 258:	e59f203c 	ldr	r2, [pc, #60]	; 29c <ADC0_Read+0x48>
 25c:	e5931000 	ldr	r1, [r3]
 260:	e1812002 	orr	r2, r1, r2
 264:	e5832000 	str	r2, [r3]
 268:	e1a02003 	mov	r2, r3
	while(!(ADSTAT & 0x00000001)); // Wait for end of A/D Conversion
 26c:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 270:	e3110001 	tst	r1, #1
 274:	e59f301c 	ldr	r3, [pc, #28]	; 298 <ADC0_Read+0x44>
 278:	0afffffb 	beq	26c <ADC0_Read+0x18>
	i = ADDR0; // Read A/D Data Register
 27c:	e5930010 	ldr	r0, [r3, #16]
	ADCR &= 0xFEDFF9FE; // Stop A/D Conversion
 280:	e59f2018 	ldr	r2, [pc, #24]	; 2a0 <ADC0_Read+0x4c>
 284:	e5931000 	ldr	r1, [r3]
 288:	e0012002 	and	r2, r1, r2
 28c:	e5832000 	str	r2, [r3]
	return (i >> 6); // bit 6:15 is 10 bit AD value
}
 290:	e1a00340 	asr	r0, r0, #6
 294:	e12fff1e 	bx	lr
 298:	e0034000 	.word	0xe0034000
 29c:	01200601 	.word	0x01200601
 2a0:	fedff9fe 	.word	0xfedff9fe

000002a4 <ADC1_Read>:

static inline int ADC1_Read(void){
	int i;
	ADCR |= 0x01200602; // Start A/D Conversion Enabled, No Burst, 4,28MHz se pclk=30MHz
 2a4:	e59f303c 	ldr	r3, [pc, #60]	; 2e8 <ADC1_Read+0x44>
 2a8:	e59f203c 	ldr	r2, [pc, #60]	; 2ec <ADC1_Read+0x48>
 2ac:	e5931000 	ldr	r1, [r3]
 2b0:	e1812002 	orr	r2, r1, r2
 2b4:	e5832000 	str	r2, [r3]
 2b8:	e1a02003 	mov	r2, r3
	while(!(ADSTAT & 0x00000002)); // Wait for end of A/D Conversion
 2bc:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 2c0:	e3110002 	tst	r1, #2
 2c4:	e59f301c 	ldr	r3, [pc, #28]	; 2e8 <ADC1_Read+0x44>
 2c8:	0afffffb 	beq	2bc <ADC1_Read+0x18>
	i = ADDR1; // Read A/D Data Register
 2cc:	e5930014 	ldr	r0, [r3, #20]
	ADCR &= 0xFEDFF9FD; // Stop A/D Conversion
 2d0:	e59f2018 	ldr	r2, [pc, #24]	; 2f0 <ADC1_Read+0x4c>
 2d4:	e5931000 	ldr	r1, [r3]
 2d8:	e0012002 	and	r2, r1, r2
 2dc:	e5832000 	str	r2, [r3]
	return (i >> 6); // bit 6:15 is 10 bit AD value
}
 2e0:	e1a00340 	asr	r0, r0, #6
 2e4:	e12fff1e 	bx	lr
 2e8:	e0034000 	.word	0xe0034000
 2ec:	01200602 	.word	0x01200602
 2f0:	fedff9fd 	.word	0xfedff9fd

000002f4 <logger_init>:
 * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
 * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
 *
 */
void logger_init(void){ // using UART0
	PINSEL0 |= 0x05; // Set the pins function
 2f4:	e59f3028 	ldr	r3, [pc, #40]	; 324 <logger_init+0x30>
 2f8:	e5932000 	ldr	r2, [r3]
 2fc:	e3822005 	orr	r2, r2, #5
 300:	e5832000 	str	r2, [r3]
	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
 304:	e2433802 	sub	r3, r3, #131072	; 0x20000
 308:	e3a02007 	mov	r2, #7
 30c:	e5c32008 	strb	r2, [r3, #8]
	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 310:	e3e0207c 	mvn	r2, #124	; 0x7c
 314:	e5c3200c 	strb	r2, [r3, #12]
#ifdef CRYSTAL14.7456MHz
	U0DLL	 = 0x08; // DivisorLatchLow bit
	U0DLM	 = 0x00; // DivisorLatchHigh bit
#endif

	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 318:	e2822080 	add	r2, r2, #128	; 0x80
 31c:	e5c3200c 	strb	r2, [r3, #12]
}
 320:	e12fff1e 	bx	lr
 324:	e002c000 	.word	0xe002c000

00000328 <log_int>:
static void ua_outchar(char c){
	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
	while(!(U0LSR & 0x40));
}

void log_int(int num){
 328:	e92d4070 	push	{r4, r5, r6, lr}
	if(num & 0x80000000){// se for negativo
 32c:	e2504000 	subs	r4, r0, #0
 330:	aa000003 	bge	344 <log_int+0x1c>
		ua_outchar('-');
 334:	e3a0002d 	mov	r0, #45	; 0x2d
 338:	ebffff73 	bl	10c <ua_outchar>
		num = ~num;
		num += 0x1;
 33c:	e2644000 	rsb	r4, r4, #0
 340:	ea000001 	b	34c <log_int+0x24>
	}else
		ua_outchar(' ');
 344:	e3a00020 	mov	r0, #32
 348:	ebffff6f 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 28]);
 34c:	e59f5074 	ldr	r5, [pc, #116]	; 3c8 <log_int+0xa0>
 350:	e7d50e44 	ldrb	r0, [r5, r4, asr #28]
 354:	ebffff6c 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 24 & 0x0000000f]);
 358:	e1a03c44 	asr	r3, r4, #24
 35c:	e203300f 	and	r3, r3, #15
 360:	e7d50003 	ldrb	r0, [r5, r3]
 364:	ebffff68 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 20 & 0x0000000f]);
 368:	e1a03a44 	asr	r3, r4, #20
 36c:	e203300f 	and	r3, r3, #15
 370:	e7d50003 	ldrb	r0, [r5, r3]
 374:	ebffff64 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 16 & 0x0000000f]);
 378:	e1a03844 	asr	r3, r4, #16
 37c:	e203300f 	and	r3, r3, #15
 380:	e7d50003 	ldrb	r0, [r5, r3]
 384:	ebffff60 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 12 & 0x0000000f]);
 388:	e1a03644 	asr	r3, r4, #12
 38c:	e203300f 	and	r3, r3, #15
 390:	e7d50003 	ldrb	r0, [r5, r3]
 394:	ebffff5c 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 8 & 0x0000000f]);
 398:	e1a03444 	asr	r3, r4, #8
 39c:	e203300f 	and	r3, r3, #15
 3a0:	e7d50003 	ldrb	r0, [r5, r3]
 3a4:	ebffff58 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 4 & 0x0000000f]);
 3a8:	e1a03244 	asr	r3, r4, #4
 3ac:	e203300f 	and	r3, r3, #15
 3b0:	e7d50003 	ldrb	r0, [r5, r3]
 3b4:	ebffff54 	bl	10c <ua_outchar>
	ua_outchar(ascii[num & 0x0000000f]);
 3b8:	e204400f 	and	r4, r4, #15
 3bc:	e7d50004 	ldrb	r0, [r5, r4]
}
 3c0:	e8bd4070 	pop	{r4, r5, r6, lr}
	ua_outchar(ascii[num >> 20 & 0x0000000f]);
	ua_outchar(ascii[num >> 16 & 0x0000000f]);
	ua_outchar(ascii[num >> 12 & 0x0000000f]);
	ua_outchar(ascii[num >> 8 & 0x0000000f]);
	ua_outchar(ascii[num >> 4 & 0x0000000f]);
	ua_outchar(ascii[num & 0x0000000f]);
 3c4:	eaffff50 	b	10c <ua_outchar>
 3c8:	00000b04 	.word	0x00000b04

000003cc <log_short>:
}

void log_short(short num){
 3cc:	e92d4070 	push	{r4, r5, r6, lr}
	if(num & 0x8000){// se for negativo
 3d0:	e2504000 	subs	r4, r0, #0
 3d4:	aa000005 	bge	3f0 <log_short+0x24>
		ua_outchar('-');
		num = ~num;
		num++;
 3d8:	e2644000 	rsb	r4, r4, #0
	ua_outchar(ascii[num & 0x0000000f]);
}

void log_short(short num){
	if(num & 0x8000){// se for negativo
		ua_outchar('-');
 3dc:	e3a0002d 	mov	r0, #45	; 0x2d
		num = ~num;
		num++;
 3e0:	e1a04804 	lsl	r4, r4, #16
	ua_outchar(ascii[num & 0x0000000f]);
}

void log_short(short num){
	if(num & 0x8000){// se for negativo
		ua_outchar('-');
 3e4:	ebffff48 	bl	10c <ua_outchar>
		num = ~num;
		num++;
 3e8:	e1a04844 	asr	r4, r4, #16
 3ec:	ea000001 	b	3f8 <log_short+0x2c>
	}else
		ua_outchar(' ');
 3f0:	e3a00020 	mov	r0, #32
 3f4:	ebffff44 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 12]);
 3f8:	e59f5034 	ldr	r5, [pc, #52]	; 434 <STACK_SIZE+0x34>
 3fc:	e7d50644 	ldrb	r0, [r5, r4, asr #12]
 400:	ebffff41 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 8 & 0x000f]);
 404:	e1a03424 	lsr	r3, r4, #8
 408:	e203300f 	and	r3, r3, #15
 40c:	e7d50003 	ldrb	r0, [r5, r3]
 410:	ebffff3d 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 4 & 0x000f]);
 414:	e1a03224 	lsr	r3, r4, #4
 418:	e203300f 	and	r3, r3, #15
 41c:	e7d50003 	ldrb	r0, [r5, r3]
 420:	ebffff39 	bl	10c <ua_outchar>
	ua_outchar(ascii[num & 0x000f]);
 424:	e204400f 	and	r4, r4, #15
 428:	e7d50004 	ldrb	r0, [r5, r4]
}
 42c:	e8bd4070 	pop	{r4, r5, r6, lr}
	}else
		ua_outchar(' ');
	ua_outchar(ascii[num >> 12]);
	ua_outchar(ascii[num >> 8 & 0x000f]);
	ua_outchar(ascii[num >> 4 & 0x000f]);
	ua_outchar(ascii[num & 0x000f]);
 430:	eaffff35 	b	10c <ua_outchar>
 434:	00000b04 	.word	0x00000b04

00000438 <log_string>:
}

void log_string(const char *s){
 438:	e92d4010 	push	{r4, lr}
 43c:	e1a04000 	mov	r4, r0
	while(*s){
 440:	ea000004 	b	458 <log_string+0x20>
		if(*s == '\n')
 444:	e353000a 	cmp	r3, #10
			ua_outchar('\r'); // \n + \r = new line
 448:	03a0000d 	moveq	r0, #13
 44c:	0bffff2e 	bleq	10c <ua_outchar>
		ua_outchar(*s);
 450:	e5540001 	ldrb	r0, [r4, #-1]
 454:	ebffff2c 	bl	10c <ua_outchar>
	ua_outchar(ascii[num >> 4 & 0x000f]);
	ua_outchar(ascii[num & 0x000f]);
}

void log_string(const char *s){
	while(*s){
 458:	e4d43001 	ldrb	r3, [r4], #1
 45c:	e3530000 	cmp	r3, #0
 460:	1afffff7 	bne	444 <log_string+0xc>
		if(*s == '\n')
			ua_outchar('\r'); // \n + \r = new line
		ua_outchar(*s);
		s++;
	}
}
 464:	e8bd4010 	pop	{r4, lr}
 468:	e12fff1e 	bx	lr

0000046c <error>:
	T1PR = 0x1C; //Prescale increments in 30 cclk cycles
	T1TC = 0; // reset T1
	T1TCR = 1; //enable T1
}

void error(void){
 46c:	e24ee004 	sub	lr, lr, #4
 470:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
	log_string("irq error");
 474:	e59f0004 	ldr	r0, [pc, #4]	; 480 <error+0x14>
 478:	ebffffee 	bl	438 <log_string>
}
 47c:	e8fd900f 	ldm	sp!, {r0, r1, r2, r3, ip, pc}^
 480:	00000b15 	.word	0x00000b15

00000484 <log2bytes>:

void log2bytes(short c){
 484:	e92d4070 	push	{r4, r5, r6, lr}
	if(c & 0x8000){// se for negativo
 488:	e2504000 	subs	r4, r0, #0
 48c:	aa000005 	bge	4a8 <log2bytes+0x24>
		ua_outchar('-');
		c = ~c;
		c++;
 490:	e2644000 	rsb	r4, r4, #0
	}
}

void log2bytes(short c){
	if(c & 0x8000){// se for negativo
		ua_outchar('-');
 494:	e3a0002d 	mov	r0, #45	; 0x2d
		c = ~c;
		c++;
 498:	e1a04804 	lsl	r4, r4, #16
	}
}

void log2bytes(short c){
	if(c & 0x8000){// se for negativo
		ua_outchar('-');
 49c:	ebffff1a 	bl	10c <ua_outchar>
		c = ~c;
		c++;
 4a0:	e1a04844 	asr	r4, r4, #16
 4a4:	ea000001 	b	4b0 <log2bytes+0x2c>
	}else
		ua_outchar(' ');
 4a8:	e3a00020 	mov	r0, #32
 4ac:	ebffff16 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 12]);
 4b0:	e59f5034 	ldr	r5, [pc, #52]	; 4ec <log2bytes+0x68>
 4b4:	e7d50644 	ldrb	r0, [r5, r4, asr #12]
 4b8:	ebffff13 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 8 & 0x000f]);
 4bc:	e1a03424 	lsr	r3, r4, #8
 4c0:	e203300f 	and	r3, r3, #15
 4c4:	e7d50003 	ldrb	r0, [r5, r3]
 4c8:	ebffff0f 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 4 & 0x000f]);
 4cc:	e1a03224 	lsr	r3, r4, #4
 4d0:	e203300f 	and	r3, r3, #15
 4d4:	e7d50003 	ldrb	r0, [r5, r3]
 4d8:	ebffff0b 	bl	10c <ua_outchar>
	ua_outchar(ascii[c & 0x000f]);
 4dc:	e204400f 	and	r4, r4, #15
 4e0:	e7d50004 	ldrb	r0, [r5, r4]
}
 4e4:	e8bd4070 	pop	{r4, r5, r6, lr}
	}else
		ua_outchar(' ');
	ua_outchar(ascii[c >> 12]);
	ua_outchar(ascii[c >> 8 & 0x000f]);
	ua_outchar(ascii[c >> 4 & 0x000f]);
	ua_outchar(ascii[c & 0x000f]);
 4e8:	eaffff07 	b	10c <ua_outchar>
 4ec:	00000b04 	.word	0x00000b04

000004f0 <log4bytes>:
}

void log4bytes(int c){
 4f0:	e92d4070 	push	{r4, r5, r6, lr}
	if(c & 0x80000000){// se for negativo
 4f4:	e2504000 	subs	r4, r0, #0
 4f8:	aa000003 	bge	50c <log4bytes+0x1c>
		ua_outchar('-');
 4fc:	e3a0002d 	mov	r0, #45	; 0x2d
 500:	ebffff01 	bl	10c <ua_outchar>
		c = ~c;
		c += 0x1;
 504:	e2644000 	rsb	r4, r4, #0
 508:	ea000001 	b	514 <log4bytes+0x24>
	}else
		ua_outchar(' ');
 50c:	e3a00020 	mov	r0, #32
 510:	ebfffefd 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 28]);
 514:	e59f5074 	ldr	r5, [pc, #116]	; 590 <log4bytes+0xa0>
 518:	e7d50e44 	ldrb	r0, [r5, r4, asr #28]
 51c:	ebfffefa 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 24 & 0x0000000f]);
 520:	e1a03c44 	asr	r3, r4, #24
 524:	e203300f 	and	r3, r3, #15
 528:	e7d50003 	ldrb	r0, [r5, r3]
 52c:	ebfffef6 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 20 & 0x0000000f]);
 530:	e1a03a44 	asr	r3, r4, #20
 534:	e203300f 	and	r3, r3, #15
 538:	e7d50003 	ldrb	r0, [r5, r3]
 53c:	ebfffef2 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 16 & 0x0000000f]);
 540:	e1a03844 	asr	r3, r4, #16
 544:	e203300f 	and	r3, r3, #15
 548:	e7d50003 	ldrb	r0, [r5, r3]
 54c:	ebfffeee 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 12 & 0x0000000f]);
 550:	e1a03644 	asr	r3, r4, #12
 554:	e203300f 	and	r3, r3, #15
 558:	e7d50003 	ldrb	r0, [r5, r3]
 55c:	ebfffeea 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 8 & 0x0000000f]);
 560:	e1a03444 	asr	r3, r4, #8
 564:	e203300f 	and	r3, r3, #15
 568:	e7d50003 	ldrb	r0, [r5, r3]
 56c:	ebfffee6 	bl	10c <ua_outchar>
	ua_outchar(ascii[c >> 4 & 0x0000000f]);
 570:	e1a03244 	asr	r3, r4, #4
 574:	e203300f 	and	r3, r3, #15
 578:	e7d50003 	ldrb	r0, [r5, r3]
 57c:	ebfffee2 	bl	10c <ua_outchar>
	ua_outchar(ascii[c & 0x0000000f]);
 580:	e204400f 	and	r4, r4, #15
 584:	e7d50004 	ldrb	r0, [r5, r4]
}
 588:	e8bd4070 	pop	{r4, r5, r6, lr}
	ua_outchar(ascii[c >> 20 & 0x0000000f]);
	ua_outchar(ascii[c >> 16 & 0x0000000f]);
	ua_outchar(ascii[c >> 12 & 0x0000000f]);
	ua_outchar(ascii[c >> 8 & 0x0000000f]);
	ua_outchar(ascii[c >> 4 & 0x0000000f]);
	ua_outchar(ascii[c & 0x0000000f]);
 58c:	eafffede 	b	10c <ua_outchar>
 590:	00000b04 	.word	0x00000b04

00000594 <main>:
 * 													(P=1 -> PSEL=00, P=2 -> PSEL=01, P=4 -> PSEL=10, P=8 -> PSEL=11)
 */
inline void PLL_Init(void){

#ifdef CRYSTAL12MHz
	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 594:	e59f3130 	ldr	r3, [pc, #304]	; 6cc <main+0x138>
};
static struct cmd_buff cmd_out = { 0, 0, };
static struct cmd_buff cmd_in = { 0, 0, };
static unsigned int tx_restart = 1;

int main(void){
 598:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
 * 													(P=1 -> PSEL=00, P=2 -> PSEL=01, P=4 -> PSEL=10, P=8 -> PSEL=11)
 */
inline void PLL_Init(void){

#ifdef CRYSTAL12MHz
	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
 59c:	e3a02024 	mov	r2, #36	; 0x24
 5a0:	e5c32084 	strb	r2, [r3, #132]	; 0x84
#endif
#ifdef CRYSTAL14.7456MHz
	PLLCFG=0x23;                // 14.7456MHz crystal -> 58.9824MHz
#endif

	PLLCON=0x1;                 //PLLE = 1, PLLEnable
 5a4:	e3a02001 	mov	r2, #1
 5a8:	e5c32080 	strb	r2, [r3, #128]	; 0x80
	PLLFEED=0xAA;               // Validation sequence
 5ac:	e3e02055 	mvn	r2, #85	; 0x55
 5b0:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
	PLLFEED=0x55;               // Validation sequence
 5b4:	e28220ab 	add	r2, r2, #171	; 0xab
 5b8:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
 5bc:	e1a02003 	mov	r2, r3
	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
 5c0:	e1d218b8 	ldrh	r1, [r2, #136]	; 0x88
 5c4:	e3110b01 	tst	r1, #1024	; 0x400
 5c8:	e59f30fc 	ldr	r3, [pc, #252]	; 6cc <main+0x138>
 5cc:	0afffffb 	beq	5c0 <main+0x2c>
	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
 5d0:	e3a02003 	mov	r2, #3
 5d4:	e5c32080 	strb	r2, [r3, #128]	; 0x80
	PLLFEED=0xAA;               // Validation sequence
 5d8:	e3e02055 	mvn	r2, #85	; 0x55
 5dc:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
	PLLFEED=0x55;               // Validation sequence
 5e0:	e28220ab 	add	r2, r2, #171	; 0xab
 5e4:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
 * > 60MHz         -> MAMTIM = 4 CCLK
 */
inline void MAM_Init(void){

#ifdef CRYSTAL12MHz
	MAMTIM = 4; // 4 clock fetches
 5e8:	e3a02004 	mov	r2, #4
 5ec:	e5c32004 	strb	r2, [r3, #4]
#endif
#ifdef CRYSTAL14.7456MHz
	MAMTIM = 3; // 3 clock fetches
#endif
	MAMCR = 2;	// MAM functions fully enabled
 5f0:	e3a02002 	mov	r2, #2
 5f4:	e5c32000 	strb	r2, [r3]
 * Configure the peripheral devices clock divider
 */
inline void APB_Init(void){
	// peripheral clock = PCLK = CCLK/4
	//APBDIV |= 0x02;
	APBDIV &= ~0x03;
 5f8:	e5d32100 	ldrb	r2, [r3, #256]	; 0x100
 5fc:	e20220fc 	and	r2, r2, #252	; 0xfc
 600:	e5c32100 	strb	r2, [r3, #256]	; 0x100

	PLL_Init(); // Turn on PLL clock
	MAM_Init(); // Turn on MAM pre-fetcher
	APB_Init(); // Turn on the peripheral devices clock divider

	logger_init();
 604:	ebffff3a 	bl	2f4 <logger_init>
	log_string("iniciando\n");
 608:	e59f00c0 	ldr	r0, [pc, #192]	; 6d0 <main+0x13c>
 60c:	ebffff89 	bl	438 <log_string>
#include "irq.h"

static inline unsigned asm_get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
 610:	e10f3000 	mrs	r3, CPSR
inline unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr(_cpsr & ~IRQ_MASK);
 614:	e3c33080 	bic	r3, r3, #128	; 0x80
  return retval;
}

static inline void asm_set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
 618:	e129f003 	msr	CPSR_fc, r3
 * Set UART1 interrupt to the third slot in the vectored interrupts.
 */
inline void protocol_init(void){
	volatile char dummy;

	PINSEL0 |= 0x05 << 16; // Set the pins function
 61c:	e59f30b0 	ldr	r3, [pc, #176]	; 6d4 <main+0x140>
 620:	e5932000 	ldr	r2, [r3]
 624:	e3822805 	orr	r2, r2, #327680	; 0x50000
 628:	e5832000 	str	r2, [r3]
	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
 62c:	e2433907 	sub	r3, r3, #114688	; 0x1c000
 630:	e3a02007 	mov	r2, #7
 634:	e5c32008 	strb	r2, [r3, #8]
	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
 638:	e3e0207c 	mvn	r2, #124	; 0x7c
 63c:	e5c3200c 	strb	r2, [r3, #12]

#ifdef CRYSTAL12MHz
	U1DLL	 = 0x06; // DivisorLatchLow bit
	U1DLM	 = 0x00; // DivisorLatchHigh bit
 640:	e3a00000 	mov	r0, #0
	PINSEL0 |= 0x05 << 16; // Set the pins function
	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches

#ifdef CRYSTAL12MHz
	U1DLL	 = 0x06; // DivisorLatchLow bit
 644:	e2822083 	add	r2, r2, #131	; 0x83
 648:	e5c32000 	strb	r2, [r3]
	U1DLM	 = 0x00; // DivisorLatchHigh bit
 64c:	e5c30004 	strb	r0, [r3, #4]
	U1FDR	|= 0x05; // DivAddVal
 650:	e5d32028 	ldrb	r2, [r3, #40]	; 0x28
 654:	e3822005 	orr	r2, r2, #5
 658:	e5c32028 	strb	r2, [r3, #40]	; 0x28
	U1FDR	|= 0x0E << 4; // MulVal = 14
 65c:	e5d32028 	ldrb	r2, [r3, #40]	; 0x28
	U1DLM	 = 0x00; // DivisorLatchHigh bit
#endif

	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches

	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the first vectored interruption slot
 660:	e59f1070 	ldr	r1, [pc, #112]	; 6d8 <main+0x144>

#ifdef CRYSTAL12MHz
	U1DLL	 = 0x06; // DivisorLatchLow bit
	U1DLM	 = 0x00; // DivisorLatchHigh bit
	U1FDR	|= 0x05; // DivAddVal
	U1FDR	|= 0x0E << 4; // MulVal = 14
 664:	e38220e0 	orr	r2, r2, #224	; 0xe0
 668:	e5c32028 	strb	r2, [r3, #40]	; 0x28
#ifdef CRYSTAL14.7456MHz
	U1DLL	 = 0x08; // DivisorLatchLow bit
	U1DLM	 = 0x00; // DivisorLatchHigh bit
#endif

	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 66c:	e3a0c003 	mov	ip, #3

	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the first vectored interruption slot
 670:	e3e02000 	mvn	r2, #0
#ifdef CRYSTAL14.7456MHz
	U1DLL	 = 0x08; // DivisorLatchLow bit
	U1DLM	 = 0x00; // DivisorLatchHigh bit
#endif

	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
 674:	e5c3c00c 	strb	ip, [r3, #12]

	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the first vectored interruption slot
 678:	e5021ef7 	str	r1, [r2, #-3831]	; 0xfffff109
	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
 67c:	e3a01027 	mov	r1, #39	; 0x27
 680:	e5021df7 	str	r1, [r2, #-3575]	; 0xfffff209
	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
 684:	e5121fef 	ldr	r1, [r2, #-4079]	; 0xfffff011
 688:	e3811080 	orr	r1, r1, #128	; 0x80
 68c:	e5021fef 	str	r1, [r2, #-4079]	; 0xfffff011

	cmd_out.in = 0;
	cmd_out.out = 0;
	tx_restart = 1;
 690:	e59f4044 	ldr	r4, [pc, #68]	; 6dc <main+0x148>

	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the first vectored interruption slot
	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ

	cmd_out.in = 0;
 694:	e59f1044 	ldr	r1, [pc, #68]	; 6e0 <main+0x14c>
	cmd_out.out = 0;
	tx_restart = 1;
 698:	e3a05001 	mov	r5, #1

	VICVectAddr2 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the first vectored interruption slot
	VICVectCntl2 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ

	cmd_out.in = 0;
 69c:	e5810018 	str	r0, [r1, #24]
	cmd_out.out = 0;
 6a0:	e581001c 	str	r0, [r1, #28]
	tx_restart = 1;
 6a4:	e5845000 	str	r5, [r4]

	cmd_in.in = 0;
 6a8:	e5810000 	str	r0, [r1]
	cmd_in.out = 0;
 6ac:	e5810004 	str	r0, [r1, #4]

	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
 6b0:	e5d31008 	ldrb	r1, [r3, #8]
 6b4:	e5cd1007 	strb	r1, [sp, #7]
	U1IER = 3;       // Enable UART1 RX and THRE Interrupts
 6b8:	e5c3c004 	strb	ip, [r3, #4]
	//pwm_out_init();

	//enableFIQ();
	//positioning_init();

	VICDefVectAddr = (unsigned int) &error;
 6bc:	e59f3020 	ldr	r3, [pc, #32]	; 6e4 <main+0x150>
 6c0:	e5023fcb 	str	r3, [r2, #-4043]	; 0xfffff035
//		com_putchar('c');
//		com_putchar('=');
//		com_putchar(c);
//	}
	return 0;
}
 6c4:	e8bd403e 	pop	{r1, r2, r3, r4, r5, lr}
 6c8:	e12fff1e 	bx	lr
 6cc:	e01fc000 	.word	0xe01fc000
 6d0:	00000b1f 	.word	0x00000b1f
 6d4:	e002c000 	.word	0xe002c000
 6d8:	00000128 	.word	0x00000128
 6dc:	40000000 	.word	0x40000000
 6e0:	400000ac 	.word	0x400000ac
 6e4:	0000046c 	.word	0x0000046c

000006e8 <com_putchar>:
	struct cmd_buff *cmd = &cmd_out;

	/*------------------------------------------------
	 If the buffer is full, return an error value.
	 ------------------------------------------------*/
	if ((cmd->in - cmd->out) >= CMD_BUFF_SIZE)
 6e8:	e59f305c 	ldr	r3, [pc, #92]	; 74c <com_putchar+0x64>
 6ec:	e5932018 	ldr	r2, [r3, #24]
 6f0:	e593101c 	ldr	r1, [r3, #28]
 6f4:	e0611002 	rsb	r1, r1, r2
 6f8:	e351000f 	cmp	r1, #15
 6fc:	8a000010 	bhi	744 <com_putchar+0x5c>

	/*------------------------------------------------
	 Add the data to the transmit buffer.  If the
	 transmit interrupt is disabled, then enable it.
	 ------------------------------------------------*/
	if (tx_restart) {
 700:	e59fc048 	ldr	ip, [pc, #72]	; 750 <com_putchar+0x68>
 704:	e59c1000 	ldr	r1, [ip]
 708:	e3510000 	cmp	r1, #0
 70c:	0a000005 	beq	728 <com_putchar+0x40>
		tx_restart = 0;
		U1THR = c;
 710:	e59f203c 	ldr	r2, [pc, #60]	; 754 <com_putchar+0x6c>
	/*------------------------------------------------
	 Add the data to the transmit buffer.  If the
	 transmit interrupt is disabled, then enable it.
	 ------------------------------------------------*/
	if (tx_restart) {
		tx_restart = 0;
 714:	e3a03000 	mov	r3, #0
 718:	e58c3000 	str	r3, [ip]
		U1THR = c;
 71c:	e5c20000 	strb	r0, [r2]
	} else {
		cmd->buff[cmd->in & (CMD_BUFF_SIZE - 1)] = c;
		cmd->in++;
	}

	return (0);
 720:	e1a00003 	mov	r0, r3
 724:	e12fff1e 	bx	lr
	 ------------------------------------------------*/
	if (tx_restart) {
		tx_restart = 0;
		U1THR = c;
	} else {
		cmd->buff[cmd->in & (CMD_BUFF_SIZE - 1)] = c;
 728:	e202c00f 	and	ip, r2, #15
 72c:	e083c00c 	add	ip, r3, ip
		cmd->in++;
 730:	e2822001 	add	r2, r2, #1
	 ------------------------------------------------*/
	if (tx_restart) {
		tx_restart = 0;
		U1THR = c;
	} else {
		cmd->buff[cmd->in & (CMD_BUFF_SIZE - 1)] = c;
 734:	e5cc0020 	strb	r0, [ip, #32]
		cmd->in++;
 738:	e5832018 	str	r2, [r3, #24]
	}

	return (0);
 73c:	e1a00001 	mov	r0, r1
 740:	e12fff1e 	bx	lr

	/*------------------------------------------------
	 If the buffer is full, return an error value.
	 ------------------------------------------------*/
	if ((cmd->in - cmd->out) >= CMD_BUFF_SIZE)
		return (-1);
 744:	e3e00000 	mvn	r0, #0
		cmd->buff[cmd->in & (CMD_BUFF_SIZE - 1)] = c;
		cmd->in++;
	}

	return (0);
}
 748:	e12fff1e 	bx	lr
 74c:	400000ac 	.word	0x400000ac
 750:	40000000 	.word	0x40000000
 754:	e0010000 	.word	0xe0010000

00000758 <com_getchar>:
/*------------------------------------------------------------------------------
 ------------------------------------------------------------------------------*/
int com_getchar (void){
	struct cmd_buff *cmd = &cmd_in;

	if ((cmd->in - cmd->out) == 0)
 758:	e59f3020 	ldr	r3, [pc, #32]	; 780 <com_getchar+0x28>
 75c:	e8930006 	ldm	r3, {r1, r2}
 760:	e1510002 	cmp	r1, r2
		return (-1);

	return (cmd->buff[(cmd->out++) & (CMD_BUFF_SIZE - 1)]);
 764:	1202100f 	andne	r1, r2, #15
 768:	10831001 	addne	r1, r3, r1
 76c:	12822001 	addne	r2, r2, #1
 770:	15d10008 	ldrbne	r0, [r1, #8]
 774:	15832004 	strne	r2, [r3, #4]
 ------------------------------------------------------------------------------*/
int com_getchar (void){
	struct cmd_buff *cmd = &cmd_in;

	if ((cmd->in - cmd->out) == 0)
		return (-1);
 778:	03e00000 	mvneq	r0, #0

	return (cmd->buff[(cmd->out++) & (CMD_BUFF_SIZE - 1)]);
}
 77c:	e12fff1e 	bx	lr
 780:	400000ac 	.word	0x400000ac

00000784 <update_position>:
	ADCR &= 0xFEDFF9FD; // Stop A/D Conversion
	return (i >> 6); // bit 6:15 is 10 bit AD value
}

//int count1 = 0;
void update_position(void){
 784:	e24ee004 	sub	lr, lr, #4
 788:	e92d41ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	if(calcount_g>0){//calibration
 78c:	e59f6100 	ldr	r6, [pc, #256]	; 894 <update_position+0x110>
 790:	e1d630f4 	ldrsh	r3, [r6, #4]
 794:	e3530000 	cmp	r3, #0
 798:	e59f50f8 	ldr	r5, [pc, #248]	; 898 <update_position+0x114>
 79c:	e59f40f8 	ldr	r4, [pc, #248]	; 89c <update_position+0x118>
 7a0:	da000021 	ble	82c <update_position+0xa8>
		calx += ADC0_Read();
 7a4:	e5957000 	ldr	r7, [r5]
 7a8:	ebfffea9 	bl	254 <ADC0_Read>
		posx += ((velx*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
 7ac:	e5943034 	ldr	r3, [r4, #52]	; 0x34
}

//int count1 = 0;
void update_position(void){
	if(calcount_g>0){//calibration
		calx += ADC0_Read();
 7b0:	e0800007 	add	r0, r0, r7
 7b4:	e5850000 	str	r0, [r5]
		posx += ((velx*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
 7b8:	e3a0500a 	mov	r5, #10
 7bc:	e0030395 	mul	r3, r5, r3
 7c0:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		caly += ADC1_Read();
 7c4:	e59f70d4 	ldr	r7, [pc, #212]	; 8a0 <update_position+0x11c>

//int count1 = 0;
void update_position(void){
	if(calcount_g>0){//calibration
		calx += ADC0_Read();
		posx += ((velx*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
 7c8:	e2422001 	sub	r2, r2, #1
 7cc:	e0823503 	add	r3, r2, r3, lsl #10
 7d0:	e5843030 	str	r3, [r4, #48]	; 0x30
		caly += ADC1_Read();
 7d4:	e5978000 	ldr	r8, [r7]
 7d8:	ebfffeb1 	bl	2a4 <ADC1_Read>
		posy += ((vely*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
 7dc:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
 7e0:	e0050592 	mul	r5, r2, r5
 7e4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 7e8:	e2433001 	sub	r3, r3, #1
 7ec:	e0835505 	add	r5, r3, r5, lsl #10
		if(calcount_g == 1){
 7f0:	e1d630f4 	ldrsh	r3, [r6, #4]
//int count1 = 0;
void update_position(void){
	if(calcount_g>0){//calibration
		calx += ADC0_Read();
		posx += ((velx*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
		caly += ADC1_Read();
 7f4:	e0800008 	add	r0, r0, r8
		posy += ((vely*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
		if(calcount_g == 1){
 7f8:	e3530001 	cmp	r3, #1
//int count1 = 0;
void update_position(void){
	if(calcount_g>0){//calibration
		calx += ADC0_Read();
		posx += ((velx*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
		caly += ADC1_Read();
 7fc:	e5870000 	str	r0, [r7]
		posy += ((vely*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
 800:	e5845038 	str	r5, [r4, #56]	; 0x38
		if(calcount_g == 1){
			//calx >>= 1;
			//caly >>= 1;
			posx = posy = 0;
 804:	03a03000 	moveq	r3, #0
			log_string("foi");
 808:	059f0094 	ldreq	r0, [pc, #148]	; 8a4 <update_position+0x120>
		caly += ADC1_Read();
		posy += ((vely*10) << 10) - 1;//only to let it in the same situation as in normal circumstances
		if(calcount_g == 1){
			//calx >>= 1;
			//caly >>= 1;
			posx = posy = 0;
 80c:	05843038 	streq	r3, [r4, #56]	; 0x38
 810:	05843030 	streq	r3, [r4, #48]	; 0x30
			log_string("foi");
 814:	0bffff07 	bleq	438 <log_string>
		}
		calcount_g--;
 818:	e59f3074 	ldr	r3, [pc, #116]	; 894 <update_position+0x110>
 81c:	e1d320b4 	ldrh	r2, [r3, #4]
 820:	e2422001 	sub	r2, r2, #1
 824:	e1c320b4 	strh	r2, [r3, #4]
 828:	ea000011 	b	874 <update_position+0xf0>
	}else{
		velx = (ADC0_Read() << 10) - calx;
 82c:	ebfffe88 	bl	254 <ADC0_Read>
 830:	e5953000 	ldr	r3, [r5]
 834:	e1a00500 	lsl	r0, r0, #10
 838:	e0630000 	rsb	r0, r3, r0
		posx += (velx*10);// fixed point with 5 hexa
 83c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
 840:	e3a0500a 	mov	r5, #10
			posx = posy = 0;
			log_string("foi");
		}
		calcount_g--;
	}else{
		velx = (ADC0_Read() << 10) - calx;
 844:	e5840034 	str	r0, [r4, #52]	; 0x34
		posx += (velx*10);// fixed point with 5 hexa
 848:	e0203095 	mla	r0, r5, r0, r3
 84c:	e5840030 	str	r0, [r4, #48]	; 0x30
		vely = (ADC1_Read() << 10) - caly;
 850:	ebfffe93 	bl	2a4 <ADC1_Read>
 854:	e1a00510 	lsl	r0, r0, r5
 858:	e59f3040 	ldr	r3, [pc, #64]	; 8a0 <update_position+0x11c>
 85c:	e5933000 	ldr	r3, [r3]
 860:	e0630000 	rsb	r0, r3, r0
		posy += (vely*10);// fixed point with 5 hexa
 864:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 868:	e0253590 	mla	r5, r0, r5, r3
		}
		calcount_g--;
	}else{
		velx = (ADC0_Read() << 10) - calx;
		posx += (velx*10);// fixed point with 5 hexa
		vely = (ADC1_Read() << 10) - caly;
 86c:	e584003c 	str	r0, [r4, #60]	; 0x3c
		posy += (vely*10);// fixed point with 5 hexa
 870:	e5845038 	str	r5, [r4, #56]	; 0x38
			log_string("\n");
			count1=0;
		}else
			count1++;*/
	}
	T3IR |= 0x01;//reset interruption
 874:	e59f302c 	ldr	r3, [pc, #44]	; 8a8 <update_position+0x124>
 878:	e5d32000 	ldrb	r2, [r3]
 87c:	e3822001 	orr	r2, r2, #1
 880:	e5c32000 	strb	r2, [r3]
	VICVectAddr = 0;
 884:	e3a02000 	mov	r2, #0
 888:	e3e03000 	mvn	r3, #0
 88c:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
 890:	e8fd81ff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}^
 894:	40000000 	.word	0x40000000
 898:	40000104 	.word	0x40000104
 89c:	400000ac 	.word	0x400000ac
 8a0:	40000110 	.word	0x40000110
 8a4:	00000b2a 	.word	0x00000b2a
 8a8:	e0074000 	.word	0xe0074000

000008ac <pwm_in_handler>:

void pwm_in_handler(void){
 8ac:	e92d101f 	push	{r0, r1, r2, r3, r4, ip}
	const unsigned short ir = T1IR;
 8b0:	e59f31e4 	ldr	r3, [pc, #484]	; a9c <pwm_in_handler+0x1f0>
 8b4:	e5d32000 	ldrb	r2, [r3]
	//capture 1.2 and 1.3
	if(ir & 0x40){//CAP1.2 pwm0
 8b8:	e3120040 	tst	r2, #64	; 0x40
 8bc:	0a000038 	beq	9a4 <pwm_in_handler+0xf8>
		if(T1CCR & 0x40){//rising edge
 8c0:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
 8c4:	e3120040 	tst	r2, #64	; 0x40
 8c8:	e59f21d0 	ldr	r2, [pc, #464]	; aa0 <pwm_in_handler+0x1f4>
 8cc:	0a000008 	beq	8f4 <pwm_in_handler+0x48>
			tmp0 = T1CR2;
 8d0:	e5931034 	ldr	r1, [r3, #52]	; 0x34
 8d4:	e1c210b0 	strh	r1, [r2]
			T1CCR &= ~0x40;//interrupt disabled for the rising edge
 8d8:	e59f21c4 	ldr	r2, [pc, #452]	; aa4 <pwm_in_handler+0x1f8>
 8dc:	e1d312b8 	ldrh	r1, [r3, #40]	; 0x28
 8e0:	e0012002 	and	r2, r1, r2
 8e4:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
			T1CCR |= 0x80;//interrupt enabled for the falling edge
 8e8:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
 8ec:	e3822080 	orr	r2, r2, #128	; 0x80
 8f0:	ea000026 	b	990 <pwm_in_handler+0xe4>
		}else{//falling
			unsigned short tmp = T1CR2 - tmp0;
 8f4:	e5931034 	ldr	r1, [r3, #52]	; 0x34
 8f8:	e1d230b0 	ldrh	r3, [r2]
 8fc:	e0633001 	rsb	r3, r3, r1
 900:	e1a03803 	lsl	r3, r3, #16
			if(tmp > 900 && tmp < 2200){
 904:	e1a01823 	lsr	r1, r3, #16
 908:	e59f2198 	ldr	r2, [pc, #408]	; aa8 <pwm_in_handler+0x1fc>
 90c:	e283333f 	add	r3, r3, #-67108864	; 0xfc000000
 910:	e283387b 	add	r3, r3, #8060928	; 0x7b0000
 914:	e1520823 	cmp	r2, r3, lsr #16
 918:	3a000015 	bcc	974 <pwm_in_handler+0xc8>
				if(calcountx>0){
 91c:	e59f3188 	ldr	r3, [pc, #392]	; aac <pwm_in_handler+0x200>
 920:	e1d320f6 	ldrsh	r2, [r3, #6]
 924:	e3520000 	cmp	r2, #0
 928:	e1d3c0b6 	ldrh	ip, [r3, #6]
 92c:	e1a00003 	mov	r0, r3
 930:	e59f3178 	ldr	r3, [pc, #376]	; ab0 <pwm_in_handler+0x204>
 934:	da000008 	ble	95c <pwm_in_handler+0xb0>
					calpx += tmp;
 938:	e5934040 	ldr	r4, [r3, #64]	; 0x40
					if(calcountx ==1){
 93c:	e3520001 	cmp	r2, #1
			T1CCR |= 0x80;//interrupt enabled for the falling edge
		}else{//falling
			unsigned short tmp = T1CR2 - tmp0;
			if(tmp > 900 && tmp < 2200){
				if(calcountx>0){
					calpx += tmp;
 940:	e0811004 	add	r1, r1, r4
 944:	e5831040 	str	r1, [r3, #64]	; 0x40
					if(calcountx ==1){
						calpx <<= 3;
 948:	01a01181 	lsleq	r1, r1, #3
 94c:	05831040 	streq	r1, [r3, #64]	; 0x40
					}
					calcountx--;
 950:	e24c3001 	sub	r3, ip, #1
 954:	e1c030b6 	strh	r3, [r0, #6]
 958:	ea000005 	b	974 <pwm_in_handler+0xc8>
				}else{
					int tmp2 = tmp;
					tmp2 <<= 11;
					tmp2 -= calpx;
					vposx += tmp2;//fixed point 5 hexa
 95c:	e59f2150 	ldr	r2, [pc, #336]	; ab4 <pwm_in_handler+0x208>
					}
					calcountx--;
				}else{
					int tmp2 = tmp;
					tmp2 <<= 11;
					tmp2 -= calpx;
 960:	e5933040 	ldr	r3, [r3, #64]	; 0x40
 964:	e5920000 	ldr	r0, [r2]
 968:	e0633000 	rsb	r3, r3, r0
					vposx += tmp2;//fixed point 5 hexa
 96c:	e0831581 	add	r1, r3, r1, lsl #11
 970:	e5821000 	str	r1, [r2]
					//pwm1 measured
					//pwm0in = tmp - (calpx >> 11);
				}
			}
			T1CCR &= ~0x80;
 974:	e59f3120 	ldr	r3, [pc, #288]	; a9c <pwm_in_handler+0x1f0>
 978:	e59f2138 	ldr	r2, [pc, #312]	; ab8 <pwm_in_handler+0x20c>
 97c:	e1d312b8 	ldrh	r1, [r3, #40]	; 0x28
 980:	e0012002 	and	r2, r1, r2
 984:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
			T1CCR |= 0x40;
 988:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
 98c:	e3822040 	orr	r2, r2, #64	; 0x40
 990:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
		}
		T1IR |= 0x40; //reset interruption
 994:	e59f3100 	ldr	r3, [pc, #256]	; a9c <pwm_in_handler+0x1f0>
 998:	e5d32000 	ldrb	r2, [r3]
 99c:	e3822040 	orr	r2, r2, #64	; 0x40
 9a0:	ea000037 	b	a84 <pwm_in_handler+0x1d8>
	}else{//CAP1.3 pwm1
		if(T1CCR & 0x200){//rising edge
 9a4:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
 9a8:	e3120c02 	tst	r2, #512	; 0x200
 9ac:	e59f2108 	ldr	r2, [pc, #264]	; abc <pwm_in_handler+0x210>
 9b0:	0a000008 	beq	9d8 <pwm_in_handler+0x12c>
			tmp1 = T1CR3;
 9b4:	e5931038 	ldr	r1, [r3, #56]	; 0x38
 9b8:	e1c210b0 	strh	r1, [r2]
			T1CCR &= ~0x200;
 9bc:	e59f20fc 	ldr	r2, [pc, #252]	; ac0 <pwm_in_handler+0x214>
 9c0:	e1d312b8 	ldrh	r1, [r3, #40]	; 0x28
 9c4:	e0012002 	and	r2, r1, r2
 9c8:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
			T1CCR |= 0x400;
 9cc:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
 9d0:	e3822b01 	orr	r2, r2, #1024	; 0x400
 9d4:	ea000026 	b	a74 <pwm_in_handler+0x1c8>
		}else{//falling
			unsigned short tmp = T1CR3 - tmp1;
 9d8:	e5931038 	ldr	r1, [r3, #56]	; 0x38
 9dc:	e1d230b0 	ldrh	r3, [r2]
 9e0:	e0633001 	rsb	r3, r3, r1
 9e4:	e1a03803 	lsl	r3, r3, #16
			if(tmp > 900 && tmp < 2200){
 9e8:	e1a01823 	lsr	r1, r3, #16
 9ec:	e59f20b4 	ldr	r2, [pc, #180]	; aa8 <pwm_in_handler+0x1fc>
 9f0:	e283333f 	add	r3, r3, #-67108864	; 0xfc000000
 9f4:	e283387b 	add	r3, r3, #8060928	; 0x7b0000
 9f8:	e1520823 	cmp	r2, r3, lsr #16
 9fc:	3a000015 	bcc	a58 <pwm_in_handler+0x1ac>
				if(calcounty>0){
 a00:	e59f30a4 	ldr	r3, [pc, #164]	; aac <pwm_in_handler+0x200>
 a04:	e1d320f8 	ldrsh	r2, [r3, #8]
 a08:	e3520000 	cmp	r2, #0
 a0c:	e1d3c0b8 	ldrh	ip, [r3, #8]
 a10:	e1a00003 	mov	r0, r3
 a14:	e59f3094 	ldr	r3, [pc, #148]	; ab0 <pwm_in_handler+0x204>
 a18:	da000008 	ble	a40 <pwm_in_handler+0x194>
					calpy += tmp;
 a1c:	e5934044 	ldr	r4, [r3, #68]	; 0x44
					if(calcounty==1){
 a20:	e3520001 	cmp	r2, #1
			T1CCR |= 0x400;
		}else{//falling
			unsigned short tmp = T1CR3 - tmp1;
			if(tmp > 900 && tmp < 2200){
				if(calcounty>0){
					calpy += tmp;
 a24:	e0811004 	add	r1, r1, r4
 a28:	e5831044 	str	r1, [r3, #68]	; 0x44
					if(calcounty==1){
						calpy <<= 3;
 a2c:	01a01181 	lsleq	r1, r1, #3
 a30:	05831044 	streq	r1, [r3, #68]	; 0x44
					}
					calcounty--;
 a34:	e24c3001 	sub	r3, ip, #1
 a38:	e1c030b8 	strh	r3, [r0, #8]
 a3c:	ea000005 	b	a58 <pwm_in_handler+0x1ac>
				}else{
					int tmp2 = tmp;
					tmp2 <<= 11;
					tmp2 -= calpy;
					vposy += tmp2;
 a40:	e59f207c 	ldr	r2, [pc, #124]	; ac4 <pwm_in_handler+0x218>
					}
					calcounty--;
				}else{
					int tmp2 = tmp;
					tmp2 <<= 11;
					tmp2 -= calpy;
 a44:	e5933044 	ldr	r3, [r3, #68]	; 0x44
 a48:	e5920000 	ldr	r0, [r2]
 a4c:	e0633000 	rsb	r3, r3, r0
					vposy += tmp2;
 a50:	e0831581 	add	r1, r3, r1, lsl #11
 a54:	e5821000 	str	r1, [r2]
					//pwm1 measured
					//pwm1in = tmp - (calpy >> 11);
				}
			}
			T1CCR &= ~0x400;
 a58:	e59f303c 	ldr	r3, [pc, #60]	; a9c <pwm_in_handler+0x1f0>
 a5c:	e59f2064 	ldr	r2, [pc, #100]	; ac8 <pwm_in_handler+0x21c>
 a60:	e1d312b8 	ldrh	r1, [r3, #40]	; 0x28
 a64:	e0012002 	and	r2, r1, r2
 a68:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
			T1CCR |= 0x200;
 a6c:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
 a70:	e3822c02 	orr	r2, r2, #512	; 0x200
 a74:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
		}
		T1IR |= 0x80; //reset interruption
 a78:	e59f301c 	ldr	r3, [pc, #28]	; a9c <pwm_in_handler+0x1f0>
 a7c:	e5d32000 	ldrb	r2, [r3]
 a80:	e3822080 	orr	r2, r2, #128	; 0x80
 a84:	e5c32000 	strb	r2, [r3]
	}
	VICVectAddr = 0;
 a88:	e3a02000 	mov	r2, #0
 a8c:	e3e03000 	mvn	r3, #0
 a90:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
 a94:	e8bd101f 	pop	{r0, r1, r2, r3, r4, ip}
 a98:	e25ef004 	subs	pc, lr, #4
 a9c:	e0008000 	.word	0xe0008000
 aa0:	400000f4 	.word	0x400000f4
 aa4:	0000ffbf 	.word	0x0000ffbf
 aa8:	00000512 	.word	0x00000512
 aac:	40000000 	.word	0x40000000
 ab0:	400000ac 	.word	0x400000ac
 ab4:	40000100 	.word	0x40000100
 ab8:	0000ff7f 	.word	0x0000ff7f
 abc:	400000fc 	.word	0x400000fc
 ac0:	0000fdff 	.word	0x0000fdff
 ac4:	40000108 	.word	0x40000108
 ac8:	0000fbff 	.word	0x0000fbff

00000acc <pid>:

void pid(void){
 acc:	e92d4008 	push	{r3, lr}
	//}

	//T2MR0 = 18000 + pwm0in;//pwm0out;//set pwm0 output
	//T2MR1 = 18000 + pwm1in;//pwm1out;//set pwm1 output

	log_string("p");
 ad0:	e59f0024 	ldr	r0, [pc, #36]	; afc <pid+0x30>
 ad4:	ebfffe57 	bl	438 <log_string>
	T2IR |= 0x04;
 ad8:	e59f3020 	ldr	r3, [pc, #32]	; b00 <pid+0x34>
 adc:	e5d32000 	ldrb	r2, [r3]
 ae0:	e3822004 	orr	r2, r2, #4
 ae4:	e5c32000 	strb	r2, [r3]
	VICVectAddr = 0;
 ae8:	e3a02000 	mov	r2, #0
 aec:	e3e03000 	mvn	r3, #0
 af0:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
 af4:	e8bd4008 	pop	{r3, lr}
 af8:	e12fff1e 	bx	lr
 afc:	00000b2e 	.word	0x00000b2e
 b00:	e0070000 	.word	0xe0070000

00000b04 <ascii>:
 b04:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 b14:	71726900 72726520 6900726f 6963696e     .irq error.inici
 b24:	6f646e61 6f66000a 00700069              ando..foi.p.
