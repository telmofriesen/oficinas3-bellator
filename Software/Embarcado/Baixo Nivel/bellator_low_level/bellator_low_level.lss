
bellator_low_level.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001880  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.extab    000000fc  00001880  00001880  00009880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .ARM.exidx    00000110  0000197c  0000197c  0000997c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .interp       00000013  00001a8c  00001a8c  00009a8c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .gnu.version  0000000c  00001aa0  00001aa0  00009aa0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .gnu.version_r 00000020  00001aac  00001aac  00009aac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .dynsym       00000060  00001acc  00001acc  00009acc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dynstr       0000006a  00001b2c  00001b2c  00009b2c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .hash         0000002c  00001b98  00001b98  00009b98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .dynamic      00000090  40000000  00001bc4  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .got.plt      0000000c  40000090  00001c54  00010090  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          00000204  4000009c  00001c60  0001009c  2**2
                  ALLOC
 12 .stack        00000400  400002a0  00001e64  0001009c  2**0
                  ALLOC
 13 .ARM.attributes 0000002e  00000000  00000000  0001009c  2**0
                  CONTENTS, READONLY
 14 .comment      0000002a  00000000  00000000  000100ca  2**0
                  CONTENTS, READONLY
 15 .debug_aranges 00000040  00000000  00000000  000100f8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_pubnames 00000382  00000000  00000000  00010138  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_info   00000e17  00000000  00000000  000104ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_abbrev 000003ac  00000000  00000000  000112d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_line   000003df  00000000  00000000  0001167d  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame  000004cc  00000000  00000000  00011a5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_str    000005c6  00000000  00000000  00011f28  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_loc    00000b47  00000000  00000000  000124ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_pubtypes 00000030  00000000  00000000  00013035  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_ranges 00000080  00000000  00000000  00013065  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_boot>:
_boot:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
       0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
       4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
       8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
       c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
      10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
      14:	e1a00000 	nop			; (mov r0, r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
      18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xbfffe990>
        ldr   pc,_fiq                   // FIQ - _fiq
      1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
      20:	00000038 	.word	0x00000038

00000024 <_swi>:
      24:	0000003c 	.word	0x0000003c

00000028 <_pabt>:
      28:	00000040 	.word	0x00000040

0000002c <_dabt>:
      2c:	00000044 	.word	0x00000044

00000030 <_irq>:
      30:	00000048 	.word	0x00000048

00000034 <_fiq>:
      34:	0000004c 	.word	0x0000004c

00000038 <__undf>:
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
      38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
      3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
      40:	eafffffe 	b	40 <__pabt>

00000044 <__dabt>:
__dabt: b     .                         // data abort
      44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
      48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .				            // FIQ
      4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
      50:	e59f0098 	ldr	r0, [pc, #152]	; f0 <abort+0x4>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
      54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
      58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
      5c:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
      60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
      64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
      68:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
      6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
      70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
      74:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
      78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
      7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
      80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
      84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
      88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
      8c:	e2400004 	sub	r0, r0, #4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
      90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
      94:	e1a0d000 	mov	sp, r0


// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
      98:	e59f1054 	ldr	r1, [pc, #84]	; f4 <abort+0x8>
        ldr   r2,=_data                 // -> data start
      9c:	e59f2054 	ldr	r2, [pc, #84]	; f8 <abort+0xc>
        ldr   r3,=_edata                // -> end of data
      a0:	e59f3054 	ldr	r3, [pc, #84]	; fc <abort+0x10>
1:      cmp   r2,r3                     // check if data to move
      a4:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
      a8:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
      ac:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
      b0:	3afffffb 	bcc	a4 <IRQ_STACK_SIZE+0x24>
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
      b4:	e3a00000 	mov	r0, #0
        ldr   r1,=__bss_start           // -> bss start
      b8:	e59f1040 	ldr	r1, [pc, #64]	; 100 <abort+0x14>
        ldr   r2,=__bss_end__           // -> bss end
      bc:	e59f2040 	ldr	r2, [pc, #64]	; 104 <abort+0x18>
2:      cmp   r1,r2                     // check if data to clear
      c0:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
      c4:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
      c8:	3afffffc 	bcc	c0 <IRQ_STACK_SIZE+0x40>

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
      cc:	e3a00000 	mov	r0, #0
        mov   r1,r0
      d0:	e1a01000 	mov	r1, r0
        mov   r2,r0
      d4:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
      d8:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
      dc:	e1a07000 	mov	r7, r0
        ldr   r10,=main
      e0:	e59fa020 	ldr	sl, [pc, #32]	; 108 <abort+0x1c>
        mov   lr,pc
      e4:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
      e8:	e12fff1a 	bx	sl

000000ec <abort>:
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
      ec:	eafffffe 	b	ec <abort>
      f0:	400006a0 	.word	0x400006a0
      f4:	00001bc4 	.word	0x00001bc4
      f8:	40000000 	.word	0x40000000
      fc:	4000009c 	.word	0x4000009c
     100:	4000009c 	.word	0x4000009c
     104:	400002a0 	.word	0x400002a0
     108:	0000114c 	.word	0x0000114c

0000010c <log_char>:

	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
}

static void log_char(char c){
	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
     10c:	e59f3014 	ldr	r3, [pc, #20]	; 128 <log_char+0x1c>
     110:	e5c30000 	strb	r0, [r3]
	while(!(U0LSR & 0x40));
     114:	e1a02003 	mov	r2, r3
     118:	e5d23014 	ldrb	r3, [r2, #20]
     11c:	e3130040 	tst	r3, #64	; 0x40
     120:	0afffffc 	beq	118 <log_char+0xc>
}
     124:	e12fff1e 	bx	lr
     128:	e000c000 	.word	0xe000c000

0000012c <i2c_read_bytes_isr>:
}

/**
 * i2c interrupt handler
 */
void i2c_read_bytes_isr(void) {
     12c:	e92d100f 	push	{r0, r1, r2, r3, ip}
     130:	e24dd00c 	sub	sp, sp, #12
	log_string_i2c(">> read_bytes_isr\n");
	volatile int temp = 0;
     134:	e3a03000 	mov	r3, #0
     138:	e58d3004 	str	r3, [sp, #4]
	temp = I2C1STAT;
     13c:	e59f32a0 	ldr	r3, [pc, #672]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     140:	e5d33004 	ldrb	r3, [r3, #4]
     144:	e20330ff 	and	r3, r3, #255	; 0xff
     148:	e58d3004 	str	r3, [sp, #4]

	switch (temp) {
     14c:	e59d3004 	ldr	r3, [sp, #4]
     150:	e2433008 	sub	r3, r3, #8
     154:	e3530050 	cmp	r3, #80	; 0x50
     158:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
     15c:	ea000097 	b	3c0 <i2c_read_bytes_isr+0x294>
     160:	000002a4 	.word	0x000002a4
     164:	000003c0 	.word	0x000003c0
     168:	000003c0 	.word	0x000003c0
     16c:	000003c0 	.word	0x000003c0
     170:	000003c0 	.word	0x000003c0
     174:	000003c0 	.word	0x000003c0
     178:	000003c0 	.word	0x000003c0
     17c:	000003c0 	.word	0x000003c0
     180:	000002bc 	.word	0x000002bc
     184:	000003c0 	.word	0x000003c0
     188:	000003c0 	.word	0x000003c0
     18c:	000003c0 	.word	0x000003c0
     190:	000003c0 	.word	0x000003c0
     194:	000003c0 	.word	0x000003c0
     198:	000003c0 	.word	0x000003c0
     19c:	000003c0 	.word	0x000003c0
     1a0:	000002d4 	.word	0x000002d4
     1a4:	000003c0 	.word	0x000003c0
     1a8:	000003c0 	.word	0x000003c0
     1ac:	000003c0 	.word	0x000003c0
     1b0:	000003c0 	.word	0x000003c0
     1b4:	000003c0 	.word	0x000003c0
     1b8:	000003c0 	.word	0x000003c0
     1bc:	000003c0 	.word	0x000003c0
     1c0:	000003cc 	.word	0x000003cc
     1c4:	000003c0 	.word	0x000003c0
     1c8:	000003c0 	.word	0x000003c0
     1cc:	000003c0 	.word	0x000003c0
     1d0:	000003c0 	.word	0x000003c0
     1d4:	000003c0 	.word	0x000003c0
     1d8:	000003c0 	.word	0x000003c0
     1dc:	000003c0 	.word	0x000003c0
     1e0:	000002f0 	.word	0x000002f0
     1e4:	000003c0 	.word	0x000003c0
     1e8:	000003c0 	.word	0x000003c0
     1ec:	000003c0 	.word	0x000003c0
     1f0:	000003c0 	.word	0x000003c0
     1f4:	000003c0 	.word	0x000003c0
     1f8:	000003c0 	.word	0x000003c0
     1fc:	000003c0 	.word	0x000003c0
     200:	000003cc 	.word	0x000003cc
     204:	000003c0 	.word	0x000003c0
     208:	000003c0 	.word	0x000003c0
     20c:	000003c0 	.word	0x000003c0
     210:	000003c0 	.word	0x000003c0
     214:	000003c0 	.word	0x000003c0
     218:	000003c0 	.word	0x000003c0
     21c:	000003c0 	.word	0x000003c0
     220:	000003cc 	.word	0x000003cc
     224:	000003c0 	.word	0x000003c0
     228:	000003c0 	.word	0x000003c0
     22c:	000003c0 	.word	0x000003c0
     230:	000003c0 	.word	0x000003c0
     234:	000003c0 	.word	0x000003c0
     238:	000003c0 	.word	0x000003c0
     23c:	000003c0 	.word	0x000003c0
     240:	00000308 	.word	0x00000308
     244:	000003c0 	.word	0x000003c0
     248:	000003c0 	.word	0x000003c0
     24c:	000003c0 	.word	0x000003c0
     250:	000003c0 	.word	0x000003c0
     254:	000003c0 	.word	0x000003c0
     258:	000003c0 	.word	0x000003c0
     25c:	000003c0 	.word	0x000003c0
     260:	000003cc 	.word	0x000003cc
     264:	000003c0 	.word	0x000003c0
     268:	000003c0 	.word	0x000003c0
     26c:	000003c0 	.word	0x000003c0
     270:	000003c0 	.word	0x000003c0
     274:	000003c0 	.word	0x000003c0
     278:	000003c0 	.word	0x000003c0
     27c:	000003c0 	.word	0x000003c0
     280:	00000330 	.word	0x00000330
     284:	000003c0 	.word	0x000003c0
     288:	000003c0 	.word	0x000003c0
     28c:	000003c0 	.word	0x000003c0
     290:	000003c0 	.word	0x000003c0
     294:	000003c0 	.word	0x000003c0
     298:	000003c0 	.word	0x000003c0
     29c:	000003c0 	.word	0x000003c0
     2a0:	00000370 	.word	0x00000370
	case TW_START: // A START condition has been transmitted.
		log_string_i2c("TW_START\n");
		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
     2a4:	e59f3138 	ldr	r3, [pc, #312]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     2a8:	e3e0202f 	mvn	r2, #47	; 0x2f
     2ac:	e5c32008 	strb	r2, [r3, #8]
		I2C1CONCLR = 0x28; // Clear SI and STA flag
     2b0:	e3a02028 	mov	r2, #40	; 0x28
     2b4:	e5c32018 	strb	r2, [r3, #24]
		break;
     2b8:	ea000043 	b	3cc <i2c_read_bytes_isr+0x2a0>
	case TW_REP_START: // A repeated START	condition has been transmitted.
		log_string_i2c("TW_REP_START\n");
		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_READ; // Slave address + Read
     2bc:	e59f3120 	ldr	r3, [pc, #288]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     2c0:	e3e0202e 	mvn	r2, #46	; 0x2e
     2c4:	e5c32008 	strb	r2, [r3, #8]
		I2C1CONCLR = 0x28; // Clear SI and STA flag
     2c8:	e3a02028 	mov	r2, #40	; 0x28
     2cc:	e5c32018 	strb	r2, [r3, #24]
		break;
     2d0:	ea00003d 	b	3cc <i2c_read_bytes_isr+0x2a0>
	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
		log_string_i2c("TW_MT_SLA_ACK\n");
		I2C1DAT = ra_buff; // Register address to be written
     2d4:	e59f310c 	ldr	r3, [pc, #268]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     2d8:	e5d32000 	ldrb	r2, [r3]
     2dc:	e59f3100 	ldr	r3, [pc, #256]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     2e0:	e5c32008 	strb	r2, [r3, #8]
		I2C1CONCLR = 0x08; // Clear SI
     2e4:	e3a02008 	mov	r2, #8
     2e8:	e5c32018 	strb	r2, [r3, #24]
		break;
     2ec:	ea000036 	b	3cc <i2c_read_bytes_isr+0x2a0>
	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
		log_string_i2c("TW_MT_SLA_NACK\n");
		break;
	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
		log_string_i2c("TW_MT_DATA_ACK\n");
		I2C1CONSET = 0x20; // Transmit start condition
     2f0:	e59f30ec 	ldr	r3, [pc, #236]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     2f4:	e3a02020 	mov	r2, #32
     2f8:	e5c32000 	strb	r2, [r3]
		I2C1CONCLR = 0x08; // Clear SI
     2fc:	e3a02008 	mov	r2, #8
     300:	e5c32018 	strb	r2, [r3, #24]
		break;
     304:	ea000030 	b	3cc <i2c_read_bytes_isr+0x2a0>
		log_string_i2c("TW_MT_ARB_LOST\n");
		break;

	case TW_MR_SLA_ACK: // SLA+R has been transmitted; ACK has been received.
		log_string_i2c("TW_MR_SLA_ACK\n");
		if(buff_size > 1)
     308:	e59f30d8 	ldr	r3, [pc, #216]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     30c:	e5933004 	ldr	r3, [r3, #4]
     310:	e3530001 	cmp	r3, #1
			I2C1CONSET = 0x04; // Transmit ACK on data receives
     314:	c3a02004 	movgt	r2, #4
     318:	c59f30c4 	ldrgt	r3, [pc, #196]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     31c:	c5c32000 	strbgt	r2, [r3]
		I2C1CONCLR = 0x08; // Clear SI
     320:	e3a02008 	mov	r2, #8
     324:	e59f30b8 	ldr	r3, [pc, #184]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     328:	e5c32018 	strb	r2, [r3, #24]
		break;
     32c:	ea000026 	b	3cc <i2c_read_bytes_isr+0x2a0>
	case TW_MR_DATA_ACK: // Data byte has been received; ACK has been returned.
		log_string_i2c("TW_MR_DATA_ACK\n");
		log_string_i2c("pos: ");
		log_int_i2c(buff_pos);
		log_string_i2c("\n");
		if ((buff_pos + 2) < buff_size) {
     330:	e59f20b0 	ldr	r2, [pc, #176]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     334:	e5923008 	ldr	r3, [r2, #8]
     338:	e2831002 	add	r1, r3, #2
     33c:	e5922004 	ldr	r2, [r2, #4]
     340:	e1510002 	cmp	r1, r2
			c_buff[buff_pos++] = I2C1DAT;
     344:	e59f2098 	ldr	r2, [pc, #152]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     348:	e5d2c008 	ldrb	ip, [r2, #8]
     34c:	e59f1094 	ldr	r1, [pc, #148]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     350:	e591000c 	ldr	r0, [r1, #12]
     354:	e7c0c003 	strb	ip, [r0, r3]
     358:	e2833001 	add	r3, r3, #1
     35c:	e5813008 	str	r3, [r1, #8]
			I2C1CONCLR = 0x08; // Clear SI
     360:	b3a03008 	movlt	r3, #8
		}
		else {
			c_buff[buff_pos++] = I2C1DAT;
			I2C1CONCLR = 0x0C; // Transmit NACK on next data receive, Clear SI
     364:	a3a0300c 	movge	r3, #12
     368:	e5c23018 	strb	r3, [r2, #24]
     36c:	ea000016 	b	3cc <i2c_read_bytes_isr+0x2a0>
	case TW_MR_DATA_NACK: // Data byte has been received; NOT ACK has been returned.
		log_string_i2c("TW_MR_DATA_NACK\n");
		log_string_i2c("pos: ");
		log_int_i2c(buff_pos);
		log_string_i2c("\n");
		if (buff_pos < buff_size) {
     370:	e59f2070 	ldr	r2, [pc, #112]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     374:	e992000c 	ldmib	r2, {r2, r3}
     378:	e1530002 	cmp	r3, r2
     37c:	aa000006 	bge	39c <i2c_read_bytes_isr+0x270>
			c_buff[buff_pos++] = I2C1DAT;
     380:	e59f205c 	ldr	r2, [pc, #92]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     384:	e5d20008 	ldrb	r0, [r2, #8]
     388:	e59f2058 	ldr	r2, [pc, #88]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     38c:	e592100c 	ldr	r1, [r2, #12]
     390:	e7c10003 	strb	r0, [r1, r3]
     394:	e2833001 	add	r3, r3, #1
     398:	e5823008 	str	r3, [r2, #8]
		}
		I2C1CONSET = 0x10; // Transmit stop condition
     39c:	e59f3040 	ldr	r3, [pc, #64]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     3a0:	e3a02010 	mov	r2, #16
     3a4:	e5c32000 	strb	r2, [r3]
		I2C1CONCLR = 0x08; // Clear SI
     3a8:	e3a02008 	mov	r2, #8
     3ac:	e5c32018 	strb	r2, [r3, #24]
		busy = 0; // data ready to be returned
     3b0:	e3a02000 	mov	r2, #0
     3b4:	e59f302c 	ldr	r3, [pc, #44]	; 3e8 <i2c_read_bytes_isr+0x2bc>
     3b8:	e5832010 	str	r2, [r3, #16]
		break;
     3bc:	ea000002 	b	3cc <i2c_read_bytes_isr+0x2a0>
	default:
		log_string_warning("[i2c] default: ");
		log_int_warning(temp);
		log_string_warning("\n");
		//I2C1CONSET = 0x10; // Transmit stop condition
		I2C1CONCLR = 0x08; // Clear SI
     3c0:	e3a02008 	mov	r2, #8
     3c4:	e59f3018 	ldr	r3, [pc, #24]	; 3e4 <i2c_read_bytes_isr+0x2b8>
     3c8:	e5c32018 	strb	r2, [r3, #24]
		//busy = 0; // data ready to be returned
		break;
	}

	VICVectAddr = 0;
     3cc:	e3a02000 	mov	r2, #0
     3d0:	e3e03000 	mvn	r3, #0
     3d4:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
     3d8:	e28dd00c 	add	sp, sp, #12
     3dc:	e8bd100f 	pop	{r0, r1, r2, r3, ip}
     3e0:	e25ef004 	subs	pc, lr, #4
     3e4:	e005c000 	.word	0xe005c000
     3e8:	4000009c 	.word	0x4000009c

000003ec <i2c_write_byte_isr>:
}

/**
 * i2c interrupt handler
 */
void i2c_write_byte_isr(void) {
     3ec:	e92d000f 	push	{r0, r1, r2, r3}
     3f0:	e24dd008 	sub	sp, sp, #8
	log_string_i2c(">> i2c_write_byte_isr\n");
	volatile int temp = 0;
     3f4:	e3a03000 	mov	r3, #0
     3f8:	e58d3004 	str	r3, [sp, #4]
	temp = I2C1STAT;
     3fc:	e59f3198 	ldr	r3, [pc, #408]	; 59c <STACK_SIZE+0x19c>
     400:	e5d33004 	ldrb	r3, [r3, #4]
     404:	e20330ff 	and	r3, r3, #255	; 0xff
     408:	e58d3004 	str	r3, [sp, #4]

	switch (temp) {
     40c:	e59d3004 	ldr	r3, [sp, #4]
     410:	e2433008 	sub	r3, r3, #8
     414:	e3530028 	cmp	r3, #40	; 0x28
     418:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
     41c:	ea000058 	b	584 <STACK_SIZE+0x184>
     420:	000004c4 	.word	0x000004c4
     424:	00000584 	.word	0x00000584
     428:	00000584 	.word	0x00000584
     42c:	00000584 	.word	0x00000584
     430:	00000584 	.word	0x00000584
     434:	00000584 	.word	0x00000584
     438:	00000584 	.word	0x00000584
     43c:	00000584 	.word	0x00000584
     440:	00000584 	.word	0x00000584
     444:	00000584 	.word	0x00000584
     448:	00000584 	.word	0x00000584
     44c:	00000584 	.word	0x00000584
     450:	00000584 	.word	0x00000584
     454:	00000584 	.word	0x00000584
     458:	00000584 	.word	0x00000584
     45c:	00000584 	.word	0x00000584
     460:	000004dc 	.word	0x000004dc
     464:	00000584 	.word	0x00000584
     468:	00000584 	.word	0x00000584
     46c:	00000584 	.word	0x00000584
     470:	00000584 	.word	0x00000584
     474:	00000584 	.word	0x00000584
     478:	00000584 	.word	0x00000584
     47c:	00000584 	.word	0x00000584
     480:	00000584 	.word	0x00000584
     484:	00000584 	.word	0x00000584
     488:	00000584 	.word	0x00000584
     48c:	00000584 	.word	0x00000584
     490:	00000584 	.word	0x00000584
     494:	00000584 	.word	0x00000584
     498:	00000584 	.word	0x00000584
     49c:	00000584 	.word	0x00000584
     4a0:	000004f8 	.word	0x000004f8
     4a4:	00000584 	.word	0x00000584
     4a8:	00000584 	.word	0x00000584
     4ac:	00000584 	.word	0x00000584
     4b0:	00000584 	.word	0x00000584
     4b4:	00000584 	.word	0x00000584
     4b8:	00000584 	.word	0x00000584
     4bc:	00000584 	.word	0x00000584
     4c0:	0000055c 	.word	0x0000055c
	case TW_START: // A START condition has been transmitted.
		log_string_i2c("TW_START\n");
		I2C1DAT = (MPU6050_ADDRESS_AD0_LOW << 0x1) | I2C_WRITE; // Slave address + Write
     4c4:	e59f30d0 	ldr	r3, [pc, #208]	; 59c <STACK_SIZE+0x19c>
     4c8:	e3e0202f 	mvn	r2, #47	; 0x2f
     4cc:	e5c32008 	strb	r2, [r3, #8]
		I2C1CONCLR = 0x28; // Clear SI and STA flag
     4d0:	e3a02028 	mov	r2, #40	; 0x28
     4d4:	e5c32018 	strb	r2, [r3, #24]
		break;
     4d8:	ea000029 	b	584 <STACK_SIZE+0x184>
	case TW_REP_START: // A repeated START	condition has been transmitted.
		log_string_i2c("TW_REP_START\n");
		break;
	case TW_MT_SLA_ACK: // SLA+W has been transmitted; ACK has been received.
		log_string_i2c("TW_MT_SLA_ACK\n");
		I2C1DAT = ra_buff; // Register address to be written
     4dc:	e59f30bc 	ldr	r3, [pc, #188]	; 5a0 <STACK_SIZE+0x1a0>
     4e0:	e5d32000 	ldrb	r2, [r3]
     4e4:	e59f30b0 	ldr	r3, [pc, #176]	; 59c <STACK_SIZE+0x19c>
     4e8:	e5c32008 	strb	r2, [r3, #8]
		I2C1CONCLR = 0x08; // Clear SI
     4ec:	e3a02008 	mov	r2, #8
     4f0:	e5c32018 	strb	r2, [r3, #24]
		break;
     4f4:	ea000022 	b	584 <STACK_SIZE+0x184>
	case TW_MT_SLA_NACK: // SLA+W has been transmitted; NOT ACK has been received.
		log_string_i2c("TW_MT_SLA_NACK\n");
		break;
	case TW_MT_DATA_ACK: // Data byte in I2DAT has been transmitted; ACK has been received.
		log_string_i2c("TW_MT_DATA_ACK\n");
		if (buff_pos < buff_size) {
     4f8:	e59f20a0 	ldr	r2, [pc, #160]	; 5a0 <STACK_SIZE+0x1a0>
     4fc:	e992000c 	ldmib	r2, {r2, r3}
     500:	e1530002 	cmp	r3, r2
     504:	aa000009 	bge	530 <STACK_SIZE+0x130>
			I2C1DAT = c_buff[buff_pos++]; // Send data
     508:	e59f1090 	ldr	r1, [pc, #144]	; 5a0 <STACK_SIZE+0x1a0>
     50c:	e591200c 	ldr	r2, [r1, #12]
     510:	e7d20003 	ldrb	r0, [r2, r3]
     514:	e59f2080 	ldr	r2, [pc, #128]	; 59c <STACK_SIZE+0x19c>
     518:	e5c20008 	strb	r0, [r2, #8]
     51c:	e2833001 	add	r3, r3, #1
     520:	e5813008 	str	r3, [r1, #8]
			I2C1CONCLR = 0x08; // Clear SI
     524:	e3a03008 	mov	r3, #8
     528:	e5c23018 	strb	r3, [r2, #24]
     52c:	ea000014 	b	584 <STACK_SIZE+0x184>
		} else {
			I2C1CONSET |= 0x01 << 4; // Transmit stop condition
     530:	e59f3064 	ldr	r3, [pc, #100]	; 59c <STACK_SIZE+0x19c>
     534:	e5d32000 	ldrb	r2, [r3]
     538:	e20220ff 	and	r2, r2, #255	; 0xff
     53c:	e3822010 	orr	r2, r2, #16
     540:	e5c32000 	strb	r2, [r3]
			I2C1CONCLR = 0x08; // Clear SI
     544:	e3a02008 	mov	r2, #8
     548:	e5c32018 	strb	r2, [r3, #24]
			busy = 0; // done
     54c:	e3a02000 	mov	r2, #0
     550:	e59f3048 	ldr	r3, [pc, #72]	; 5a0 <STACK_SIZE+0x1a0>
     554:	e5832010 	str	r2, [r3, #16]
     558:	ea000009 	b	584 <STACK_SIZE+0x184>
		}
		break;
	case TW_MT_DATA_NACK: // Data byte in I2DAT has been transmitted; NOT ACK has been received.
		log_string_i2c("TW_MT_DATA_NACK\n");
		I2C1CONSET |= 0x01 << 4; // Transmit stop condition
     55c:	e59f3038 	ldr	r3, [pc, #56]	; 59c <STACK_SIZE+0x19c>
     560:	e5d32000 	ldrb	r2, [r3]
     564:	e20220ff 	and	r2, r2, #255	; 0xff
     568:	e3822010 	orr	r2, r2, #16
     56c:	e5c32000 	strb	r2, [r3]
		I2C1CONCLR = 0x08; // Clear SI
     570:	e3a02008 	mov	r2, #8
     574:	e5c32018 	strb	r2, [r3, #24]
		busy = 0; // done
     578:	e3a02000 	mov	r2, #0
     57c:	e59f301c 	ldr	r3, [pc, #28]	; 5a0 <STACK_SIZE+0x1a0>
     580:	e5832010 	str	r2, [r3, #16]
	default:
		log_string_i2c("default\n");
		break;
	}

	VICVectAddr = 0;
     584:	e3a02000 	mov	r2, #0
     588:	e3e03000 	mvn	r3, #0
     58c:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
     590:	e28dd008 	add	sp, sp, #8
     594:	e8bd000f 	pop	{r0, r1, r2, r3}
     598:	e25ef004 	subs	pc, lr, #4
     59c:	e005c000 	.word	0xe005c000
     5a0:	4000009c 	.word	0x4000009c

000005a4 <protocol_in>:
 * Communication Protocol state machine implementation;
 * This is triggered on uart1 interruption
 * This handles the following commands
 *
 */
void protocol_in(void){
     5a4:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
     5a8:	e24dd00c 	sub	sp, sp, #12
			dummy = U1LSR; // Just clear the interrupt source
			break;

		case 0x04: // Receive Data Available
		case 0x0C: // Character Time-Out
			cmd_in.buff[cmd_in.i] = U1RBR;
     5ac:	e59f31e4 	ldr	r3, [pc, #484]	; 798 <protocol_in+0x1f4>
inline void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel) {

	if (left_wheel > 8)
		left_wheel -= 8;
	else
		left_wheel = 8;
     5b0:	e5932014 	ldr	r2, [r3, #20]

	volatile char dummy;
	volatile char iir;

	// Repeat while there is at least one interrupt source.
	while (((iir = U1IIR) & 0x01) == 0) {
     5b4:	e59f31e0 	ldr	r3, [pc, #480]	; 79c <protocol_in+0x1f8>
			dummy = U1LSR; // Just clear the interrupt source
			break;

		case 0x04: // Receive Data Available
		case 0x0C: // Character Time-Out
			cmd_in.buff[cmd_in.i] = U1RBR;
     5b8:	e59f11d8 	ldr	r1, [pc, #472]	; 798 <protocol_in+0x1f4>
				}
				// SYNC
				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
					log_string_debug("SYNC\n");

					send_data = 1;
     5bc:	e3a0b001 	mov	fp, #1

					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
     5c0:	e3a0c000 	mov	ip, #0

	if (left_wheel & PWM_DIR) { // Forward
		T1MR0 = 256;
		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
	} else { // Backwards
		T1MR1 = 256;
     5c4:	e59f61d4 	ldr	r6, [pc, #468]	; 7a0 <protocol_in+0x1fc>
     5c8:	e3a05c01 	mov	r5, #256	; 0x100

	if (right_wheel & PWM_DIR) { // Forward
		T0MR2 = 256;
		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
	} else { // Backwards
		T0MR1 = 256;
     5cc:	e59f41d0 	ldr	r4, [pc, #464]	; 7a4 <protocol_in+0x200>

	volatile char dummy;
	volatile char iir;

	// Repeat while there is at least one interrupt source.
	while (((iir = U1IIR) & 0x01) == 0) {
     5d0:	ea000062 	b	760 <protocol_in+0x1bc>
		switch (iir & 0x0E) {
     5d4:	e5dd0006 	ldrb	r0, [sp, #6]
     5d8:	e200000e 	and	r0, r0, #14
     5dc:	e350000c 	cmp	r0, #12
     5e0:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
     5e4:	ea00005d 	b	760 <protocol_in+0x1bc>
     5e8:	00000754 	.word	0x00000754
     5ec:	00000760 	.word	0x00000760
     5f0:	00000744 	.word	0x00000744
     5f4:	00000760 	.word	0x00000760
     5f8:	0000062c 	.word	0x0000062c
     5fc:	00000760 	.word	0x00000760
     600:	0000061c 	.word	0x0000061c
     604:	00000760 	.word	0x00000760
     608:	00000760 	.word	0x00000760
     60c:	00000760 	.word	0x00000760
     610:	00000760 	.word	0x00000760
     614:	00000760 	.word	0x00000760
     618:	0000062c 	.word	0x0000062c
		case 0x06: // Receive Line Status
			dummy = U1LSR; // Just clear the interrupt source
     61c:	e5d30014 	ldrb	r0, [r3, #20]
     620:	e20000ff 	and	r0, r0, #255	; 0xff
     624:	e5cd0007 	strb	r0, [sp, #7]
			break;
     628:	ea00004c 	b	760 <protocol_in+0x1bc>

		case 0x04: // Receive Data Available
		case 0x0C: // Character Time-Out
			cmd_in.buff[cmd_in.i] = U1RBR;
     62c:	e5d30000 	ldrb	r0, [r3]
     630:	e20000ff 	and	r0, r0, #255	; 0xff
     634:	e0817002 	add	r7, r1, r2
     638:	e5c70018 	strb	r0, [r7, #24]

			if (cmd_in.buff[cmd_in.i] == END_CMD) {
     63c:	e35000fe 	cmp	r0, #254	; 0xfe
     640:	1a00003c 	bne	738 <protocol_in+0x194>
				// ENGINES
				if (cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] == ENGINES) {
     644:	e2420003 	sub	r0, r2, #3
     648:	e200001f 	and	r0, r0, #31
     64c:	e0817000 	add	r7, r1, r0
     650:	e5d77018 	ldrb	r7, [r7, #24]
     654:	e35700b0 	cmp	r7, #176	; 0xb0
     658:	1a00002a 	bne	708 <protocol_in+0x164>
					log_string_debug("ENGINES\n");

					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)]),
     65c:	e2427002 	sub	r7, r2, #2
     660:	e207701f 	and	r7, r7, #31
     664:	e0818007 	add	r8, r1, r7
     668:	e5d8a018 	ldrb	sl, [r8, #24]
								(unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]));
     66c:	e2429001 	sub	r9, r2, #1
     670:	e209901f 	and	r9, r9, #31
     674:	e0818009 	add	r8, r1, r9
			if (cmd_in.buff[cmd_in.i] == END_CMD) {
				// ENGINES
				if (cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] == ENGINES) {
					log_string_debug("ENGINES\n");

					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)]),
     678:	e5d88018 	ldrb	r8, [r8, #24]
/**
 * Set the output pwm value
 */
inline void set_wheel_pwm(unsigned short left_wheel, unsigned short right_wheel) {

	if (left_wheel > 8)
     67c:	e35a0008 	cmp	sl, #8
		left_wheel -= 8;
     680:	824aa008 	subhi	sl, sl, #8
     684:	81a0a80a 	lslhi	sl, sl, #16
     688:	81a0a82a 	lsrhi	sl, sl, #16
	else
		left_wheel = 8;
     68c:	93a0a008 	movls	sl, #8

	if (right_wheel & PWM_DIR) { // Forward
     690:	e3180080 	tst	r8, #128	; 0x80
		T0MR2 = 256;
     694:	15845020 	strne	r5, [r4, #32]
		T0MR1 = 256 - (right_wheel & ~PWM_DIR)*2;
     698:	13c88080 	bicne	r8, r8, #128	; 0x80
     69c:	12688080 	rsbne	r8, r8, #128	; 0x80
     6a0:	11a08088 	lslne	r8, r8, #1
     6a4:	1584801c 	strne	r8, [r4, #28]
	} else { // Backwards
		T0MR1 = 256;
     6a8:	0584501c 	streq	r5, [r4, #28]
		T0MR2 = 256 - right_wheel*2;
     6ac:	02688080 	rsbeq	r8, r8, #128	; 0x80
     6b0:	01a08088 	lsleq	r8, r8, #1
     6b4:	05848020 	streq	r8, [r4, #32]
	}

	if (left_wheel & PWM_DIR) { // Forward
     6b8:	e31a0080 	tst	sl, #128	; 0x80
		T1MR0 = 256;
     6bc:	15865018 	strne	r5, [r6, #24]
		T1MR1 = 256 - (left_wheel & ~PWM_DIR)*2;
     6c0:	13ca8080 	bicne	r8, sl, #128	; 0x80
     6c4:	12688080 	rsbne	r8, r8, #128	; 0x80
     6c8:	11a08088 	lslne	r8, r8, #1
     6cc:	1586801c 	strne	r8, [r6, #28]
	} else { // Backwards
		T1MR1 = 256;
     6d0:	0586501c 	streq	r5, [r6, #28]
		T1MR0 = 256 - left_wheel*2;
     6d4:	026a8080 	rsbeq	r8, sl, #128	; 0x80
     6d8:	01a08088 	lsleq	r8, r8, #1
     6dc:	05868018 	streq	r8, [r6, #24]
					log_string_debug("ENGINES\n");

					set_wheel_pwm((unsigned short) (cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)]),
								(unsigned short) (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)]));

					cmd_in.buff[(cmd_in.i-3) & (CMD_BUFF_SIZE-1)] = 0;
     6e0:	e0810000 	add	r0, r1, r0
     6e4:	e5c0c018 	strb	ip, [r0, #24]
					cmd_in.buff[(cmd_in.i-2) & (CMD_BUFF_SIZE-1)] = 0;
     6e8:	e0810007 	add	r0, r1, r7
     6ec:	e5c0c018 	strb	ip, [r0, #24]
					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
     6f0:	e0810009 	add	r0, r1, r9
     6f4:	e5c0c018 	strb	ip, [r0, #24]
					cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)] = 0;
     6f8:	e202001f 	and	r0, r2, #31
     6fc:	e0810000 	add	r0, r1, r0
     700:	e5c0c018 	strb	ip, [r0, #24]
     704:	ea00000b 	b	738 <protocol_in+0x194>
				}
				// SYNC
				else if (cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] == SYNC) {
     708:	e2420001 	sub	r0, r2, #1
     70c:	e200001f 	and	r0, r0, #31
     710:	e0817000 	add	r7, r1, r0
     714:	e5d77018 	ldrb	r7, [r7, #24]
     718:	e35700a0 	cmp	r7, #160	; 0xa0
     71c:	1a000005 	bne	738 <protocol_in+0x194>
					log_string_debug("SYNC\n");

					send_data = 1;
     720:	e5c1b038 	strb	fp, [r1, #56]	; 0x38

					cmd_in.buff[(cmd_in.i-1) & (CMD_BUFF_SIZE-1)] = 0;
     724:	e0810000 	add	r0, r1, r0
     728:	e5c0c018 	strb	ip, [r0, #24]
					cmd_in.buff[(cmd_in.i) & (CMD_BUFF_SIZE-1)] = 0;
     72c:	e202001f 	and	r0, r2, #31
     730:	e0810000 	add	r0, r1, r0
     734:	e5c0c018 	strb	ip, [r0, #24]
				}
			}

			cmd_in.i = (cmd_in.i + 1) & (CMD_BUFF_SIZE-1);
     738:	e2822001 	add	r2, r2, #1
     73c:	e202201f 	and	r2, r2, #31
			break;
     740:	ea000006 	b	760 <protocol_in+0x1bc>

		case 0x02: // THRE Interrupt, transmit interrupt
			U1THR = dummy; // Just clear the interrupt source
     744:	e5dd0007 	ldrb	r0, [sp, #7]
     748:	e20000ff 	and	r0, r0, #255	; 0xff
     74c:	e5c30000 	strb	r0, [r3]
			break;
     750:	ea000002 	b	760 <protocol_in+0x1bc>

		case 0x00: // Modem Interrupt
			dummy = U1MSR; // Just clear the interrupt source
     754:	e5d30018 	ldrb	r0, [r3, #24]
     758:	e20000ff 	and	r0, r0, #255	; 0xff
     75c:	e5cd0007 	strb	r0, [sp, #7]

	volatile char dummy;
	volatile char iir;

	// Repeat while there is at least one interrupt source.
	while (((iir = U1IIR) & 0x01) == 0) {
     760:	e5d30008 	ldrb	r0, [r3, #8]
     764:	e20000ff 	and	r0, r0, #255	; 0xff
     768:	e5cd0006 	strb	r0, [sp, #6]
     76c:	e5dd0006 	ldrb	r0, [sp, #6]
     770:	e3100001 	tst	r0, #1
     774:	0affff96 	beq	5d4 <protocol_in+0x30>
     778:	e59f3018 	ldr	r3, [pc, #24]	; 798 <protocol_in+0x1f4>
     77c:	e5832014 	str	r2, [r3, #20]
		}
	}

	log_string_debug("<< protocol_in\n");

	VICVectAddr = 0;
     780:	e3a02000 	mov	r2, #0
     784:	e3e03000 	mvn	r3, #0
     788:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
     78c:	e28dd00c 	add	sp, sp, #12
     790:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
     794:	e25ef004 	subs	pc, lr, #4
     798:	4000009c 	.word	0x4000009c
     79c:	e0010000 	.word	0xe0010000
     7a0:	e0008000 	.word	0xe0008000
     7a4:	e0004000 	.word	0xe0004000

000007a8 <pulse_in>:
 *
 * Count the encoder pulses using CAP2.0-2 and EINT0 as interrupt sources
 *
 * Handle i2c requests
 */
void pulse_in(void) {
     7a8:	e92d000c 	push	{r2, r3}
     7ac:	e24dd008 	sub	sp, sp, #8

	//log_string_debug(">> pulse_in\n");

	volatile unsigned short ir = T2IR;
     7b0:	e59f3130 	ldr	r3, [pc, #304]	; 8e8 <pulse_in+0x140>
     7b4:	e5d33000 	ldrb	r3, [r3]
     7b8:	e20330ff 	and	r3, r3, #255	; 0xff
     7bc:	e1cd30b6 	strh	r3, [sp, #6]

	// pulses in int
	if (ir & (0x1 << 4)) { //CAP2.0 left encoder
     7c0:	e1dd30b6 	ldrh	r3, [sp, #6]
     7c4:	e3130010 	tst	r3, #16
     7c8:	0a000009 	beq	7f4 <pulse_in+0x4c>
		//log_string_debug("FIQ2\n");
		forward_l--;
     7cc:	e59f3118 	ldr	r3, [pc, #280]	; 8ec <pulse_in+0x144>
     7d0:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
     7d4:	e2422001 	sub	r2, r2, #1
     7d8:	e583203c 	str	r2, [r3, #60]	; 0x3c
		T2IR |= 0x1 << 4; // reset CAP2.0
     7dc:	e59f3104 	ldr	r3, [pc, #260]	; 8e8 <pulse_in+0x140>
     7e0:	e5d32000 	ldrb	r2, [r3]
     7e4:	e20220ff 	and	r2, r2, #255	; 0xff
     7e8:	e3822010 	orr	r2, r2, #16
     7ec:	e5c32000 	strb	r2, [r3]
     7f0:	ea000036 	b	8d0 <pulse_in+0x128>
	}
	else if (ir & (0x1 << 5)) { //CAP2.1 right encoder
     7f4:	e1dd30b6 	ldrh	r3, [sp, #6]
     7f8:	e3130020 	tst	r3, #32
     7fc:	0a000011 	beq	848 <pulse_in+0xa0>
		//log_string_debug("FIQ3\n");
		forward_r++;
     800:	e59f20e4 	ldr	r2, [pc, #228]	; 8ec <pulse_in+0x144>
     804:	e5923040 	ldr	r3, [r2, #64]	; 0x40
     808:	e2833001 	add	r3, r3, #1
     80c:	e5823040 	str	r3, [r2, #64]	; 0x40
		if (forward_r > 0)
     810:	e3530000 	cmp	r3, #0
			encoder_count[1]++;
     814:	c1a03002 	movgt	r3, r2
     818:	c5922048 	ldrgt	r2, [r2, #72]	; 0x48
     81c:	c2822001 	addgt	r2, r2, #1
		else
			encoder_count[1]--;
     820:	d59f30c4 	ldrle	r3, [pc, #196]	; 8ec <pulse_in+0x144>
     824:	d5932048 	ldrle	r2, [r3, #72]	; 0x48
     828:	d2422001 	suble	r2, r2, #1
     82c:	e5832048 	str	r2, [r3, #72]	; 0x48
		T2IR |= 0x1 << 5; // reset CAP2.1
     830:	e59f30b0 	ldr	r3, [pc, #176]	; 8e8 <pulse_in+0x140>
     834:	e5d32000 	ldrb	r2, [r3]
     838:	e20220ff 	and	r2, r2, #255	; 0xff
     83c:	e3822020 	orr	r2, r2, #32
     840:	e5c32000 	strb	r2, [r3]
     844:	ea000021 	b	8d0 <pulse_in+0x128>
	}
	else if (ir & (0x1 << 6)) { //CAP2.2 right encoder
     848:	e1dd30b6 	ldrh	r3, [sp, #6]
     84c:	e3130040 	tst	r3, #64	; 0x40
     850:	0a000009 	beq	87c <pulse_in+0xd4>
		//log_string_debug("FIQ4\n");
		forward_r--;
     854:	e59f3090 	ldr	r3, [pc, #144]	; 8ec <pulse_in+0x144>
     858:	e5932040 	ldr	r2, [r3, #64]	; 0x40
     85c:	e2422001 	sub	r2, r2, #1
     860:	e5832040 	str	r2, [r3, #64]	; 0x40
		T2IR |= 0x1 << 6; // reset CAP2.2
     864:	e59f307c 	ldr	r3, [pc, #124]	; 8e8 <pulse_in+0x140>
     868:	e5d32000 	ldrb	r2, [r3]
     86c:	e20220ff 	and	r2, r2, #255	; 0xff
     870:	e3822040 	orr	r2, r2, #64	; 0x40
     874:	e5c32000 	strb	r2, [r3]
     878:	ea000014 	b	8d0 <pulse_in+0x128>
	}
	else if (EXTINT & 0x1 << 0) { // EINT0 left encoder
     87c:	e59f306c 	ldr	r3, [pc, #108]	; 8f0 <pulse_in+0x148>
     880:	e5d33040 	ldrb	r3, [r3, #64]	; 0x40
     884:	e3130001 	tst	r3, #1
     888:	0a000010 	beq	8d0 <pulse_in+0x128>
		//log_string_debug("FIQ1\n");
		forward_l++;
     88c:	e59f2058 	ldr	r2, [pc, #88]	; 8ec <pulse_in+0x144>
     890:	e592303c 	ldr	r3, [r2, #60]	; 0x3c
     894:	e2833001 	add	r3, r3, #1
     898:	e582303c 	str	r3, [r2, #60]	; 0x3c
		if (forward_l > 0)
     89c:	e3530000 	cmp	r3, #0
			encoder_count[0]++;
     8a0:	c1a03002 	movgt	r3, r2
     8a4:	c5922044 	ldrgt	r2, [r2, #68]	; 0x44
     8a8:	c2822001 	addgt	r2, r2, #1
		else
			encoder_count[0]--;
     8ac:	d59f3038 	ldrle	r3, [pc, #56]	; 8ec <pulse_in+0x144>
     8b0:	d5932044 	ldrle	r2, [r3, #68]	; 0x44
     8b4:	d2422001 	suble	r2, r2, #1
     8b8:	e5832044 	str	r2, [r3, #68]	; 0x44
		EXTINT |= 0x1 << 0; // reset EINT0
     8bc:	e59f302c 	ldr	r3, [pc, #44]	; 8f0 <pulse_in+0x148>
     8c0:	e5d32040 	ldrb	r2, [r3, #64]	; 0x40
     8c4:	e20220ff 	and	r2, r2, #255	; 0xff
     8c8:	e3822001 	orr	r2, r2, #1
     8cc:	e5c32040 	strb	r2, [r3, #64]	; 0x40
	}

	//log_string_debug("<< pulse_in\n");

	VICVectAddr = 0;
     8d0:	e3a02000 	mov	r2, #0
     8d4:	e3e03000 	mvn	r3, #0
     8d8:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
     8dc:	e28dd008 	add	sp, sp, #8
     8e0:	e8bd000c 	pop	{r2, r3}
     8e4:	e25ef004 	subs	pc, lr, #4
     8e8:	e0070000 	.word	0xe0070000
     8ec:	4000009c 	.word	0x4000009c
     8f0:	e01fc100 	.word	0xe01fc100

000008f4 <error>:
/**
 *
 */
void error(void){
	log_string_error("irq error");
}
     8f4:	e25ef004 	subs	pc, lr, #4

000008f8 <logger_init>:
 * ou UARTn_baudrate = PCLK / ( 16 * ( 256 * UnDLM + UnDLL))
 * 115131 = 15MHz / ( 16 * ( 256*0 + 6) * ( 1 + 5/14) )
 * 115200 = 14.7456MHz / ( 16 * ( 256*0 + 8) )
 */
void logger_init(void){ // using UART0
	PINSEL0 |= 0x05; // Set the pins function
     8f8:	e59f3054 	ldr	r3, [pc, #84]	; 954 <logger_init+0x5c>
     8fc:	e5932000 	ldr	r2, [r3]
     900:	e3822005 	orr	r2, r2, #5
     904:	e5832000 	str	r2, [r3]
	U0FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable
     908:	e59f3048 	ldr	r3, [pc, #72]	; 958 <logger_init+0x60>
     90c:	e3a02007 	mov	r2, #7
     910:	e5c32008 	strb	r2, [r3, #8]
	U0LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
     914:	e3e0207c 	mvn	r2, #124	; 0x7c
     918:	e5c3200c 	strb	r2, [r3, #12]

#ifdef CRYSTAL12MHz
	U0DLL	 = 0x06; // DivisorLatchLow bit
     91c:	e3a02006 	mov	r2, #6
     920:	e5c32000 	strb	r2, [r3]
	U0DLM	 = 0x00; // DivisorLatchHigh bit
     924:	e3a02000 	mov	r2, #0
     928:	e5c32004 	strb	r2, [r3, #4]
	U0FDR	|= 0x05; // DivAddVal
     92c:	e5d32028 	ldrb	r2, [r3, #40]	; 0x28
     930:	e20220ff 	and	r2, r2, #255	; 0xff
     934:	e3822005 	orr	r2, r2, #5
     938:	e5c32028 	strb	r2, [r3, #40]	; 0x28
	U0FDR	|= 0x0E << 4; // MulVal = 14
     93c:	e5d32028 	ldrb	r2, [r3, #40]	; 0x28
     940:	e38220e0 	orr	r2, r2, #224	; 0xe0
     944:	e5c32028 	strb	r2, [r3, #40]	; 0x28
#ifdef CRYSTAL14745600Hz
	U0DLL	 = 0x08; // DivisorLatchLow bit
	U0DLM	 = 0x00; // DivisorLatchHigh bit
#endif

	U0LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
     948:	e3a02003 	mov	r2, #3
     94c:	e5c3200c 	strb	r2, [r3, #12]
}
     950:	e12fff1e 	bx	lr
     954:	e002c000 	.word	0xe002c000
     958:	e000c000 	.word	0xe000c000

0000095c <log_int>:
static void log_char(char c){
	U0THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
	while(!(U0LSR & 0x40));
}

void log_int(int num){
     95c:	e92d4038 	push	{r3, r4, r5, lr}
	if(num & 0x80000000){ // se for negativo
     960:	e2504000 	subs	r4, r0, #0
     964:	aa000003 	bge	978 <log_int+0x1c>
		log_char('-');
     968:	e3a0002d 	mov	r0, #45	; 0x2d
     96c:	ebfffde6 	bl	10c <log_char>
		num = ~num;
		num += 0x1;
     970:	e2644000 	rsb	r4, r4, #0
     974:	ea000001 	b	980 <log_int+0x24>
	}else
		log_char(' ');
     978:	e3a00020 	mov	r0, #32
     97c:	ebfffde2 	bl	10c <log_char>
	log_char(ascii[num >> 28]);
     980:	e59f5078 	ldr	r5, [pc, #120]	; a00 <log_int+0xa4>
     984:	e7d50e44 	ldrb	r0, [r5, r4, asr #28]
     988:	ebfffddf 	bl	10c <log_char>
	log_char(ascii[num >> 24 & 0x0000000f]);
     98c:	e1a03c44 	asr	r3, r4, #24
     990:	e203300f 	and	r3, r3, #15
     994:	e7d50003 	ldrb	r0, [r5, r3]
     998:	ebfffddb 	bl	10c <log_char>
	log_char(ascii[num >> 20 & 0x0000000f]);
     99c:	e1a03a44 	asr	r3, r4, #20
     9a0:	e203300f 	and	r3, r3, #15
     9a4:	e7d50003 	ldrb	r0, [r5, r3]
     9a8:	ebfffdd7 	bl	10c <log_char>
	log_char(ascii[num >> 16 & 0x0000000f]);
     9ac:	e1a03844 	asr	r3, r4, #16
     9b0:	e203300f 	and	r3, r3, #15
     9b4:	e7d50003 	ldrb	r0, [r5, r3]
     9b8:	ebfffdd3 	bl	10c <log_char>
	log_char(ascii[num >> 12 & 0x0000000f]);
     9bc:	e1a03644 	asr	r3, r4, #12
     9c0:	e203300f 	and	r3, r3, #15
     9c4:	e7d50003 	ldrb	r0, [r5, r3]
     9c8:	ebfffdcf 	bl	10c <log_char>
	log_char(ascii[num >> 8 & 0x0000000f]);
     9cc:	e1a03444 	asr	r3, r4, #8
     9d0:	e203300f 	and	r3, r3, #15
     9d4:	e7d50003 	ldrb	r0, [r5, r3]
     9d8:	ebfffdcb 	bl	10c <log_char>
	log_char(ascii[num >> 4 & 0x0000000f]);
     9dc:	e1a03244 	asr	r3, r4, #4
     9e0:	e203300f 	and	r3, r3, #15
     9e4:	e7d50003 	ldrb	r0, [r5, r3]
     9e8:	ebfffdc7 	bl	10c <log_char>
	log_char(ascii[num & 0x0000000f]);
     9ec:	e204400f 	and	r4, r4, #15
     9f0:	e7d50004 	ldrb	r0, [r5, r4]
     9f4:	ebfffdc4 	bl	10c <log_char>
}
     9f8:	e8bd4038 	pop	{r3, r4, r5, lr}
     9fc:	e12fff1e 	bx	lr
     a00:	0000186c 	.word	0x0000186c

00000a04 <log_short>:

void log_short(short num){
     a04:	e92d4038 	push	{r3, r4, r5, lr}
	if(num & 0x8000){ // se for negativo
     a08:	e2504000 	subs	r4, r0, #0
     a0c:	aa000005 	bge	a28 <log_short+0x24>
		log_char('-');
     a10:	e3a0002d 	mov	r0, #45	; 0x2d
     a14:	ebfffdbc 	bl	10c <log_char>
		num = ~num;
		num++;
     a18:	e2644000 	rsb	r4, r4, #0
     a1c:	e1a04804 	lsl	r4, r4, #16
     a20:	e1a04844 	asr	r4, r4, #16
     a24:	ea000001 	b	a30 <log_short+0x2c>
	}else
		log_char(' ');
     a28:	e3a00020 	mov	r0, #32
     a2c:	ebfffdb6 	bl	10c <log_char>
	log_char(ascii[num >> 12]);
     a30:	e59f5038 	ldr	r5, [pc, #56]	; a70 <log_short+0x6c>
     a34:	e7d50644 	ldrb	r0, [r5, r4, asr #12]
     a38:	ebfffdb3 	bl	10c <log_char>
	log_char(ascii[num >> 8 & 0x000f]);
     a3c:	e1a03424 	lsr	r3, r4, #8
     a40:	e203300f 	and	r3, r3, #15
     a44:	e7d50003 	ldrb	r0, [r5, r3]
     a48:	ebfffdaf 	bl	10c <log_char>
	log_char(ascii[num >> 4 & 0x000f]);
     a4c:	e1a03224 	lsr	r3, r4, #4
     a50:	e203300f 	and	r3, r3, #15
     a54:	e7d50003 	ldrb	r0, [r5, r3]
     a58:	ebfffdab 	bl	10c <log_char>
	log_char(ascii[num & 0x000f]);
     a5c:	e204400f 	and	r4, r4, #15
     a60:	e7d50004 	ldrb	r0, [r5, r4]
     a64:	ebfffda8 	bl	10c <log_char>
}
     a68:	e8bd4038 	pop	{r3, r4, r5, lr}
     a6c:	e12fff1e 	bx	lr
     a70:	0000186c 	.word	0x0000186c

00000a74 <log_string>:

void log_string(const char *s){
     a74:	e92d4038 	push	{r3, r4, r5, lr}
	while(*s){
     a78:	e5d03000 	ldrb	r3, [r0]
     a7c:	e3530000 	cmp	r3, #0
     a80:	0a000009 	beq	aac <log_string+0x38>
     a84:	e1a04000 	mov	r4, r0
		if(*s == '\n')
			log_char('\r'); // \n + \r = new line
     a88:	e3a0500d 	mov	r5, #13
	log_char(ascii[num & 0x000f]);
}

void log_string(const char *s){
	while(*s){
		if(*s == '\n')
     a8c:	e353000a 	cmp	r3, #10
			log_char('\r'); // \n + \r = new line
     a90:	01a00005 	moveq	r0, r5
     a94:	0bfffd9c 	bleq	10c <log_char>
		log_char(*s);
     a98:	e5d40000 	ldrb	r0, [r4]
     a9c:	ebfffd9a 	bl	10c <log_char>
	log_char(ascii[num >> 4 & 0x000f]);
	log_char(ascii[num & 0x000f]);
}

void log_string(const char *s){
	while(*s){
     aa0:	e5f43001 	ldrb	r3, [r4, #1]!
     aa4:	e3530000 	cmp	r3, #0
     aa8:	1afffff7 	bne	a8c <log_string+0x18>
		if(*s == '\n')
			log_char('\r'); // \n + \r = new line
		log_char(*s);
		s++;
	}
}
     aac:	e8bd4038 	pop	{r3, r4, r5, lr}
     ab0:	e12fff1e 	bx	lr

00000ab4 <log_byte>:

void log_byte(char c){
     ab4:	e92d4038 	push	{r3, r4, r5, lr}
     ab8:	e1a04000 	mov	r4, r0
	if(c & 0x80){ // se for negativo
     abc:	e3100080 	tst	r0, #128	; 0x80
     ac0:	0a000004 	beq	ad8 <log_byte+0x24>
		log_char('-');
     ac4:	e3a0002d 	mov	r0, #45	; 0x2d
     ac8:	ebfffd8f 	bl	10c <log_char>
		c = ~c;
		c++;
     acc:	e2644000 	rsb	r4, r4, #0
     ad0:	e20440ff 	and	r4, r4, #255	; 0xff
     ad4:	ea000001 	b	ae0 <log_byte+0x2c>
	}else
		log_char(' ');
     ad8:	e3a00020 	mov	r0, #32
     adc:	ebfffd8a 	bl	10c <log_char>
	log_char(ascii[c >> 4]);
     ae0:	e59f5018 	ldr	r5, [pc, #24]	; b00 <log_byte+0x4c>
     ae4:	e7d50224 	ldrb	r0, [r5, r4, lsr #4]
     ae8:	ebfffd87 	bl	10c <log_char>
	log_char(ascii[c & 0x000f]);
     aec:	e204400f 	and	r4, r4, #15
     af0:	e7d50004 	ldrb	r0, [r5, r4]
     af4:	ebfffd84 	bl	10c <log_char>
}
     af8:	e8bd4038 	pop	{r3, r4, r5, lr}
     afc:	e12fff1e 	bx	lr
     b00:	0000186c 	.word	0x0000186c

00000b04 <log2bytes>:

void log2bytes(short c){
     b04:	e92d4038 	push	{r3, r4, r5, lr}
	if(c & 0x8000){ // se for negativo
     b08:	e2504000 	subs	r4, r0, #0
     b0c:	aa000005 	bge	b28 <log2bytes+0x24>
		log_char('-');
     b10:	e3a0002d 	mov	r0, #45	; 0x2d
     b14:	ebfffd7c 	bl	10c <log_char>
		c = ~c;
		c++;
     b18:	e2644000 	rsb	r4, r4, #0
     b1c:	e1a04804 	lsl	r4, r4, #16
     b20:	e1a04844 	asr	r4, r4, #16
     b24:	ea000001 	b	b30 <log2bytes+0x2c>
	}else
		log_char(' ');
     b28:	e3a00020 	mov	r0, #32
     b2c:	ebfffd76 	bl	10c <log_char>
	log_char(ascii[c >> 12]);
     b30:	e59f5038 	ldr	r5, [pc, #56]	; b70 <log2bytes+0x6c>
     b34:	e7d50644 	ldrb	r0, [r5, r4, asr #12]
     b38:	ebfffd73 	bl	10c <log_char>
	log_char(ascii[c >> 8 & 0x000f]);
     b3c:	e1a03424 	lsr	r3, r4, #8
     b40:	e203300f 	and	r3, r3, #15
     b44:	e7d50003 	ldrb	r0, [r5, r3]
     b48:	ebfffd6f 	bl	10c <log_char>
	log_char(ascii[c >> 4 & 0x000f]);
     b4c:	e1a03224 	lsr	r3, r4, #4
     b50:	e203300f 	and	r3, r3, #15
     b54:	e7d50003 	ldrb	r0, [r5, r3]
     b58:	ebfffd6b 	bl	10c <log_char>
	log_char(ascii[c & 0x000f]);
     b5c:	e204400f 	and	r4, r4, #15
     b60:	e7d50004 	ldrb	r0, [r5, r4]
     b64:	ebfffd68 	bl	10c <log_char>
}
     b68:	e8bd4038 	pop	{r3, r4, r5, lr}
     b6c:	e12fff1e 	bx	lr
     b70:	0000186c 	.word	0x0000186c

00000b74 <log4bytes>:

void log4bytes(int c){
     b74:	e92d4038 	push	{r3, r4, r5, lr}
	if(c & 0x80000000){ // se for negativo
     b78:	e2504000 	subs	r4, r0, #0
     b7c:	aa000003 	bge	b90 <log4bytes+0x1c>
		log_char('-');
     b80:	e3a0002d 	mov	r0, #45	; 0x2d
     b84:	ebfffd60 	bl	10c <log_char>
		c = ~c;
		c += 0x1;
     b88:	e2644000 	rsb	r4, r4, #0
     b8c:	ea000001 	b	b98 <log4bytes+0x24>
	}else
		log_char(' ');
     b90:	e3a00020 	mov	r0, #32
     b94:	ebfffd5c 	bl	10c <log_char>
	log_char(ascii[c >> 28]);
     b98:	e59f5078 	ldr	r5, [pc, #120]	; c18 <log4bytes+0xa4>
     b9c:	e7d50e44 	ldrb	r0, [r5, r4, asr #28]
     ba0:	ebfffd59 	bl	10c <log_char>
	log_char(ascii[c >> 24 & 0x0000000f]);
     ba4:	e1a03c44 	asr	r3, r4, #24
     ba8:	e203300f 	and	r3, r3, #15
     bac:	e7d50003 	ldrb	r0, [r5, r3]
     bb0:	ebfffd55 	bl	10c <log_char>
	log_char(ascii[c >> 20 & 0x0000000f]);
     bb4:	e1a03a44 	asr	r3, r4, #20
     bb8:	e203300f 	and	r3, r3, #15
     bbc:	e7d50003 	ldrb	r0, [r5, r3]
     bc0:	ebfffd51 	bl	10c <log_char>
	log_char(ascii[c >> 16 & 0x0000000f]);
     bc4:	e1a03844 	asr	r3, r4, #16
     bc8:	e203300f 	and	r3, r3, #15
     bcc:	e7d50003 	ldrb	r0, [r5, r3]
     bd0:	ebfffd4d 	bl	10c <log_char>
	log_char(ascii[c >> 12 & 0x0000000f]);
     bd4:	e1a03644 	asr	r3, r4, #12
     bd8:	e203300f 	and	r3, r3, #15
     bdc:	e7d50003 	ldrb	r0, [r5, r3]
     be0:	ebfffd49 	bl	10c <log_char>
	log_char(ascii[c >> 8 & 0x0000000f]);
     be4:	e1a03444 	asr	r3, r4, #8
     be8:	e203300f 	and	r3, r3, #15
     bec:	e7d50003 	ldrb	r0, [r5, r3]
     bf0:	ebfffd45 	bl	10c <log_char>
	log_char(ascii[c >> 4 & 0x0000000f]);
     bf4:	e1a03244 	asr	r3, r4, #4
     bf8:	e203300f 	and	r3, r3, #15
     bfc:	e7d50003 	ldrb	r0, [r5, r3]
     c00:	ebfffd41 	bl	10c <log_char>
	log_char(ascii[c & 0x0000000f]);
     c04:	e204400f 	and	r4, r4, #15
     c08:	e7d50004 	ldrb	r0, [r5, r4]
     c0c:	ebfffd3e 	bl	10c <log_char>
}
     c10:	e8bd4038 	pop	{r3, r4, r5, lr}
     c14:	e12fff1e 	bx	lr
     c18:	0000186c 	.word	0x0000186c

00000c1c <i2c_init>:
void i2c_init(void){

	log_string_i2c(">> i2c_init\n");

	// Set the pin function
	PINSEL1 |= 0x1 << 2; // SCL1
     c1c:	e59f3058 	ldr	r3, [pc, #88]	; c7c <i2c_init+0x60>
     c20:	e5932004 	ldr	r2, [r3, #4]
     c24:	e3822004 	orr	r2, r2, #4
     c28:	e5832004 	str	r2, [r3, #4]
	PINSEL1 |= 0x1 << 4; // SDA1
     c2c:	e5932004 	ldr	r2, [r3, #4]
     c30:	e3822010 	orr	r2, r2, #16
     c34:	e5832004 	str	r2, [r3, #4]

	I2C1CONCLR = 0x6C; // clear all flags
     c38:	e2833803 	add	r3, r3, #196608	; 0x30000
     c3c:	e3a0206c 	mov	r2, #108	; 0x6c
     c40:	e5c32018 	strb	r2, [r3, #24]
	I2C1CONSET |= 0x1 << 6; // enable i2c1
     c44:	e5d32000 	ldrb	r2, [r3]
     c48:	e20220ff 	and	r2, r2, #255	; 0xff
     c4c:	e3822040 	orr	r2, r2, #64	; 0x40
     c50:	e5c32000 	strb	r2, [r3]
	I2C1SCLH = 19; // Set the bit rate:
     c54:	e3a02013 	mov	r2, #19
     c58:	e1c321b0 	strh	r2, [r3, #16]
	I2C1SCLL = 19; // 394.7kHz for pclk=15MHz | 388.0kHz for pclk=14.7456MHz
     c5c:	e1c321b4 	strh	r2, [r3, #20]

	// Enable the interrupts
	VICVectCntl2 = 0x33; //Vectored Interrupt slot enabled with source #19 (I2C1)
     c60:	e3e03000 	mvn	r3, #0
     c64:	e3a02033 	mov	r2, #51	; 0x33
     c68:	e5032df7 	str	r2, [r3, #-3575]	; 0xfffff209
	VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ
     c6c:	e5132fef 	ldr	r2, [r3, #-4079]	; 0xfffff011
     c70:	e3822702 	orr	r2, r2, #524288	; 0x80000
     c74:	e5032fef 	str	r2, [r3, #-4079]	; 0xfffff011
	// Enable i2c as FIQ
	//VICIntSelect |= 0x1 << 19;// I2C1 as FIQ
	//VICIntEnable |= 0x1 << 19; //source #19 enabled as FIQ or IRQ

	log_string_i2c("<< i2c_init\n");
}
     c78:	e12fff1e 	bx	lr
     c7c:	e002c000 	.word	0xe002c000

00000c80 <i2c_read_bytes>:
}

int i2c_read_bytes(char reg_addr, char length, char* data) {
	log_string_i2c(">> read_bytes\n");

	buff_size = length;
     c80:	e59f3048 	ldr	r3, [pc, #72]	; cd0 <i2c_read_bytes+0x50>
     c84:	e5831004 	str	r1, [r3, #4]
	buff_pos = 0;
     c88:	e3a01000 	mov	r1, #0
     c8c:	e5831008 	str	r1, [r3, #8]
	ra_buff = reg_addr;
     c90:	e5c30000 	strb	r0, [r3]
	c_buff = data;
     c94:	e583200c 	str	r2, [r3, #12]

	busy = 1;
     c98:	e3a02001 	mov	r2, #1
     c9c:	e5832010 	str	r2, [r3, #16]

	//Setting the interrupt handler location for write byte
	VICVectAddr2 = (unsigned int) &i2c_read_bytes_isr;
     ca0:	e3e03000 	mvn	r3, #0
     ca4:	e59f2028 	ldr	r2, [pc, #40]	; cd4 <i2c_read_bytes+0x54>
     ca8:	e5032ef7 	str	r2, [r3, #-3831]	; 0xfffff109
	//current_isr = &i2c_read_bytes_isr;
	// Send Start bit
	I2C1CONSET = 0x20; // Transmit start condition
     cac:	e3a02020 	mov	r2, #32
     cb0:	e59f3020 	ldr	r3, [pc, #32]	; cd8 <i2c_read_bytes+0x58>
     cb4:	e5c32000 	strb	r2, [r3]

	log_string_i2c("waiting\n");

	while (busy); // busy wait for read process
     cb8:	e59f2010 	ldr	r2, [pc, #16]	; cd0 <i2c_read_bytes+0x50>
     cbc:	e5923010 	ldr	r3, [r2, #16]
     cc0:	e3530000 	cmp	r3, #0
     cc4:	1afffffc 	bne	cbc <i2c_read_bytes+0x3c>

	log_string_i2c("<< read_bytes\n");
	return 1;
}
     cc8:	e3a00001 	mov	r0, #1
     ccc:	e12fff1e 	bx	lr
     cd0:	4000009c 	.word	0x4000009c
     cd4:	0000012c 	.word	0x0000012c
     cd8:	e005c000 	.word	0xe005c000

00000cdc <i2c_read_byte>:

//void i2c_isr(void) {
//	(*current_isr)();
//}

int i2c_read_byte(char reg_addr, char* data) {
     cdc:	e92d4008 	push	{r3, lr}
     ce0:	e1a02001 	mov	r2, r1
	log_string_i2c("read_byte\n");

	int i = i2c_read_bytes(reg_addr,1,data);
     ce4:	e3a01001 	mov	r1, #1
     ce8:	ebffffe4 	bl	c80 <i2c_read_bytes>

	log_string_i2c("read_byte..returning\n");
	return i;
}
     cec:	e8bd4008 	pop	{r3, lr}
     cf0:	e12fff1e 	bx	lr

00000cf4 <i2c_write_byte>:
	c |= data; // combine data with existing byte

	return i2c_write_byte(reg_addr, c);
}

int i2c_write_byte(char reg_addr, char data) {
     cf4:	e24dd008 	sub	sp, sp, #8
     cf8:	e28d3008 	add	r3, sp, #8
     cfc:	e5631001 	strb	r1, [r3, #-1]!
	log_string_i2c("write_byte\n");

	buff_size = 1;
     d00:	e59f204c 	ldr	r2, [pc, #76]	; d54 <i2c_write_byte+0x60>
     d04:	e3a01001 	mov	r1, #1
     d08:	e5821004 	str	r1, [r2, #4]
	buff_pos = 0;
     d0c:	e3a0c000 	mov	ip, #0
     d10:	e582c008 	str	ip, [r2, #8]
	ra_buff = reg_addr;
     d14:	e5c20000 	strb	r0, [r2]
	c_buff = &data;
     d18:	e582300c 	str	r3, [r2, #12]

	busy = 1;
     d1c:	e5821010 	str	r1, [r2, #16]

	//Setting the interrupt handler location for write byte
	VICVectAddr2 = (unsigned int) &i2c_write_byte_isr;
     d20:	e3e03000 	mvn	r3, #0
     d24:	e59f202c 	ldr	r2, [pc, #44]	; d58 <i2c_write_byte+0x64>
     d28:	e5032ef7 	str	r2, [r3, #-3831]	; 0xfffff109
	//current_isr = &i2c_write_byte_isr;
	// Send Start bit
	I2C1CONSET = 0x20; // Transmit start condition
     d2c:	e3a02020 	mov	r2, #32
     d30:	e59f3024 	ldr	r3, [pc, #36]	; d5c <i2c_write_byte+0x68>
     d34:	e5c32000 	strb	r2, [r3]

	while (busy); // busy wait for read process
     d38:	e59f2014 	ldr	r2, [pc, #20]	; d54 <i2c_write_byte+0x60>
     d3c:	e5923010 	ldr	r3, [r2, #16]
     d40:	e3530000 	cmp	r3, #0
     d44:	1afffffc 	bne	d3c <i2c_write_byte+0x48>

	log_string_i2c("write_byte..returning\n");
	return 1;
}
     d48:	e3a00001 	mov	r0, #1
     d4c:	e28dd008 	add	sp, sp, #8
     d50:	e12fff1e 	bx	lr
     d54:	4000009c 	.word	0x4000009c
     d58:	000003ec 	.word	0x000003ec
     d5c:	e005c000 	.word	0xe005c000

00000d60 <i2c_write_bits>:
	}

	VICVectAddr = 0;
}

int i2c_write_bits(char reg_addr, char bit, char length, char data){
     d60:	e92d40f0 	push	{r4, r5, r6, r7, lr}
     d64:	e24dd00c 	sub	sp, sp, #12
     d68:	e1a07000 	mov	r7, r0
     d6c:	e1a05001 	mov	r5, r1
     d70:	e1a04002 	mov	r4, r2
     d74:	e1a06003 	mov	r6, r3
	// 10101111 original value (sample)
	// 10100011 original & ~mask
	// 10101011 masked | value

	char c;
	i2c_read_byte(reg_addr, &c);
     d78:	e28d1007 	add	r1, sp, #7
     d7c:	ebffffd6 	bl	cdc <i2c_read_byte>
	char mask = ((1 << length) - 1) << (bit - length + 1);
     d80:	e2855001 	add	r5, r5, #1
     d84:	e0645005 	rsb	r5, r4, r5
     d88:	e3e03000 	mvn	r3, #0
     d8c:	e1e04413 	mvn	r4, r3, lsl r4
     d90:	e1a04514 	lsl	r4, r4, r5
     d94:	e20440ff 	and	r4, r4, #255	; 0xff
	data <<= (bit - length + 1); // shift data into correct position
	data &= mask; // zero all non-important bits in data
	c &= ~(mask); // zero all important bits in existing byte
     d98:	e5dd1007 	ldrb	r1, [sp, #7]
     d9c:	e1c11004 	bic	r1, r1, r4

	char c;
	i2c_read_byte(reg_addr, &c);
	char mask = ((1 << length) - 1) << (bit - length + 1);
	data <<= (bit - length + 1); // shift data into correct position
	data &= mask; // zero all non-important bits in data
     da0:	e0046516 	and	r6, r4, r6, lsl r5
	c &= ~(mask); // zero all important bits in existing byte
	c |= data; // combine data with existing byte
     da4:	e1811006 	orr	r1, r1, r6
     da8:	e5cd1007 	strb	r1, [sp, #7]

	return i2c_write_byte(reg_addr, c);
     dac:	e1a00007 	mov	r0, r7
     db0:	ebffffcf 	bl	cf4 <i2c_write_byte>
}
     db4:	e28dd00c 	add	sp, sp, #12
     db8:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
     dbc:	e12fff1e 	bx	lr

00000dc0 <mpu_set_clock_source>:
* @see getClockSource()
* @see MPU6050_RA_PWR_MGMT_1
* @see MPU6050_PWR1_CLKSEL_BIT
* @see MPU6050_PWR1_CLKSEL_LENGTH
*/
void mpu_set_clock_source(char source) {
     dc0:	e92d4008 	push	{r3, lr}
     dc4:	e1a03000 	mov	r3, r0
    i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
     dc8:	e3a0006b 	mov	r0, #107	; 0x6b
     dcc:	e3a01002 	mov	r1, #2
     dd0:	e3a02003 	mov	r2, #3
     dd4:	ebffffe1 	bl	d60 <i2c_write_bits>
}
     dd8:	e8bd4008 	pop	{r3, lr}
     ddc:	e12fff1e 	bx	lr

00000de0 <mpu_set_full_scale_gyro_range>:
* @see MPU6050_GYRO_FS_250
* @see MPU6050_RA_GYRO_CONFIG
* @see MPU6050_GCONFIG_FS_SEL_BIT
* @see MPU6050_GCONFIG_FS_SEL_LENGTH
*/
void mpu_set_full_scale_gyro_range(char range) {
     de0:	e92d4008 	push	{r3, lr}
     de4:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
     de8:	e3a0001b 	mov	r0, #27
     dec:	e3a01004 	mov	r1, #4
     df0:	e3a02002 	mov	r2, #2
     df4:	ebffffd9 	bl	d60 <i2c_write_bits>
}
     df8:	e8bd4008 	pop	{r3, lr}
     dfc:	e12fff1e 	bx	lr

00000e00 <mpu_set_full_scale_accel_range>:

/** Set full-scale accelerometer range.
* @param range New full-scale accelerometer range setting
* @see getFullScaleAccelRange()
*/
void mpu_set_full_scale_accel_range(char range) {
     e00:	e92d4008 	push	{r3, lr}
     e04:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);
     e08:	e3a0001c 	mov	r0, #28
     e0c:	e3a01004 	mov	r1, #4
     e10:	e3a02002 	mov	r2, #2
     e14:	ebffffd1 	bl	d60 <i2c_write_bits>
}
     e18:	e8bd4008 	pop	{r3, lr}
     e1c:	e12fff1e 	bx	lr

00000e20 <mpu_set_sleep_enable>:
* @param enabled New sleep mode enabled status
* @see getSleepEnabled()
* @see MPU6050_RA_PWR_MGMT_1
* @see MPU6050_PWR1_SLEEP_BIT
*/
void mpu_set_sleep_enable(int enable) {
     e20:	e92d4008 	push	{r3, lr}
	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, enable);
     e24:	e20030ff 	and	r3, r0, #255	; 0xff
     e28:	e3a0006b 	mov	r0, #107	; 0x6b
     e2c:	e3a01006 	mov	r1, #6
     e30:	e3a02001 	mov	r2, #1
     e34:	ebffffc9 	bl	d60 <i2c_write_bits>
}
     e38:	e8bd4008 	pop	{r3, lr}
     e3c:	e12fff1e 	bx	lr

00000e40 <mpu_set_temperature_sensor_enabled>:
 * values to indicate whether the sensor is enabled or disabled, respectively.
 * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 * bit automatically clears to 0 after the reset has been triggered.
 * @param enabled 1 enabled; 0 disabled
 */
void mpu_set_temperature_sensor_enabled(char enabled) {
     e40:	e92d4008 	push	{r3, lr}
	i2c_write_bits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, 1, 1-enabled);
     e44:	e2603001 	rsb	r3, r0, #1
     e48:	e20330ff 	and	r3, r3, #255	; 0xff
     e4c:	e3a0006b 	mov	r0, #107	; 0x6b
     e50:	e3a01003 	mov	r1, #3
     e54:	e3a02001 	mov	r2, #1
     e58:	ebffffc0 	bl	d60 <i2c_write_bits>
}
     e5c:	e8bd4008 	pop	{r3, lr}
     e60:	e12fff1e 	bx	lr

00000e64 <mpu_set_gyro_rate>:
*
* @param rate New sample rate divider
* @see getRate()
* @see MPU6050_RA_SMPLRT_DIV
*/
void mpu_set_gyro_rate(char rate) {
     e64:	e92d4008 	push	{r3, lr}
     e68:	e1a01000 	mov	r1, r0
    i2c_write_byte(MPU6050_RA_SMPLRT_DIV, rate);
     e6c:	e3a00019 	mov	r0, #25
     e70:	ebffff9f 	bl	cf4 <i2c_write_byte>
}
     e74:	e8bd4008 	pop	{r3, lr}
     e78:	e12fff1e 	bx	lr

00000e7c <mpu_set_DLPF_mode>:
* @return DLFP configuration
* @see MPU6050_RA_CONFIG
* @see MPU6050_CFG_DLPF_CFG_BIT
* @see MPU6050_CFG_DLPF_CFG_LENGTH
*/
void mpu_set_DLPF_mode(char mode) {
     e7c:	e92d4008 	push	{r3, lr}
     e80:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
     e84:	e3a0001a 	mov	r0, #26
     e88:	e3a01002 	mov	r1, #2
     e8c:	e3a02003 	mov	r2, #3
     e90:	ebffffb2 	bl	d60 <i2c_write_bits>
}
     e94:	e8bd4008 	pop	{r3, lr}
     e98:	e12fff1e 	bx	lr

00000e9c <mpu_set_6axis_FIFO_enabled>:

/**
 * Configure FIFO to store data from accelerometer temp and gyro
 * @param enabled 0 disabled; 1 enabled
 */
void mpu_set_6axis_FIFO_enabled(char enabled) {
     e9c:	e92d4008 	push	{r3, lr}
	i2c_write_byte(MPU6050_RA_FIFO_EN, 0x78);
     ea0:	e3a00023 	mov	r0, #35	; 0x23
     ea4:	e3a01078 	mov	r1, #120	; 0x78
     ea8:	ebffff91 	bl	cf4 <i2c_write_byte>
//	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, 1, enabled);
//	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, 1, 0);
//	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, 1, enabled);
//	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, 1, enabled);
//	i2c_write_bits(MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, 1, enabled);
}
     eac:	e8bd4008 	pop	{r3, lr}
     eb0:	e12fff1e 	bx	lr

00000eb4 <mpu_set_interrupt_mode>:

/**
 * Configure interruption mode
 * @param mode 0 active high; 1 active low
 */
void mpu_set_interrupt_mode(char mode) {
     eb4:	e92d4008 	push	{r3, lr}
     eb8:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, 1, mode);
     ebc:	e3a00037 	mov	r0, #55	; 0x37
     ec0:	e3a01007 	mov	r1, #7
     ec4:	e3a02001 	mov	r2, #1
     ec8:	ebffffa4 	bl	d60 <i2c_write_bits>
}
     ecc:	e8bd4008 	pop	{r3, lr}
     ed0:	e12fff1e 	bx	lr

00000ed4 <mpu_set_interrupt_drive>:

/**
 * Set interrupt drive mode
 * @param drive 0 push/pull; 1 open-drain
 */
void mpu_set_interrupt_drive(char drive) {
     ed4:	e92d4008 	push	{r3, lr}
     ed8:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, 1, drive);
     edc:	e3a00037 	mov	r0, #55	; 0x37
     ee0:	e3a01006 	mov	r1, #6
     ee4:	e3a02001 	mov	r2, #1
     ee8:	ebffff9c 	bl	d60 <i2c_write_bits>
}
     eec:	e8bd4008 	pop	{r3, lr}
     ef0:	e12fff1e 	bx	lr

00000ef4 <mpu_set_interrupt_latch>:

/**
 * Set interrupt latch mode
 * @param latch 0 50us pulse; 1 high until interrupt is cleared
 */
void mpu_set_interrupt_latch(char latch) {
     ef4:	e92d4008 	push	{r3, lr}
     ef8:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, 1, latch);
     efc:	e3a00037 	mov	r0, #55	; 0x37
     f00:	e3a01005 	mov	r1, #5
     f04:	e3a02001 	mov	r2, #1
     f08:	ebffff94 	bl	d60 <i2c_write_bits>
}
     f0c:	e8bd4008 	pop	{r3, lr}
     f10:	e12fff1e 	bx	lr

00000f14 <mpu_set_FIFO_overflow_interrupt>:

/**
 * Set FIFO Buffer Overflow interrupt enabled status.
 * @param enabled 1 enabled; 0 disabled
 */
void mpu_set_FIFO_overflow_interrupt(char enabled) {
     f14:	e92d4008 	push	{r3, lr}
     f18:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, 1, enabled);
     f1c:	e3a00038 	mov	r0, #56	; 0x38
     f20:	e3a01004 	mov	r1, #4
     f24:	e3a02001 	mov	r2, #1
     f28:	ebffff8c 	bl	d60 <i2c_write_bits>
}
     f2c:	e8bd4008 	pop	{r3, lr}
     f30:	e12fff1e 	bx	lr

00000f34 <mpu_set_data_ready_interrupt>:

/**
 * Set Data Ready interrupt enabled status.
 * @param enabled 1 enabled; 0 disabled
 */
void mpu_set_data_ready_interrupt(char enabled) {
     f34:	e92d4008 	push	{r3, lr}
     f38:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, 1, enabled);
     f3c:	e3a00038 	mov	r0, #56	; 0x38
     f40:	e3a01000 	mov	r1, #0
     f44:	e3a02001 	mov	r2, #1
     f48:	ebffff84 	bl	d60 <i2c_write_bits>
}
     f4c:	e8bd4008 	pop	{r3, lr}
     f50:	e12fff1e 	bx	lr

00000f54 <mpu_clear_interrupt>:
* These bits clear to 0 after the register has been read. Very useful
* for getting multiple INT statuses, since each single bit read clears
* all of them because it has to read the whole byte.
* @see MPU6050_RA_INT_STATUS
*/
int mpu_clear_interrupt(char* data) {
     f54:	e92d4008 	push	{r3, lr}
     f58:	e1a01000 	mov	r1, r0
	return i2c_read_byte(MPU6050_RA_INT_STATUS, data);
     f5c:	e3a0003a 	mov	r0, #58	; 0x3a
     f60:	ebffff5d 	bl	cdc <i2c_read_byte>
}
     f64:	e8bd4008 	pop	{r3, lr}
     f68:	e12fff1e 	bx	lr

00000f6c <mpu_set_FIFO_enabled>:

/** Enable FIFO usage.
 * @param enabled 1 enabled; 0 disabled
 */
void mpu_set_FIFO_enabled(char enabled) {
     f6c:	e92d4008 	push	{r3, lr}
     f70:	e1a03000 	mov	r3, r0
	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, 1, enabled);
     f74:	e3a0006a 	mov	r0, #106	; 0x6a
     f78:	e3a01006 	mov	r1, #6
     f7c:	e3a02001 	mov	r2, #1
     f80:	ebffff76 	bl	d60 <i2c_write_bits>
}
     f84:	e8bd4008 	pop	{r3, lr}
     f88:	e12fff1e 	bx	lr

00000f8c <mpu_reset_FIFO>:
 * Reset the FIFO.
 * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
 * bit automatically clears to 0 after the reset has been triggered.
 * @param enabled 1 enabled; 0 disabled
 */
void mpu_reset_FIFO(void) {
     f8c:	e92d4008 	push	{r3, lr}
	i2c_write_bits(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);
     f90:	e3a0006a 	mov	r0, #106	; 0x6a
     f94:	e3a01002 	mov	r1, #2
     f98:	e3a02001 	mov	r2, #1
     f9c:	e1a03002 	mov	r3, r2
     fa0:	ebffff6e 	bl	d60 <i2c_write_bits>
}
     fa4:	e8bd4008 	pop	{r3, lr}
     fa8:	e12fff1e 	bx	lr

00000fac <mpu_init>:
* after start-up). This function also sets both the accelerometer and the gyroscope
* to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
* the clock source to use the X Gyro for reference, which is slightly better than
* the default internal clock source.
*/
void mpu_init(void) {
     fac:	e92d4008 	push	{r3, lr}
	log_string_mpu(">> mpu_init\n");

    // configure clock source
	mpu_set_clock_source(MPU6050_CLOCK_PLL_XGYRO);
     fb0:	e3a00001 	mov	r0, #1
     fb4:	ebffff81 	bl	dc0 <mpu_set_clock_source>
	// disable temperature sensor
	mpu_set_temperature_sensor_enabled(0);
     fb8:	e3a00000 	mov	r0, #0
     fbc:	ebffff9f 	bl	e40 <mpu_set_temperature_sensor_enabled>
	// set scale to
	// acc ±2g 16384 LSB/g
	// gyro ± 250 °/s 131 LSB/°/s
    mpu_set_full_scale_gyro_range(MPU6050_GYRO_FS_250);
     fc0:	e3a00000 	mov	r0, #0
     fc4:	ebffff85 	bl	de0 <mpu_set_full_scale_gyro_range>
    mpu_set_full_scale_accel_range(MPU6050_ACCEL_FS_2);
     fc8:	e3a00000 	mov	r0, #0
     fcc:	ebffff8b 	bl	e00 <mpu_set_full_scale_accel_range>

    // divide gyro output rate by 7+1, if DLPF>0 set back to 0 to keep output rate 1kHz
    mpu_set_gyro_rate(7);
     fd0:	e3a00007 	mov	r0, #7
     fd4:	ebffffa2 	bl	e64 <mpu_set_gyro_rate>
    // set digital low pass filter cut off frequency (disabled)
    mpu_set_DLPF_mode(0);
     fd8:	e3a00000 	mov	r0, #0
     fdc:	ebffffa6 	bl	e7c <mpu_set_DLPF_mode>

    // FIFO WAS NOT USED
    // enable FIFO
    mpu_set_6axis_FIFO_enabled(1);
     fe0:	e3a00001 	mov	r0, #1
     fe4:	ebffffac 	bl	e9c <mpu_set_6axis_FIFO_enabled>

    // clear interrupts
	//char source;
	//mpu_clear_interrupt(&source);
    // reset FIFO
    mpu_reset_FIFO();
     fe8:	ebffffe7 	bl	f8c <mpu_reset_FIFO>
    // enable fifo
    mpu_set_FIFO_enabled(1);
     fec:	e3a00001 	mov	r0, #1
     ff0:	ebffffdd 	bl	f6c <mpu_set_FIFO_enabled>

    // stop sleeping
    mpu_set_sleep_enable(0);
     ff4:	e3a00000 	mov	r0, #0
     ff8:	ebffff88 	bl	e20 <mpu_set_sleep_enable>

	log_string_mpu("<< mpu_init\n");
}
     ffc:	e8bd4008 	pop	{r3, lr}
    1000:	e12fff1e 	bx	lr

00001004 <mpu_get_FIFO_size>:
* This value indicates the number of bytes stored in the FIFO buffer. This
* number is in turn the number of bytes that can be read from the FIFO buffer
* and it is directly proportional to the number of samples available given the
* set of sensor data bound to be stored in the FIFO (register 35 and 36).
*/
void mpu_get_FIFO_size(int* size) {
    1004:	e92d4010 	push	{r4, lr}
    1008:	e24dd008 	sub	sp, sp, #8
    100c:	e1a04000 	mov	r4, r0
	char count[2];
	i2c_read_bytes(MPU6050_RA_FIFO_COUNTH, 2, count);
    1010:	e3a00072 	mov	r0, #114	; 0x72
    1014:	e3a01002 	mov	r1, #2
    1018:	e28d2004 	add	r2, sp, #4
    101c:	ebffff17 	bl	c80 <i2c_read_bytes>
	*size = (((int)count[0]) << 8) | count[1];
    1020:	e5dd2004 	ldrb	r2, [sp, #4]
    1024:	e5dd3005 	ldrb	r3, [sp, #5]
    1028:	e1833402 	orr	r3, r3, r2, lsl #8
    102c:	e5843000 	str	r3, [r4]
}
    1030:	e28dd008 	add	sp, sp, #8
    1034:	e8bd4010 	pop	{r4, lr}
    1038:	e12fff1e 	bx	lr

0000103c <mpu_get_motion6>:
*
* @see getAcceleration()
* @see getRotation()
* @see MPU6050_RA_ACCEL_XOUT_H
*/
void mpu_get_motion6(char* buff) {
    103c:	e92d4010 	push	{r4, lr}
    1040:	e24dd010 	sub	sp, sp, #16
    1044:	e1a04000 	mov	r4, r0

	log_string_mpu(">> mpu_get_motion6\n");

	char c[14];
	i2c_read_bytes(MPU6050_RA_ACCEL_XOUT_H, 14, c);
    1048:	e3a0003b 	mov	r0, #59	; 0x3b
    104c:	e3a0100e 	mov	r1, #14
    1050:	e1a0200d 	mov	r2, sp
    1054:	ebffff09 	bl	c80 <i2c_read_bytes>
	*buff = c[0];
    1058:	e5dd3000 	ldrb	r3, [sp]
    105c:	e5c43000 	strb	r3, [r4]
	*(buff+1) = c[1];
    1060:	e5dd3001 	ldrb	r3, [sp, #1]
    1064:	e5c43001 	strb	r3, [r4, #1]
	*(buff+2) = c[2];
    1068:	e5dd3002 	ldrb	r3, [sp, #2]
    106c:	e5c43002 	strb	r3, [r4, #2]
	*(buff+3) = c[3];
    1070:	e5dd3003 	ldrb	r3, [sp, #3]
    1074:	e5c43003 	strb	r3, [r4, #3]
	*(buff+4) = c[4];
    1078:	e5dd3004 	ldrb	r3, [sp, #4]
    107c:	e5c43004 	strb	r3, [r4, #4]
	*(buff+5) = c[5];
    1080:	e5dd3005 	ldrb	r3, [sp, #5]
    1084:	e5c43005 	strb	r3, [r4, #5]
	*(buff+6) = c[8];
    1088:	e5dd3008 	ldrb	r3, [sp, #8]
    108c:	e5c43006 	strb	r3, [r4, #6]
	*(buff+7) = c[9];
    1090:	e5dd3009 	ldrb	r3, [sp, #9]
    1094:	e5c43007 	strb	r3, [r4, #7]
	*(buff+8) = c[10];
    1098:	e5dd300a 	ldrb	r3, [sp, #10]
    109c:	e5c43008 	strb	r3, [r4, #8]
	*(buff+9) = c[11];
    10a0:	e5dd300b 	ldrb	r3, [sp, #11]
    10a4:	e5c43009 	strb	r3, [r4, #9]
	*(buff+10) = c[12];
    10a8:	e5dd300c 	ldrb	r3, [sp, #12]
    10ac:	e5c4300a 	strb	r3, [r4, #10]
	*(buff+11) = c[13];
    10b0:	e5dd300d 	ldrb	r3, [sp, #13]
    10b4:	e5c4300b 	strb	r3, [r4, #11]

	log_string_mpu("<< mpu_get_motion6\n");
}
    10b8:	e28dd010 	add	sp, sp, #16
    10bc:	e8bd4010 	pop	{r4, lr}
    10c0:	e12fff1e 	bx	lr

000010c4 <mpu_get_FIFO_motion6>:
*
* buff:
* ax_h, ax_l, ay_h, ay_l, az_h, az_l, gx_h, gx_l, gy_h, gy_l, gz_h, gz_l,
*
*/
void mpu_get_FIFO_motion6(char* buff) {
    10c4:	e92d4010 	push	{r4, lr}
    10c8:	e24dd010 	sub	sp, sp, #16
    10cc:	e1a04000 	mov	r4, r0

	char c[12];
	i2c_read_bytes(MPU6050_RA_FIFO_R_W, 12, c);
    10d0:	e3a00074 	mov	r0, #116	; 0x74
    10d4:	e3a0100c 	mov	r1, #12
    10d8:	e28d2004 	add	r2, sp, #4
    10dc:	ebfffee7 	bl	c80 <i2c_read_bytes>

	*buff = c[0];
    10e0:	e5dd3004 	ldrb	r3, [sp, #4]
    10e4:	e5c43000 	strb	r3, [r4]
	*(buff+1) = c[1];
    10e8:	e5dd3005 	ldrb	r3, [sp, #5]
    10ec:	e5c43001 	strb	r3, [r4, #1]
	*(buff+2) = c[2];
    10f0:	e5dd3006 	ldrb	r3, [sp, #6]
    10f4:	e5c43002 	strb	r3, [r4, #2]
	*(buff+3) = c[3];
    10f8:	e5dd3007 	ldrb	r3, [sp, #7]
    10fc:	e5c43003 	strb	r3, [r4, #3]
	*(buff+4) = c[4];
    1100:	e5dd3008 	ldrb	r3, [sp, #8]
    1104:	e5c43004 	strb	r3, [r4, #4]
	*(buff+5) = c[5];
    1108:	e5dd3009 	ldrb	r3, [sp, #9]
    110c:	e5c43005 	strb	r3, [r4, #5]
	*(buff+6) = c[6];
    1110:	e5dd300a 	ldrb	r3, [sp, #10]
    1114:	e5c43006 	strb	r3, [r4, #6]
	*(buff+7) = c[7];
    1118:	e5dd300b 	ldrb	r3, [sp, #11]
    111c:	e5c43007 	strb	r3, [r4, #7]
	*(buff+8) = c[8];
    1120:	e5dd300c 	ldrb	r3, [sp, #12]
    1124:	e5c43008 	strb	r3, [r4, #8]
	*(buff+9) = c[9];
    1128:	e5dd300d 	ldrb	r3, [sp, #13]
    112c:	e5c43009 	strb	r3, [r4, #9]
	*(buff+10) = c[10];
    1130:	e5dd300e 	ldrb	r3, [sp, #14]
    1134:	e5c4300a 	strb	r3, [r4, #10]
	*(buff+11) = c[11];
    1138:	e5dd300f 	ldrb	r3, [sp, #15]
    113c:	e5c4300b 	strb	r3, [r4, #11]
//	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_h);
//	i2c_read_byte(MPU6050_RA_FIFO_R_W, gy_l);
//
//	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_h);
//	i2c_read_byte(MPU6050_RA_FIFO_R_W, gz_l);
}
    1140:	e28dd010 	add	sp, sp, #16
    1144:	e8bd4010 	pop	{r4, lr}
    1148:	e12fff1e 	bx	lr

0000114c <main>:
static unsigned short timestamp = 0;

/**
 * Entry point
 */
int main(void){
    114c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    1150:	e24dd00c 	sub	sp, sp, #12
 * 													(P=1 -> PSEL=00, P=2 -> PSEL=01, P=4 -> PSEL=10, P=8 -> PSEL=11)
 */
inline void PLL_Init(void){

#ifdef CRYSTAL12MHz
	PLLCFG=0x24;                // 12MHz crystal      -> 60MHz
    1154:	e59f34c0 	ldr	r3, [pc, #1216]	; 161c <main+0x4d0>
    1158:	e3a02024 	mov	r2, #36	; 0x24
    115c:	e5c32084 	strb	r2, [r3, #132]	; 0x84
#endif
#ifdef CRYSTAL14745600Hz
	PLLCFG=0x23;                // 14.7456MHz crystal -> 58.9824MHz
#endif

	PLLCON=0x1;                 //PLLE = 1, PLLEnable
    1160:	e3a02001 	mov	r2, #1
    1164:	e5c32080 	strb	r2, [r3, #128]	; 0x80
	PLLFEED=0xAA;               // Validation sequence
    1168:	e3e02055 	mvn	r2, #85	; 0x55
    116c:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
	PLLFEED=0x55;               // Validation sequence
    1170:	e28220ab 	add	r2, r2, #171	; 0xab
    1174:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
	while(!(PLLSTAT & 0x400)); // Wait PLL to lock
    1178:	e1d328b8 	ldrh	r2, [r3, #136]	; 0x88
    117c:	e3120b01 	tst	r2, #1024	; 0x400
    1180:	0afffffc 	beq	1178 <main+0x2c>
	PLLCON=0x3;                 // PLLC = 1, PLLConnect, Assert the PLL to be the cclk
    1184:	e59f3490 	ldr	r3, [pc, #1168]	; 161c <main+0x4d0>
    1188:	e3a02003 	mov	r2, #3
    118c:	e5c32080 	strb	r2, [r3, #128]	; 0x80
	PLLFEED=0xAA;               // Validation sequence
    1190:	e3e02055 	mvn	r2, #85	; 0x55
    1194:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
	PLLFEED=0x55;               // Validation sequence
    1198:	e28220ab 	add	r2, r2, #171	; 0xab
    119c:	e5c3208c 	strb	r2, [r3, #140]	; 0x8c
 * > 60MHz         -> MAMTIM = 4 CCLK
 */
inline void MAM_Init(void){

#ifdef CRYSTAL12MHz
	MAMTIM = 4; // 4 clock fetches
    11a0:	e3a02004 	mov	r2, #4
    11a4:	e5c32004 	strb	r2, [r3, #4]
#endif
#ifdef CRYSTAL14745600Hz
	MAMTIM = 3; // 3 clock fetches
#endif
	MAMCR = 2;	// MAM functions fully enabled
    11a8:	e3a02002 	mov	r2, #2
    11ac:	e5c32000 	strb	r2, [r3]
 * for PCLK = CCLK/4
 */
inline void APB_Init(void){
	// peripheral clock = PCLK = CCLK/4
	//APBDIV |= 0x02;
	APBDIV &= ~0x03;
    11b0:	e2833c01 	add	r3, r3, #256	; 0x100
    11b4:	e5d32000 	ldrb	r2, [r3]
    11b8:	e20220fc 	and	r2, r2, #252	; 0xfc
    11bc:	e5c32000 	strb	r2, [r3]

	PLL_Init(); // Turn on PLL clock
	MAM_Init(); // Turn on MAM pre-fetcher
	APB_Init(); // Turn on the peripheral devices clock divider

	logger_init(); // uart0
    11c0:	ebfffdcc 	bl	8f8 <logger_init>
#include "irq.h"

static inline unsigned asm_get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
    11c4:	e10f3000 	mrs	r3, CPSR
static inline unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr(_cpsr & ~IRQ_MASK);
    11c8:	e3c33080 	bic	r3, r3, #128	; 0x80
  return retval;
}

static inline void asm_set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
    11cc:	e129f003 	msr	CPSR_fc, r3
inline void pulses_in_init(void){

	log_string_debug(">> pulses_in_init\n");

	// Set the pin function
	PINSEL1 |= 0x1 << 0;  // EINT0
    11d0:	e59f4448 	ldr	r4, [pc, #1096]	; 1620 <main+0x4d4>
    11d4:	e5943004 	ldr	r3, [r4, #4]
    11d8:	e3833001 	orr	r3, r3, #1
    11dc:	e5843004 	str	r3, [r4, #4]
	PINSEL1 |= 0x2 << 22; // CAP2.0
    11e0:	e5943004 	ldr	r3, [r4, #4]
    11e4:	e3833502 	orr	r3, r3, #8388608	; 0x800000
    11e8:	e5843004 	str	r3, [r4, #4]
	PINSEL1 |= 0x2 << 24; // CAP2.1
    11ec:	e5943004 	ldr	r3, [r4, #4]
    11f0:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
    11f4:	e5843004 	str	r3, [r4, #4]
	PINSEL1 |= 0x2 << 26; // CAP2.2
    11f8:	e5943004 	ldr	r3, [r4, #4]
    11fc:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
    1200:	e5843004 	str	r3, [r4, #4]

	// EINT setup
	EXTMODE |= 0x1 << 0; // EINT is edge sensitive
    1204:	e59f3418 	ldr	r3, [pc, #1048]	; 1624 <main+0x4d8>
    1208:	e5d32048 	ldrb	r2, [r3, #72]	; 0x48
    120c:	e20220ff 	and	r2, r2, #255	; 0xff
    1210:	e3822001 	orr	r2, r2, #1
    1214:	e5c32048 	strb	r2, [r3, #72]	; 0x48
	EXTPOLAR |= 0x1 << 0; // EINT is rising edge sensitive
    1218:	e5d3204c 	ldrb	r2, [r3, #76]	; 0x4c
    121c:	e20220ff 	and	r2, r2, #255	; 0xff
    1220:	e3822001 	orr	r2, r2, #1
    1224:	e5c3204c 	strb	r2, [r3, #76]	; 0x4c
	EXTINT |= 0x1 << 0; // reset EINT0
    1228:	e5d32040 	ldrb	r2, [r3, #64]	; 0x40
    122c:	e20220ff 	and	r2, r2, #255	; 0xff
    1230:	e3822001 	orr	r2, r2, #1
    1234:	e5c32040 	strb	r2, [r3, #64]	; 0x40

	// Timer Setup
	T2CCR |= 0x5 << 0; // capture and interrupt on CAP2.0 rising edge
    1238:	e59f33e8 	ldr	r3, [pc, #1000]	; 1628 <main+0x4dc>
    123c:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
    1240:	e3822005 	orr	r2, r2, #5
    1244:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
	T2CCR |= 0x5 << 3; // capture and interrupt on CAP2.1 rising edge
    1248:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
    124c:	e3822028 	orr	r2, r2, #40	; 0x28
    1250:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
	T2CCR |= 0x5 << 6; // capture and interrupt on CAP2.2 rising edge
    1254:	e1d322b8 	ldrh	r2, [r3, #40]	; 0x28
    1258:	e3822d05 	orr	r2, r2, #320	; 0x140
    125c:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
	T2TCR = 1; //enable T2
    1260:	e3a06001 	mov	r6, #1
    1264:	e5c36004 	strb	r6, [r3, #4]

	// Enable the interrupts
	//VICIntSelect |= 0x1 << 14;// EINT2 as FIQ
	VICVectAddr6 = (unsigned int) &pulse_in;
    1268:	e59f33bc 	ldr	r3, [pc, #956]	; 162c <main+0x4e0>
    126c:	e3e05000 	mvn	r5, #0
    1270:	e5053ee7 	str	r3, [r5, #-3815]	; 0xfffff119
	VICVectCntl6 = 0x2E; // source 14 and enabled
    1274:	e3a0202e 	mov	r2, #46	; 0x2e
    1278:	e5052de7 	str	r2, [r5, #-3559]	; 0xfffff219
	VICIntEnable |= 0x1 << 14; //source #14 enabled as FIQ or IRQ
    127c:	e5152fef 	ldr	r2, [r5, #-4079]	; 0xfffff011
    1280:	e3822901 	orr	r2, r2, #16384	; 0x4000
    1284:	e5052fef 	str	r2, [r5, #-4079]	; 0xfffff011

	//VICIntSelect |= 0x1 << 26;// Timer 2 as FIQ
	VICVectAddr7 = (unsigned int) &pulse_in;
    1288:	e5053ee3 	str	r3, [r5, #-3811]	; 0xfffff11d
	VICVectCntl7 = 0x3A; // source 26 and enabled
    128c:	e3a0303a 	mov	r3, #58	; 0x3a
    1290:	e5053de3 	str	r3, [r5, #-3555]	; 0xfffff21d
	VICIntEnable |= 0x1 << 26; // source #26 enabled as FIQ or IRQ
    1294:	e5153fef 	ldr	r3, [r5, #-4079]	; 0xfffff011
    1298:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
    129c:	e5053fef 	str	r3, [r5, #-4079]	; 0xfffff011
inline void imu_init(void){

	log_string_debug(">> imu_init\n");

	// start the communication with the IMU
	i2c_init();
    12a0:	ebfffe5d 	bl	c1c <i2c_init>

	// configure mpu and start taking samples
	mpu_init();
    12a4:	ebffff40 	bl	fac <mpu_init>
inline void adc_init(void){

	log_string_debug(">> adc_init\n");

	// Set the pin function
	PINSEL1 |= 0x3 << 12; // AD0.0
    12a8:	e5943004 	ldr	r3, [r4, #4]
    12ac:	e3833a03 	orr	r3, r3, #12288	; 0x3000
    12b0:	e5843004 	str	r3, [r4, #4]
	PINSEL1 |= 0x3 << 14; // AD0.1
    12b4:	e5943004 	ldr	r3, [r4, #4]
    12b8:	e3833903 	orr	r3, r3, #49152	; 0xc000
    12bc:	e5843004 	str	r3, [r4, #4]
	PINSEL1 |= 0x3 << 16; // AD0.2
    12c0:	e5943004 	ldr	r3, [r4, #4]
    12c4:	e3833803 	orr	r3, r3, #196608	; 0x30000
    12c8:	e5843004 	str	r3, [r4, #4]
	PINSEL0 |= 0x3 << 20; // AD0.3
    12cc:	e5943000 	ldr	r3, [r4]
    12d0:	e3833603 	orr	r3, r3, #3145728	; 0x300000
    12d4:	e5843000 	str	r3, [r4]
	PINSEL0 |= 0x3 << 22; // AD0.4
    12d8:	e5943000 	ldr	r3, [r4]
    12dc:	e3833503 	orr	r3, r3, #12582912	; 0xc00000
    12e0:	e5843000 	str	r3, [r4]

	// ADC setup
	ADCR |= 0x01 << 16; // Start A/D Conversion in burst mode
    12e4:	e59f3344 	ldr	r3, [pc, #836]	; 1630 <main+0x4e4>
    12e8:	e5932000 	ldr	r2, [r3]
    12ec:	e3822801 	orr	r2, r2, #65536	; 0x10000
    12f0:	e5832000 	str	r2, [r3]
	ADCR |= 0x03 << 8; // 3,75MHz for adc if pclk=15MHz; 3,6864MHz if pclk=14.7456MHz
    12f4:	e5932000 	ldr	r2, [r3]
    12f8:	e3822c03 	orr	r2, r2, #768	; 0x300
    12fc:	e5832000 	str	r2, [r3]
	ADCR |= 0x1F; // Read AD0.0 - AD0.4
    1300:	e5932000 	ldr	r2, [r3]
    1304:	e382201f 	orr	r2, r2, #31
    1308:	e5832000 	str	r2, [r3]
	ADCR |= 0x01 << 21; // The ADC is operational
    130c:	e5932000 	ldr	r2, [r3]
    1310:	e3822602 	orr	r2, r2, #2097152	; 0x200000
    1314:	e5832000 	str	r2, [r3]
inline void pwm_out_init(void){

	log_string_debug(">> pwm_out_init\n");

	// Set the pin function
	PINSEL0 |= 0x2 << 6;  // MAT0.0
    1318:	e5943000 	ldr	r3, [r4]
    131c:	e3833080 	orr	r3, r3, #128	; 0x80
    1320:	e5843000 	str	r3, [r4]
	PINSEL0 |= 0x2 << 10; // MAT0.1
    1324:	e5943000 	ldr	r3, [r4]
    1328:	e3833b02 	orr	r3, r3, #2048	; 0x800
    132c:	e5843000 	str	r3, [r4]
	PINSEL0 |= 0x2 << 24; // MAT1.0
    1330:	e5943000 	ldr	r3, [r4]
    1334:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
    1338:	e5843000 	str	r3, [r4]
	PINSEL0 |= 0x2 << 26; // MAT1.1
    133c:	e5943000 	ldr	r3, [r4]
    1340:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
    1344:	e5843000 	str	r3, [r4]

#ifdef CRYSTAL12MHz
	T0PR = 293; // 255 levels for T2TC in 5ms
    1348:	e59f22e4 	ldr	r2, [pc, #740]	; 1634 <main+0x4e8>
    134c:	e59f12e4 	ldr	r1, [pc, #740]	; 1638 <main+0x4ec>
    1350:	e582100c 	str	r1, [r2, #12]
	T1PR = 293; // TC increments every PR + 1 PCLKs
    1354:	e59f32e0 	ldr	r3, [pc, #736]	; 163c <main+0x4f0>
    1358:	e583100c 	str	r1, [r3, #12]
#ifdef CRYSTAL14745600Hz
	T0PR = 288; // 255 levels for T2TC in 5ms
	T1PR = 288;
#endif

	T0PC = 0; // Prescale = 0
    135c:	e3a01000 	mov	r1, #0
    1360:	e5821010 	str	r1, [r2, #16]
	T1PC = 0;
    1364:	e5831010 	str	r1, [r3, #16]
	T0TC = 0; // Counter = 0
    1368:	e5821008 	str	r1, [r2, #8]
	T1TC = 0;
    136c:	e5831008 	str	r1, [r3, #8]

	T0MCR |= (0x1 << 10); // Reset the counter on MAT0.3
    1370:	e1d201b4 	ldrh	r0, [r2, #20]
    1374:	e3800b01 	orr	r0, r0, #1024	; 0x400
    1378:	e1c201b4 	strh	r0, [r2, #20]
	T1MCR |= (0x1 << 10); // Reset the counter on MAT1.3
    137c:	e1d301b4 	ldrh	r0, [r3, #20]
    1380:	e3800b01 	orr	r0, r0, #1024	; 0x400
    1384:	e1c301b4 	strh	r0, [r3, #20]
	T0MR3 = 255; // MAT0.3 every 255 counts (5ms)
    1388:	e3a000ff 	mov	r0, #255	; 0xff
    138c:	e5820024 	str	r0, [r2, #36]	; 0x24
	T1MR3 = 255; // MAT1.3 every 255 counts (5ms)
    1390:	e5830024 	str	r0, [r3, #36]	; 0x24

	T0PWMCON |= (0x1 << 0); // MAT0.0 configured as PWM output
    1394:	e5920074 	ldr	r0, [r2, #116]	; 0x74
    1398:	e1800006 	orr	r0, r0, r6
    139c:	e5820074 	str	r0, [r2, #116]	; 0x74
	T0PWMCON |= (0x1 << 1); // MAT0.1 configured as PWM output
    13a0:	e5920074 	ldr	r0, [r2, #116]	; 0x74
    13a4:	e3800002 	orr	r0, r0, #2
    13a8:	e5820074 	str	r0, [r2, #116]	; 0x74
	T1PWMCON |= (0x1 << 0); // MAT1.0 configured as PWM output
    13ac:	e5930074 	ldr	r0, [r3, #116]	; 0x74
    13b0:	e1800006 	orr	r0, r0, r6
    13b4:	e5830074 	str	r0, [r3, #116]	; 0x74
	T1PWMCON |= (0x1 << 1); // MAT1.1 configured as PWM output
    13b8:	e5930074 	ldr	r0, [r3, #116]	; 0x74
    13bc:	e3800002 	orr	r0, r0, #2
    13c0:	e5830074 	str	r0, [r3, #116]	; 0x74

	T0MR0 = 256; // initially LOW
    13c4:	e3a00c01 	mov	r0, #256	; 0x100
    13c8:	e5820018 	str	r0, [r2, #24]
	T0MR1 = 256; // initially LOW
    13cc:	e582001c 	str	r0, [r2, #28]
	T1MR0 = 256; // initially LOW
    13d0:	e5830018 	str	r0, [r3, #24]
	T1MR1 = 256; // initially LOW
    13d4:	e583001c 	str	r0, [r3, #28]

	T0TCR = 1; // enable T0
    13d8:	e5c26004 	strb	r6, [r2, #4]
	T1TCR = 1; // enable T1
    13dc:	e5c36004 	strb	r6, [r3, #4]

	log_string_debug(">> protocol_init\n");

	volatile char dummy;

	PINSEL0 |= 0x05 << 16; // Set the pins function
    13e0:	e5943000 	ldr	r3, [r4]
    13e4:	e3833805 	orr	r3, r3, #327680	; 0x50000
    13e8:	e5843000 	str	r3, [r4]
	U1FCR    = 0x07; // FIFOControlRegister, Tx, Rx FIFO Reset and FIFO enable, Rx trigger = 1
    13ec:	e59f324c 	ldr	r3, [pc, #588]	; 1640 <main+0x4f4>
    13f0:	e3a02007 	mov	r2, #7
    13f4:	e5c32008 	strb	r2, [r3, #8]
	U1LCR 	 = 0x83; // DivisorLatchAccessBit = 1,  UART 8N1, allow access to divider-latches
    13f8:	e3e0207c 	mvn	r2, #124	; 0x7c
    13fc:	e5c3200c 	strb	r2, [r3, #12]

#ifdef CRYSTAL12MHz
	U1DLL	 = 0x06; // DivisorLatchLow bit
    1400:	e2822083 	add	r2, r2, #131	; 0x83
    1404:	e5c32000 	strb	r2, [r3]
	U1DLM	 = 0x00; // DivisorLatchHigh bit
    1408:	e5c31004 	strb	r1, [r3, #4]
	U1FDR	|= 0x05; // DivAddVal
    140c:	e5d32028 	ldrb	r2, [r3, #40]	; 0x28
    1410:	e20220ff 	and	r2, r2, #255	; 0xff
    1414:	e3822005 	orr	r2, r2, #5
    1418:	e5c32028 	strb	r2, [r3, #40]	; 0x28
	U1FDR	|= 0x0E << 4; // MulVal = 14
    141c:	e5d32028 	ldrb	r2, [r3, #40]	; 0x28
    1420:	e38220e0 	orr	r2, r2, #224	; 0xe0
    1424:	e5c32028 	strb	r2, [r3, #40]	; 0x28
#ifdef CRYSTAL14745600Hz
	U1DLL	 = 0x08; // DivisorLatchLow bit
	U1DLM	 = 0x00; // DivisorLatchHigh bit
#endif

	U1LCR	 = 0x03; // DivisorLatchAccessBit = 0,  UART 8N1, forbid access to divider-latches
    1428:	e3a02003 	mov	r2, #3
    142c:	e5c3200c 	strb	r2, [r3, #12]

	VICVectAddr4 = (unsigned int) &protocol_in; //Setting the interrupt handler location to the 2th vectored interruption slot
    1430:	e59f220c 	ldr	r2, [pc, #524]	; 1644 <main+0x4f8>
    1434:	e5052eef 	str	r2, [r5, #-3823]	; 0xfffff111
	VICVectCntl4 = 0x27; //Vectored Interrupt slot 2 enabled with source #7 (UART1)
    1438:	e3a02027 	mov	r2, #39	; 0x27
    143c:	e5052def 	str	r2, [r5, #-3567]	; 0xfffff211
	VICIntEnable |= 0x00000080; //source #7 enabled as FIQ or IRQ
    1440:	e5152fef 	ldr	r2, [r5, #-4079]	; 0xfffff011
    1444:	e3822080 	orr	r2, r2, #128	; 0x80
    1448:	e5052fef 	str	r2, [r5, #-4079]	; 0xfffff011

	cmd_out.i = 0;
    144c:	e59f21f4 	ldr	r2, [pc, #500]	; 1648 <main+0x4fc>
    1450:	e582104c 	str	r1, [r2, #76]	; 0x4c
	cmd_in.i = 0;
    1454:	e5821014 	str	r1, [r2, #20]

	dummy = U1IIR;   // Read IrqID - Required to Get Interrupts Started
    1458:	e5d32008 	ldrb	r2, [r3, #8]
    145c:	e20220ff 	and	r2, r2, #255	; 0xff
    1460:	e5cd2007 	strb	r2, [sp, #7]
	U1IER = 1;       // Enable UART1 RX (and THRE Interrupts)
    1464:	e5c36004 	strb	r6, [r3, #4]
 */
inline void sampler_init(void){
	log_string_debug(">> sampler_init\n");

	// set pre scale for sample rate
	T3PR = SAMPLE_RATE; // Increment the timer every PCLK
    1468:	e2833919 	add	r3, r3, #409600	; 0x64000
    146c:	e3a02004 	mov	r2, #4
    1470:	e1c320bc 	strh	r2, [r3, #12]

	T3PC = 0;
    1474:	e1c311b0 	strh	r1, [r3, #16]
	T3TC = 0; // Counter = 0
    1478:	e1c310b8 	strh	r1, [r3, #8]

	T3MCR |= (0x1 << 0); // Interrupt on MAT3.0
    147c:	e1d321b4 	ldrh	r2, [r3, #20]
    1480:	e1822006 	orr	r2, r2, r6
    1484:	e1c321b4 	strh	r2, [r3, #20]
	T3MCR |= (0x1 << 1); // Reset the counter on MAT3.0
    1488:	e1d321b4 	ldrh	r2, [r3, #20]
    148c:	e3822002 	orr	r2, r2, #2
    1490:	e1c321b4 	strh	r2, [r3, #20]

#ifdef CRYSTAL12MHz
	T3MR0 = 15000; // MAT3.0 every 15000/(SAMPLE_RATE + 1) counts (1ms/(SAMPLE_RATE + 1))
    1494:	e59f21b0 	ldr	r2, [pc, #432]	; 164c <main+0x500>
    1498:	e1c321b8 	strh	r2, [r3, #24]
#endif
#ifdef CRYSTAL14745600Hz
	T3MR0 = 14746; // MAT3.0 every 14746/(SAMPLE_RATE + 1) counts (1.000027127ms/(SAMPLE_RATE + 1))
#endif

	VICVectAddr3 = (unsigned int) &sample; //Setting the interrupt handler location
    149c:	e59f21ac 	ldr	r2, [pc, #428]	; 1650 <main+0x504>
    14a0:	e5052ef3 	str	r2, [r5, #-3827]	; 0xfffff10d
	VICVectCntl3 = 0x3B; //Vectored Interrupt slot enabled and with source #27 (TIMER3)
    14a4:	e3a0203b 	mov	r2, #59	; 0x3b
    14a8:	e5052df3 	str	r2, [r5, #-3571]	; 0xfffff20d
	VICIntEnable |= 0x1 << 27; //source #27 enabled as FIQ or IRQ
    14ac:	e5152fef 	ldr	r2, [r5, #-4079]	; 0xfffff011
    14b0:	e3822302 	orr	r2, r2, #134217728	; 0x8000000
    14b4:	e5052fef 	str	r2, [r5, #-4079]	; 0xfffff011

	T3TCR = 1; // enable T3
    14b8:	e5c36004 	strb	r6, [r3, #4]
	adc_init(); // start reading the IR sensor signals			| Burst mode, no interruption
	pwm_out_init(); // start pwm for the H bridges				| Timer 0 and Timer 1 operating in PWM mode, no interruption
	protocol_init(); // start the communication protocol		| uart1, Priority 2
	sampler_init(); // start taking samples at 1kHz				| Timer 3, 1kH, Priority 1

	VICDefVectAddr = (unsigned int) &error;
    14bc:	e59f3190 	ldr	r3, [pc, #400]	; 1654 <main+0x508>
    14c0:	e5053fcb 	str	r3, [r5, #-4043]	; 0xfffff035

	//set_wheel_pwm(RIGHT_WHEEL,0x7F);
	//set_wheel_pwm(LEFT_WHEEL,0x7F);

	while (1) {
		if (send_data) {
    14c4:	e59f317c 	ldr	r3, [pc, #380]	; 1648 <main+0x4fc>
			// while data available
			while(data_out_pos != data_in_pos) {
    14c8:	e3a05f7d 	mov	r5, #500	; 0x1f4
static unsigned short timestamp = 0;

/**
 * Entry point
 */
int main(void){
    14cc:	e2836068 	add	r6, r3, #104	; 0x68

/**
 *
 */
static inline void protocol_out_char(char c){
	U1THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
    14d0:	e2444907 	sub	r4, r4, #114688	; 0x1c000

	//set_wheel_pwm(RIGHT_WHEEL,0x7F);
	//set_wheel_pwm(LEFT_WHEEL,0x7F);

	while (1) {
		if (send_data) {
    14d4:	e5d32038 	ldrb	r2, [r3, #56]	; 0x38
    14d8:	e3520000 	cmp	r2, #0
    14dc:	0afffffc 	beq	14d4 <main+0x388>
    14e0:	ea000044 	b	15f8 <main+0x4ac>
			// while data available
			while(data_out_pos != data_in_pos) {

				log_string_debug("sending data");
				// send next data
				data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
    14e4:	e1d327b0 	ldrh	r2, [r3, #112]	; 0x70
    14e8:	e2822001 	add	r2, r2, #1
    14ec:	e1a02802 	lsl	r2, r2, #16
    14f0:	e1a02822 	lsr	r2, r2, #16
    14f4:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
    14f8:	e1d327b0 	ldrh	r2, [r3, #112]	; 0x70
    14fc:	e202200f 	and	r2, r2, #15
    1500:	e1c327b0 	strh	r2, [r3, #112]	; 0x70

				struct sensors_data* data;
				data = &(sensors_data_buff[data_out_pos]);
    1504:	e1d317b0 	ldrh	r1, [r3, #112]	; 0x70

				// encoders
				cmd_out.buff[0] = (data->encoder_left >> 0x8) & 0xFF;
    1508:	e0811081 	add	r1, r1, r1, lsl #1
    150c:	e0831181 	add	r1, r3, r1, lsl #3
    1510:	e1d127b4 	ldrh	r2, [r1, #116]	; 0x74
    1514:	e1a07422 	lsr	r7, r2, #8
    1518:	e5c37050 	strb	r7, [r3, #80]	; 0x50
				cmd_out.buff[1] = data->encoder_left & 0xFF;
    151c:	e5c32051 	strb	r2, [r3, #81]	; 0x51
				cmd_out.buff[2] = (data->encoder_right >> 0x8) & 0xFF;
    1520:	e1d127b6 	ldrh	r2, [r1, #118]	; 0x76
    1524:	e1a07422 	lsr	r7, r2, #8
    1528:	e5c37052 	strb	r7, [r3, #82]	; 0x52
				cmd_out.buff[3] = data->encoder_right & 0xFF;
    152c:	e5c32053 	strb	r2, [r3, #83]	; 0x53

				// Infra Red
				cmd_out.buff[4] = data->ir_l;
    1530:	e5d1707c 	ldrb	r7, [r1, #124]	; 0x7c
    1534:	e5c37054 	strb	r7, [r3, #84]	; 0x54
				cmd_out.buff[5] = data->ir_ml;
    1538:	e5d1707b 	ldrb	r7, [r1, #123]	; 0x7b
    153c:	e5c37055 	strb	r7, [r3, #85]	; 0x55
				cmd_out.buff[6] = data->ir_m;
    1540:	e5d1707a 	ldrb	r7, [r1, #122]	; 0x7a
    1544:	e5c37056 	strb	r7, [r3, #86]	; 0x56
				cmd_out.buff[7] = data->ir_mr;
    1548:	e5d17079 	ldrb	r7, [r1, #121]	; 0x79
    154c:	e5c37057 	strb	r7, [r3, #87]	; 0x57
				cmd_out.buff[8] = data->ir_r;
    1550:	e5d10078 	ldrb	r0, [r1, #120]	; 0x78
    1554:	e5c30058 	strb	r0, [r3, #88]	; 0x58

				// IMU data
				cmd_out.buff[9] = data->ax_h;
    1558:	e5d1007d 	ldrb	r0, [r1, #125]	; 0x7d
    155c:	e5c30059 	strb	r0, [r3, #89]	; 0x59
				cmd_out.buff[10] = data->ax_l;
    1560:	e5d1007e 	ldrb	r0, [r1, #126]	; 0x7e
    1564:	e5c3005a 	strb	r0, [r3, #90]	; 0x5a
				cmd_out.buff[11] = data->ay_h;
    1568:	e5d1007f 	ldrb	r0, [r1, #127]	; 0x7f
    156c:	e5c3005b 	strb	r0, [r3, #91]	; 0x5b
				cmd_out.buff[12] = data->ay_l;
    1570:	e5d10080 	ldrb	r0, [r1, #128]	; 0x80
    1574:	e5c3005c 	strb	r0, [r3, #92]	; 0x5c
				cmd_out.buff[13] = data->az_h;
    1578:	e5d10081 	ldrb	r0, [r1, #129]	; 0x81
    157c:	e5c3005d 	strb	r0, [r3, #93]	; 0x5d
				cmd_out.buff[14] = data->az_l;
    1580:	e5d10082 	ldrb	r0, [r1, #130]	; 0x82
    1584:	e5c3005e 	strb	r0, [r3, #94]	; 0x5e
				cmd_out.buff[15] = data->gx_h;
    1588:	e5d12083 	ldrb	r2, [r1, #131]	; 0x83
    158c:	e5c3205f 	strb	r2, [r3, #95]	; 0x5f
				cmd_out.buff[16] = data->gx_l;
    1590:	e2812084 	add	r2, r1, #132	; 0x84
    1594:	e5d11084 	ldrb	r1, [r1, #132]	; 0x84
    1598:	e5c31060 	strb	r1, [r3, #96]	; 0x60
				cmd_out.buff[17] = data->gy_h;
    159c:	e5d21001 	ldrb	r1, [r2, #1]
    15a0:	e5c31061 	strb	r1, [r3, #97]	; 0x61
				cmd_out.buff[18] = data->gy_l;
    15a4:	e5d21002 	ldrb	r1, [r2, #2]
    15a8:	e5c31062 	strb	r1, [r3, #98]	; 0x62
				cmd_out.buff[19] = data->gz_h;
    15ac:	e5d21003 	ldrb	r1, [r2, #3]
    15b0:	e5c31063 	strb	r1, [r3, #99]	; 0x63
				cmd_out.buff[20] = data->gz_l;
    15b4:	e5d21004 	ldrb	r1, [r2, #4]
    15b8:	e5c31064 	strb	r1, [r3, #100]	; 0x64

				// Timestamp
				cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
    15bc:	e1d220b6 	ldrh	r2, [r2, #6]
    15c0:	e1a01422 	lsr	r1, r2, #8
    15c4:	e5c31065 	strb	r1, [r3, #101]	; 0x65
				cmd_out.buff[22] = data->timestamp & 0xFF;
    15c8:	e5c32066 	strb	r2, [r3, #102]	; 0x66

				// end cmd
				cmd_out.buff[23] = END_CMD;
    15cc:	e5c3e067 	strb	lr, [r3, #103]	; 0x67
				cmd_out.buff[24] = '\n';
    15d0:	e5c3c068 	strb	ip, [r3, #104]	; 0x68
    15d4:	e283104f 	add	r1, r3, #79	; 0x4f
/**
 *
 */
static inline void protocol_out_cmd(){
	for (unsigned short i = 0; i < cmd_out.i; i++)
		protocol_out_char(cmd_out.buff[i]);
    15d8:	e5f12001 	ldrb	r2, [r1, #1]!

/**
 *
 */
static inline void protocol_out_char(char c){
	U1THR = c;     // TransmitHoldingRegister , DivisorLatchAccessBit must be 0 to transmit
    15dc:	e5c42000 	strb	r2, [r4]
	while(!(U1LSR & 0x40));
    15e0:	e5d42014 	ldrb	r2, [r4, #20]
    15e4:	e3120040 	tst	r2, #64	; 0x40
    15e8:	0afffffc 	beq	15e0 <main+0x494>

/**
 *
 */
static inline void protocol_out_cmd(){
	for (unsigned short i = 0; i < cmd_out.i; i++)
    15ec:	e1510006 	cmp	r1, r6
    15f0:	0a000002 	beq	1600 <main+0x4b4>
    15f4:	eafffff7 	b	15d8 <main+0x48c>
				// Timestamp
				cmd_out.buff[21] = (data->timestamp >> 8) & 0xFF;
				cmd_out.buff[22] = data->timestamp & 0xFF;

				// end cmd
				cmd_out.buff[23] = END_CMD;
    15f8:	e3e0e001 	mvn	lr, #1
				cmd_out.buff[24] = '\n';
    15fc:	e3a0c00a 	mov	ip, #10
	//set_wheel_pwm(LEFT_WHEEL,0x7F);

	while (1) {
		if (send_data) {
			// while data available
			while(data_out_pos != data_in_pos) {
    1600:	e1d317b0 	ldrh	r1, [r3, #112]	; 0x70
    1604:	e19320b5 	ldrh	r2, [r3, r5]
    1608:	e1510002 	cmp	r1, r2
    160c:	1affffb4 	bne	14e4 <main+0x398>
				cmd_out.i = 25;

				protocol_out_cmd();
			}

			send_data = 0;
    1610:	e3a02000 	mov	r2, #0
    1614:	e5c32038 	strb	r2, [r3, #56]	; 0x38
    1618:	eaffffad 	b	14d4 <main+0x388>
    161c:	e01fc000 	.word	0xe01fc000
    1620:	e002c000 	.word	0xe002c000
    1624:	e01fc100 	.word	0xe01fc100
    1628:	e0070000 	.word	0xe0070000
    162c:	000007a8 	.word	0x000007a8
    1630:	e0034000 	.word	0xe0034000
    1634:	e0004000 	.word	0xe0004000
    1638:	00000125 	.word	0x00000125
    163c:	e0008000 	.word	0xe0008000
    1640:	e0010000 	.word	0xe0010000
    1644:	000005a4 	.word	0x000005a4
    1648:	4000009c 	.word	0x4000009c
    164c:	00003a98 	.word	0x00003a98
    1650:	00001738 	.word	0x00001738
    1654:	000008f4 	.word	0x000008f4

00001658 <get_ir_sensor_data>:
 */
void get_ir_sensor_data(char * buff) {

	unsigned short val;

	while(ADDR0 & ((0x1 << 31) == 0));
    1658:	e59f30a0 	ldr	r3, [pc, #160]	; 1700 <get_ir_sensor_data+0xa8>
    165c:	e5932010 	ldr	r2, [r3, #16]
	val = (ADDR0 >> 6) & 0x3FF;
    1660:	e5932010 	ldr	r2, [r3, #16]
	val >>= 0x2; // they want a value from 1 to 255
    1664:	e1a02422 	lsr	r2, r2, #8
	val += (val == 0);
    1668:	e21220ff 	ands	r2, r2, #255	; 0xff
    166c:	13a01000 	movne	r1, #0
    1670:	03a01001 	moveq	r1, #1
    1674:	e0812002 	add	r2, r1, r2
	*buff = (char) val;
    1678:	e5c02000 	strb	r2, [r0]

	while(ADDR1 & ((0x1 << 31) == 0));
    167c:	e5932014 	ldr	r2, [r3, #20]
	val = (ADDR1 >> 6) & 0x3FF;
    1680:	e5932014 	ldr	r2, [r3, #20]
	val >>= 0x2; // they want a value from 1 to 255
    1684:	e1a02422 	lsr	r2, r2, #8
	val += (val == 0);
    1688:	e21220ff 	ands	r2, r2, #255	; 0xff
    168c:	13a01000 	movne	r1, #0
    1690:	03a01001 	moveq	r1, #1
    1694:	e0812002 	add	r2, r1, r2
	*(buff+1) = (char) val;
    1698:	e5c02001 	strb	r2, [r0, #1]

	while(ADDR2 & ((0x1 << 31) == 0));
    169c:	e5932018 	ldr	r2, [r3, #24]
	val = (ADDR2 >> 6) & 0x3FF;
    16a0:	e5932018 	ldr	r2, [r3, #24]
	val >>= 0x2; // they want a value from 1 to 255
    16a4:	e1a02422 	lsr	r2, r2, #8
	val += (val == 0);
    16a8:	e21220ff 	ands	r2, r2, #255	; 0xff
    16ac:	13a01000 	movne	r1, #0
    16b0:	03a01001 	moveq	r1, #1
    16b4:	e0812002 	add	r2, r1, r2
	*(buff+2) = (char) val;
    16b8:	e5c02002 	strb	r2, [r0, #2]

	while(ADDR3 & ((0x1 << 31) == 0));
    16bc:	e593201c 	ldr	r2, [r3, #28]
	val = (ADDR3 >> 6) & 0x3FF;
    16c0:	e593201c 	ldr	r2, [r3, #28]
	val >>= 0x2; // they want a value from 1 to 255
    16c4:	e1a02422 	lsr	r2, r2, #8
	val += (val == 0);
    16c8:	e21220ff 	ands	r2, r2, #255	; 0xff
    16cc:	13a01000 	movne	r1, #0
    16d0:	03a01001 	moveq	r1, #1
    16d4:	e0812002 	add	r2, r1, r2
	*(buff+3) = (char) val;
    16d8:	e5c02003 	strb	r2, [r0, #3]

	while(ADDR4 & ((0x1 << 31) == 0));
    16dc:	e5932020 	ldr	r2, [r3, #32]
	val = (ADDR4 >> 6) & 0x3FF;
    16e0:	e5933020 	ldr	r3, [r3, #32]
	val >>= 0x2; // they want a value from 1 to 255
    16e4:	e1a03423 	lsr	r3, r3, #8
	val += (val == 0);
    16e8:	e21330ff 	ands	r3, r3, #255	; 0xff
    16ec:	13a02000 	movne	r2, #0
    16f0:	03a02001 	moveq	r2, #1
    16f4:	e0823003 	add	r3, r2, r3
	*(buff+4) = (char) val;
    16f8:	e5c03004 	strb	r3, [r0, #4]
}
    16fc:	e12fff1e 	bx	lr
    1700:	e0034000 	.word	0xe0034000

00001704 <get_encoders_count>:
 * Return the count value read from the i'th sensor
 */
void get_encoders_count(short * left_encoder, short * right_encoder) {

	int val;
	val = encoder_count[ENCODER_L - ENCODER_L];
    1704:	e59f3028 	ldr	r3, [pc, #40]	; 1734 <get_encoders_count+0x30>
    1708:	e5932044 	ldr	r2, [r3, #68]	; 0x44
	*left_encoder = val - sent_encoder_count[ENCODER_L - ENCODER_L];
    170c:	e593c1f8 	ldr	ip, [r3, #504]	; 0x1f8
    1710:	e06cc002 	rsb	ip, ip, r2
    1714:	e1c0c0b0 	strh	ip, [r0]
	sent_encoder_count[ENCODER_L - ENCODER_L] = val;
    1718:	e58321f8 	str	r2, [r3, #504]	; 0x1f8

	val = encoder_count[ENCODER_R - ENCODER_L];
    171c:	e5932048 	ldr	r2, [r3, #72]	; 0x48
	*right_encoder = val - sent_encoder_count[ENCODER_R - ENCODER_L];
    1720:	e59301fc 	ldr	r0, [r3, #508]	; 0x1fc
    1724:	e0600002 	rsb	r0, r0, r2
    1728:	e1c100b0 	strh	r0, [r1]
	sent_encoder_count[ENCODER_R - ENCODER_L] = val;
    172c:	e58321fc 	str	r2, [r3, #508]	; 0x1fc
}
    1730:	e12fff1e 	bx	lr
    1734:	4000009c 	.word	0x4000009c

00001738 <sample>:

/**
 * Sample sensors every 1ms (1kHz)
 * data_in_pos -
 */
void sample(void) {
    1738:	e24ee004 	sub	lr, lr, #4
    173c:	e92d50ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, ip, lr}
    1740:	e24dd008 	sub	sp, sp, #8
	volatile unsigned short ir = T3IR;
    1744:	e59f3118 	ldr	r3, [pc, #280]	; 1864 <sample+0x12c>
    1748:	e5d33000 	ldrb	r3, [r3]
    174c:	e20330ff 	and	r3, r3, #255	; 0xff
    1750:	e1cd30b6 	strh	r3, [sp, #6]
	if(ir & 0x1) { // MAT3.0
    1754:	e1dd30b6 	ldrh	r3, [sp, #6]
    1758:	e3130001 	tst	r3, #1
    175c:	0a00003b 	beq	1850 <sample+0x118>
		log_string_debug(">> sample\n");

		log_string_debug("IENABLE\n");
		// enable nested interrupts for i2c and FIQ
		T3IR |= 0x1 << 0; // clear MAT3.0 interrupt
    1760:	e59f30fc 	ldr	r3, [pc, #252]	; 1864 <sample+0x12c>
    1764:	e5d32000 	ldrb	r2, [r3]
    1768:	e20220ff 	and	r2, r2, #255	; 0xff
    176c:	e3822001 	orr	r2, r2, #1
    1770:	e5c32000 	strb	r2, [r3]
		IENABLE
    1774:	e14fe000 	mrs	lr, SPSR
    1778:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    177c:	e321f01f 	msr	CPSR_c, #31
    1780:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)

		// next position in buffer
		data_in_pos = ++data_in_pos % DATA_BUFF_SIZE;
    1784:	e59f30dc 	ldr	r3, [pc, #220]	; 1868 <sample+0x130>
    1788:	e3a02f7d 	mov	r2, #500	; 0x1f4
    178c:	e19310b2 	ldrh	r1, [r3, r2]
    1790:	e2811001 	add	r1, r1, #1
    1794:	e1a01801 	lsl	r1, r1, #16
    1798:	e1a01821 	lsr	r1, r1, #16
    179c:	e18310b2 	strh	r1, [r3, r2]
    17a0:	e19310b2 	ldrh	r1, [r3, r2]
    17a4:	e201100f 	and	r1, r1, #15
    17a8:	e18310b2 	strh	r1, [r3, r2]

		// check for overflow
		if (data_in_pos == data_out_pos) {
    17ac:	e19320b2 	ldrh	r2, [r3, r2]
    17b0:	e1d337b0 	ldrh	r3, [r3, #112]	; 0x70
    17b4:	e1520003 	cmp	r2, r3
    17b8:	1a000008 	bne	17e0 <sample+0xa8>
			log_string_warning("LPC overflow\n");
			// the oldest data will be overwritten
			data_out_pos = ++data_out_pos % DATA_BUFF_SIZE;
    17bc:	e59f30a4 	ldr	r3, [pc, #164]	; 1868 <sample+0x130>
    17c0:	e1d327b0 	ldrh	r2, [r3, #112]	; 0x70
    17c4:	e2822001 	add	r2, r2, #1
    17c8:	e1a02802 	lsl	r2, r2, #16
    17cc:	e1a02822 	lsr	r2, r2, #16
    17d0:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
    17d4:	e1d327b0 	ldrh	r2, [r3, #112]	; 0x70
    17d8:	e202200f 	and	r2, r2, #15
    17dc:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
		}

		// read data and put on local circular buffer
		struct sensors_data* data;
		data = &(sensors_data_buff[data_in_pos]);
    17e0:	e59f4080 	ldr	r4, [pc, #128]	; 1868 <sample+0x130>
    17e4:	e3a03f7d 	mov	r3, #500	; 0x1f4
    17e8:	e19460b3 	ldrh	r6, [r4, r3]

		// read encoder counts
		get_encoders_count(&(data->encoder_left), &(data->encoder_right));
    17ec:	e2845074 	add	r5, r4, #116	; 0x74
    17f0:	e1a07086 	lsl	r7, r6, #1
    17f4:	e0871006 	add	r1, r7, r6
    17f8:	e0851181 	add	r1, r5, r1, lsl #3
    17fc:	e1a00001 	mov	r0, r1
    1800:	e2811002 	add	r1, r1, #2
    1804:	ebffffbe 	bl	1704 <get_encoders_count>

		// read the last IMU data
		mpu_get_motion6(&(data->ax_h));
    1808:	e0873006 	add	r3, r7, r6
    180c:	e0855183 	add	r5, r5, r3, lsl #3
    1810:	e2850009 	add	r0, r5, #9
    1814:	e2855008 	add	r5, r5, #8
    1818:	ebfffe07 	bl	103c <mpu_get_motion6>

		// read IR data
		get_ir_sensor_data(&(data->ir_l));
    181c:	e1a00005 	mov	r0, r5
    1820:	ebffff8c 	bl	1658 <get_ir_sensor_data>

		data->timestamp = timestamp++;
    1824:	e3a03c02 	mov	r3, #512	; 0x200
    1828:	e19420b3 	ldrh	r2, [r4, r3]
    182c:	e0876006 	add	r6, r7, r6
    1830:	e0846186 	add	r6, r4, r6, lsl #3
    1834:	e1c628ba 	strh	r2, [r6, #138]	; 0x8a
    1838:	e2822001 	add	r2, r2, #1
    183c:	e18420b3 	strh	r2, [r4, r3]

		log_string_debug("IDISABLE\n");
		IDISABLE
    1840:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
    1844:	e321f092 	msr	CPSR_c, #146	; 0x92
    1848:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
    184c:	e16ff00e 	msr	SPSR_fsxc, lr

		log_string_debug("<< sample\n");
	}

	VICVectAddr = 0;
    1850:	e3a02000 	mov	r2, #0
    1854:	e3e03000 	mvn	r3, #0
    1858:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfffff031
}
    185c:	e28dd008 	add	sp, sp, #8
    1860:	e8fd90ff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, ip, pc}^
    1864:	e0074000 	.word	0xe0074000
    1868:	4000009c 	.word	0x4000009c

0000186c <ascii>:
    186c:	33323130 37363534 42413938 46454443     0123456789ABCDEF
    187c:	00000000                                ....
